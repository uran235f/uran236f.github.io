<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="uk">

<head>
    <h1>Лекція 2</h1>
	<title>Проектування класів Java</title>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=java&lang=bsh"></script>
</head>

<body>

	<h1>Проектування класів Java</h1>

	<p>Цілі</p>

	<ul>
		<li>Реалізовувати інкапсуляцію</li>
        <li>Реалізовувати спадкування з модифікаторами видимості та композицію</li>
        <li>Реалізовувати поліморфізм</li>
        <li>Перевизначати методи hashCode, equals та toString класа <tt class="prettyprint lang-java">Object</tt></li>
        <li>Створювати та використовувати класи сінглтон та незмінні класи</li>
        <li>Розробляти код з використанням ключового слова static в блоках ініціалізації, змінних, методах та класах</li>
	</ul>

	<p>Об'єктно-орієнтований підхід є серцевиною більшості сучасних основних мов програмування. Для створення високоякісних проектів та програмного забезпечення важливо доре розуміти його концепції. Ця глава про проектування класів та наступна глава про продвинуте проектування класів пропонують соліний фундамент для створення якісних проектів на Java.</p>

    <p>Для розуміння подальшого матеріалу треба добре знати такі прості концепції як методи, поля, як визначається конструктор.</p>

	<h2>Інкапсуляція</h2>

	<p>Структурне програмування передбачає <em>декомпозицію</em> функціональності програмина різні процедури (<em>функції</em>), без приділення значної уваги даним, з якими може працювати кожна така процедура. Функції вільні оперувати та змінювати (зазвичай шлобальні та незахищені) дані.</p>

    <p>В об'єктно-орієнтованому програмуванні (OOP) дані та пов'язана поведінка формують єдину одиницю, яку називають <em>клас</em>. Термін <em>інкапсуляція</em> посилається на поєднання даних та пов'язаніх функцій в єдину одиницю. Наприклад, в класі <tt class="prettyprint lang-java">Circle</tt> <tt class="prettyprint lang-java">radius</tt> та <tt class="prettyprint lang-java">center</tt> визначені як <em>приватні поля</em>. Тепер до полів <tt class="prettyprint lang-java">radius</tt> та <tt class="prettyprint lang-java">center</tt> можна додати такі методи, як <tt class="prettyprint lang-java">draw()</tt> та <tt class="prettyprint lang-java">fillColor()</tt>, оскільки поля та методи близько відносяться одні до одних. Всі дані (поля), потрібні для методів класа доступні всередині самого класа. Іншими словами, клас <em>інкапсулює</em> свої поля та методи разом.</p>

<h3>Модифікатори доступу</h3>

    <p>Модифікатори доступу визначають рівень видимості якоїсь сутності Java (класа, метода чи поля). <em>Модифікатори доступу дозволяють ефективно реалізувати інкапсуляцію</em>. Якби до всіх змінних-членів класа можна було б мати доступ звідусіль, то не було б сенсу збирати ці змінні в клас та інкапсулювати в класі дані та поведінку.</p>

    <p>Екзамен OCPJP 8 влючає як прямі питання про модифікатори доступу, так і непрямі, відповіді на які потребують базових знань про модифікатори доступу. Отже, важливо розуміти різні модифікатори доступу, які підтримуються в Java.</p>

    <p>Java підтримує чотири модифікатори доступу:</p>

    <ul>
        <li>Public - публічний</li>
        <li>Private - приватний</li>
        <li>Protected - захищений</li>
        <li>Default - по замовчанню (модифікатор не вказаний)</li>
    </ul>

    <p>Розглянемо ці чотири типи модифікаторів доступу на прикладі наведених нижче класів програмі для малювання: <tt class="prettyprint lang-java">Shape</tt>, <tt class="prettyprint lang-java">Circle</tt>, <tt class="prettyprint lang-java">Circles</tt>, and <tt class="prettyprint lang-java">Canvas</tt>. Клас <tt class="prettyprint lang-java">Canvas</tt> міститься в пакеті <tt class="prettyprint lang-java">appcanvas</tt>, а інші три класи - в пакеті <tt class="prettyprint lang-java">graphicshape</tt> (дивись Лістинг <a href="#c02l01">2-1</a>).</p>

    <pre id="c02l01" class="prettyprint lang-java">
// Лістинг 2-1. Shape.java, Circle.java, Circles.java, and Canvas.java

// Shape.java
package graphicshape;

class Shape {
    protected int color;
}

// Circle.java
package graphicshape;

import graphicshape.Shape;

public class Circle extends Shape {
    private int radius;     // приватне поле
    public void area() {    // публічний метод
        // доступ до приватного поля radius всередині класа:
        System.out.println("area: " + 3.14 * radius * radius);
    }

    // Метод fillColor з доступом по замовчанню
    void fillColor() {
        // доступ до захищеного поля в під-класі:
        System.out.println("color: " + color);
    }
}

// Circles.java
package graphicshape;

class Circles {
    void getArea() {
        Circle circle = new Circle();
        // виклик публічного метода area() зсередини пакета:
        circle.area();
        // виклик fillColor() з доступом по замовчанню зсередини пакета:
        circle.fillColor();
    }
}

// Canvas.java
package appcanvas;

import graphicshape.Circle;

class Canvas {
    void getArea() {
        Circle circle = new Circle();
        circle.area();  // виклик публічного метода area() ззовні пакета
    }
}
    </pre>

    <h4>Публчний модифікатор доступу</h4>

    <p>Публічний модифікатор доступу найбільш ліберальний. Якщо клас чи його члени оголошені як <em>public</em>, до них можна отримати доступ з боку будь-якого іншого класа поза залежністю від меж пакетів. Це схоже на публічне місце в реальному світі, де можуть зустрітися співробітники фірми з різник підрозділів. На Лістингу <a href="#c02l01">2-1</a> публічний метод <tt class="prettyprint lang-java">area()</tt> в класі <tt class="prettyprint lang-java">Circle</tt> доступний в самому пакеті так само, як і ззовні пакета (в класі <tt class="prettyprint lang-java">Canvas</tt>).</p>

    <hr class="Bomb"/>
    <p><em>Публічний метод</em> класа доступний для зовнішнього світу тільки якщо клас оголошений як публічний. Якщо клас не вказує ніякого модифікатора доступу (тобто, має доступ по замовчанню), тоді публічний доступ доступний тільки з пакету, в якому розташований цей клас.</p>
    <hr/>

    <h4>Приватний модифікатор доступу</h4>

    <p>Приватний модифікатор доступу найбільш суворий. Приватний член класа не доступний поза класом; тільки члени того ж класа можуть мати доступ до цього приватного члена. Схоже на кімнату з бакнківськими комірками, до якої мають доступ деякий авторизований персонал та власники депозиту. В Лістингу <a href="#c02l01">2-1</a> приватне поле <tt class="prettyprint lang-java">radius</tt> класа <tt class="prettyprint lang-java">Circle</tt> доступне лише зсередини класа <tt class="prettyprint lang-java">Circle</tt>, та не доступне для будь-якого іншого класа поза залежністю від оточуючого пакета.</p>

    <h4>Модифікатори доступу: захищений та по замовчанню</h4>

    <p>Захищений модифікатор доступу та модифікатор доступу по замовчанню дуже схожі. Якщо метод або поле оголошені як захищене чи по замовчанню, тоді вони доступні в межах пакету. Для надання доступу по замовчанню не потрібно ніяке ключове слово - без модифікатора доступа член має доступ по замовчанню. Також доступ по замовчанню відомий як доступ з захистом пакета. Захищений та по замовчанню доступи можна порівняти з доступністю конференц-кімнати лише для персоналу одного підрозділу.</p>

    <p>Одна вагома різниця між цими модифікаторами доступу виявляється тоді, коли йдеться про під-клас, який належить іншому пакету в порівнянні з пакетом супер-класа. В такому випадку захищені члени доступні в підкласі, а члени з доступом по замовчанню - ні.</p>

    <hr class="Bomb"/>
    <p>Клас (чи інтерфейс) не можна оголосити як приватний чи захищений. Більш за те, члени - методи чи поля - інтерфейса не можуть бути оголошені як приватні чи захищені.</p>
    <hr/>

    <p>В Лістингу <a hreg="#c02l01">2-1</a> захищене поле <tt class="prettyprint lang-java">color</tt> доступне в класі <tt class="prettyprint lang-java">Circle</tt>, а метод з доступом по замовчанню <tt class="prettyprint lang-java">fillColor()</tt> викликається в класі <tt class="prettyprint lang-java">Circles</tt>.</p>

    <p>Видимість при різних модифікаторах доступу підсумовано в Таблиці <a href="#c02t01">2-1</a>.</p>

    <p><em><strong>Таблиця 2-1.</strong> Модифікатори доступу та їх видимість</em></p>

    <table id="c02t01">
        <tr>
            <th>Модифікатори доступу/доступність</th>
            <th>В тому ж класі</th>
            <th>Підклас в пакеті</th>
            <th>Підклас поза пакетом</th>
            <th>Зовнішній клас в пакеті</th>
            <th>Зовнішній клас поза пакетом</th>
        </tr>
        <tr>
            <td>Публічний</td>
            <td>Так</td><td>Так</td><td>Так</td><td>Так</td><td>Так</td>
        </tr>
        <tr>
            <td>Приватний</td>
            <td>Так</td><td>Ні</td><td>Ні</td><td>Ні</td><td>Ні</td>
        </tr>
        <tr>
            <td>Захищений</td>
            <td>Так</td><td>Так</td><td>Так</td><td>Так</td><td>Ні</td>
        </tr>
        <tr>
            <td>По замовчанню</td>
            <td>Так</td><td>Так</td><td>Ні</td><td>Так</td><td>Ні</td>
        </tr>
    </table>

    <h2>Спадкування</h2>

    <p><em>Спадкування</em> це механізм повторного використання в об'єктно-орієнтованому програмуванні. Із спадкуванням загальні властивості різних об'єктів використовуються разом для формування взамних відносин. Абстрактні та загальні властивості надаються в <em>супер-класі</em>, який доступний для більш специфічних <em>під-класів</em>. Наприклад, кольоровий принтер та чорно-білий принтер це різновиди принтера (<em>одиночне спадкування</em>); МФУ це принтер, сканер та фотокопір (<em>множинне спадкування</em>).</p>

    <p>Чому спадкування - потужна особливість? Тому, що вона забезпечує модулювання класів в ієрархії, а ієрархічна модель легше зрозуміти. Наприклад, транспортні засоби можна логічно категоризувати як двоколісні, триколісні, чотриколісні і так далі. В категорії чотириколісних є автомобілі, мікроавтобуси, автобуси та вантажівки. В категорії автомобілів є хетчбеки, седани та універсали. При створенні ієрархії категорій легше розуміти, моделювати та писати програми.</p>

    <p>Розглянемо простий приклад з попередніх розділів: клас <tt class="prettyprint lang-java">Shape</tt> є базовим класом, а <tt class="prettyprint lang-java">Circle</tt> це породжений клас. Інакше кажучи, <tt class="prettyprint lang-java">Circle</tt> це <tt class="prettyprint lang-java">Shape</tt>; аналогічно, <tt class="prettyprint lang-java">Square</tt> це <tt class="prettyprint lang-java">Shape</tt>. Таким чином, відношення спадкування можна називати <em>відношенням ЦЕ</em> (<em>IS-A relationship</em>).</p>

    <p>В бібліотеці Javaспадкування використовується дуже широко. Рисунок <a href="#c02i01">2-1</a> містить частину спадкової ієрархії з бібліотеки <tt class="prettyprint lang-java">java.lang</tt>. Клас <tt class="prettyprint lang-java">Number</tt> абстрагує різні числові (посилальні)) типи на кшталт <tt class="prettyprint lang-java">Byte</tt>, <tt class="prettyprint lang-java">Integer</tt>, <tt class="prettyprint lang-java">Float</tt>, <tt class="prettyprint lang-java">Double</tt>, <tt class="prettyprint lang-java">Short</tt> та <tt class="prettyprint lang-java">BigDecimal</tt>.</p>

    <p>
        <img id="c02i01" src="img/c02i01.png"/><br/>
        <em><strong>Рисункок 2-1.</strong> Частина спадкової ієрархії в пакеті <tt class="prettyprint lang-java">java.lang</tt></em>
    </p>

    <p>Клас <tt class="prettyprint lang-java">Number</tt> має багато спільних методів, які спадкуються породженими класами. Породжені класи не повинні реалізовувати спільні методи, реалізовані класом <tt class="prettyprint lang-java">Number</tt>. Крім того, можна використовувати породжений тип там, де очікується базовий тип. Наприклад, <tt class="prettyprint lang-java">Byte</tt> це <tt class="prettyprint lang-java">Number</tt>, що означає, що об'єкт типу <tt class="prettyprint lang-java">Byte</tt> можна виористовувати там, де очікується об'єкт типу <tt class="prettyprint lang-java">Number</tt>. Можна писати методи загального призначення (або алгоритми) при написанні методів базового типу. Лістинг <a href="#c02l02">2-2</a> містить простий приклад.</p>

    <pre id="c02l02" class="prettyprint lang-java">
// Лістинг 2-2. TestNumber.java
// Демонструє як абстрагування різних різновидів чисел в ієрархії Number
// стає у практичній нагоді
public class TestNumber {
    // отримати масив чисел та обрахувати їх суму
    public static double sum(Number []nums) {
        double sum = 0.0;
        for(Number num : nums) {
            sum += num.doubleValue();
        }
        return sum;
    }

    public static void main(String []s) {
        // створити масив Number
        Number []nums = new Number[4];
        // призначити об'єкти породжених класів
        nums[0] = Byte.valueOf((byte)10);
        nums[1] = Integer.valueOf(10);
        nums[2] = Float.valueOf(10.0f);
        nums[3] = Double.valueOf(10.0f);
        // передати масив Number для отримання суми та надрукувати результат
        System.out.println("Сума чисел: " + sum(nums));
    }
}
    </pre>

    <p>Програма друкує</p>

    <pre>
Сума чисел: 40.0
    </pre>

    <p>В методі <tt class="prettyprint lang-java">main()</tt> оголошується <tt class="prettyprint lang-java">nums</tt> як <tt class="prettyprint lang-java">Number[]</tt>. Посилання <tt class="prettyprint lang-java">Number</tt> можу містити об'єкти будь-яких з породжених від нього типів. Створюються об'єкти типів <tt class="prettyprint lang-java">Byte</tt>, <tt class="prettyprint lang-java">Integer</tt>, <tt class="prettyprint lang-java">Float</tt> та <tt class="prettyprint lang-java">Double</tt> з початковим значенням <tt class="prettyprint lang-java">10</tt>; масив <tt class="prettyprint lang-java">nums</tt> містить ці елементи. (Зверніть увагу на явне приведення типу в <tt class="prettyprint lang-java">Byte.valueOf((byte) 10)</tt> замість простого <tt class="prettyprint lang-java">Byte.valueOf(10)</tt> - <tt class="prettyprint lang-java">Byte</tt> приймає байтовий елемент <tt class="prettyprint lang-java">10</tt> як <tt class="prettyprint lang-java">int</tt>.)</p>

    <p>Метод <tt class="prettyprint lang-java">sum</tt> приймає <tt class="prettyprint lang-java">Number[]</tt> та повертає суму елементів <tt class="prettyprint lang-java">Number</tt>. Тип <tt class="prettyprint lang-java">double</tt> може містити найбільший діапазон значень, тому використовується саме <tt class="prettyprint lang-java">double</tt> в якості типу результата метода <tt class="prettyprint lang-java">sum</tt>. <tt class="prettyprint lang-java">Number</tt> має метод <tt class="prettyprint lang-java">doubleValue</tt>, який повертає значення <tt class="prettyprint lang-java">Number</tt> як значення <tt class="prettyprint lang-java">double</tt>. Цикл проходить масив, додає значення <tt class="prettyprint lang-java">double</tt> та по закінченню повертає суму.</p>

    <p>Як можна бачити, метод <tt class="prettyprint lang-java">sum()</tt> є загальним методом, який може оперувати будь-яким <tt class="prettyprint lang-java">Number[]</tt>. Схожий приклад можна навести із стандартної бібліотеки Java, де клас <tt class="prettyprint lang-java">java.util.Arrays</tt> має статичний метод <tt class="prettyprint lang-java">binarySearch()</tt>:</p>

    <pre class="prettyprint lang-java">
static int binarySearch(Object[] a, Object key, Comparator c)
    </pre>

    <p>Цей метод здійснює пошук наданого ключа (тип <tt class="prettyprint lang-java">Object</tt>) в даному масиві <tt class="prettyprint lang-java">Objects</tt>. <tt class="prettyprint lang-java">Comparator</tt> це інтерфейс, який оголошує методи <tt class="prettyprint lang-java">equals</tt> та <tt class="prettyprint lang-java">compare</tt>. <tt class="prettyprint lang-java">binarySearch</tt> можна використовувати для об'єктів типу будь-якого класа, який реалізує цей інтерфейс <tt class="prettyprint lang-java">Comparator</tt>. Спадкування це потужна та корисна властивість для написання методів загального призначення.</p>

    <h2>Поліморфізм</h2>

    <p>Грецькі корені терміну <em>поліморфізм</em> означають "багато форм" однієї сутності. В реальності кожне повідомлення супроводжується якимось контекстом. В залежності від контекста може змінюватися значення повідомлення, а також значення відповіді на нього. Так само в ООП: повідомлення може бути інтерпретоване по-різному (поліморфізм), в залежності від об'єкта (конкретного екземпляра).</p>

    <p>Поліморфізм може мати дві форми: <em>динамічна</em> та <em>статична</em>.</p>

    <ul>
        <li>Коли різні форми однієї сутності розв'язуються (визначаються) під час виконання (<em>пізнє зв'язування</em>), такий поліморфізм називається <em>динамічним поліморфізмом</em>. В попередньому розділі про спадкування обговорювалося перевизначення. Перевизначення це приклад <em>поліморфізму часу виконання</em>.</li>
        <li>Коли різні форми однієї сутності розв'язуються (визначаються) під час компіляції (<em>раннє зв'язування</em>), такий поліморфізм називається <em>статичним поліморфізмом</em>. <em>Перевантаження функцій</em> - це приклад статичного поліморфізму, який розглядається далі.</li>
    </ul>

    <p>Зверніть увагу на використання абстрактними методами саме поліморфізму часу виконання. Абстрактні методі в інтерфейсах обговорюватимуться в наступній главі (Глава 3 – Продвинуте проектування класів Java).</p>

    <h3>Поліморфізм часу виконання</h3>

    <p>Як вже було зазначено, посилання на об'єкт базового класа може посилатися на об'єкт породженого класа. З посилання базового класа можна викликати методи; однак, фактичний спосіб виклику залежить від динамічного типу об'єкта, на який вказує посилання базового класа. Тип посилання на базовий клас відомий як <em> статичний тип </em> об’єкта, а фактичний об’єкт, на який вказує посилання під час виконання, відомий як <em> динамічний тип </em> об’єкта.</p>

    <p>Коли компілятор бачить виклик методу з посилання на базовий клас і якщо метод є перезаписуваним методом (нестатичним і нефінальним методом), компілятор відкладає визначення точного методу, який буде викликаний під час виконання (пізнє зв'язування). Під час виконання, на основі фактичного динамічного типу об'єкта, викликається відповідний метод. Цей механізм відомий як <em>  динамічне розв'язування методу </em> або <em> виклик динамічного методу </em>.</p>

    <h4>Поліморфізм часу виконання: Приклад</h4>

    <p>Розглянемо метод <tt class="prettyprint lang-java">area()</tt> в класі <tt class="prettyprint lang-java">Shape</tt>. В залежності від похідного класа — <tt class="prettyprint lang-java">Circle</tt> або <tt class="prettyprint lang-java">Square</tt>, наприклад, — метод <tt class="prettyprint lang-java">area()</tt> буде реалізований по-різному, як показано в Лістингу <a href="#c02l03">2-3</a>.</p>

    <pre id="c02l03" class="prettyprint lang-java">
// Лістинг 2-3. TestShape.java
class Shape {
    public double area() { return 0; } // реалізація по замовчанню
    // інші члени
}

class Circle extends Shape {
    private int radius;
    public Circle(int r) { radius = r; }
    // інші конструктори
    public double area() {return Math.PI * radius * radius; }
    // інші оголошення
}

class Square extends Shape {
    private int side;
    public Square(int a) { side = a; }
    public double area() { return side * side; }
    // інші оголошення
}

public class TestShape {
    public static void main(String []args) {
        Shape shape1 = new Circle(10);
        System.out.println(shape1.area());
        Shape shape2 = new Square(10);
        System.out.println(shape2.area());
    }
}
    </pre>

    <p>Ця програма друкує</p>

    <pre>
314.1592653589793
100.0
    </pre>

    <p>Ця програма показує, як метод <tt class="prettyprint lang-java">area()</tt> викликається на основі динамічного типу <tt class="prettyprint lang-java">Shape</tt>. Оператор <tt class="prettyprint lang-java">shape1.area();</tt> викликає метод <tt class="prettyprint lang-java">area()</tt> класа <tt class="prettyprint lang-java">Circle</tt>, а оператор <tt class="prettyprint lang-java">shape2.area();</tt> викликає метод <tt class="prettyprint lang-java">area()</tt> класа <tt class="prettyprint lang-java">Square</tt>.</p>

    <p>Розглянемо більш фундаментальне питання: навіщо може знадобитися перезаписувати методи? В ООП фундаментальна ідея спадкування полягає в наданні спільної функціональності (по замовчанню) в базовому класі, в той час як похідні класи мають надавати більш специфічну. В базовому класі <tt class="prettyprint lang-java">Shape</tt> та похідних класах <tt class="prettyprint lang-java">Circle</tt> і <tt class="prettyprint lang-java">Square</tt> клас <tt class="prettyprint lang-java">Shape</tt> надає реалізацію метода <tt class="prettyprint lang-java">area()</tt> по замовчанню. Похідні класи <tt class="prettyprint lang-java">Circle</tt> та <tt class="prettyprint lang-java">Square</tt> визначають власні версії метода <tt class="prettyprint lang-java">area()</tt>, які перезаписують метод <tt class="prettyprint lang-java">area()</tt> базового класа. Отже, в залежності від типу створеного похідного об'єкта виклик метода <tt class="prettyprint lang-java">area()</tt> з посилання на базовий клас буде визначений в правильний метод. Перезаписування (чи поліморфізм часу виконання) - це проста, але потужна ідея розширення функціональності.</p>

    <p>Розглянемо поліморфізм часу компіляції (перевантаження). А потім знов повернемося до теми поліморфізму часа виконання для обговорення таких тем, як модифікатори видимості при перезаписуванні та вибір між композицією та спадкуванням.</p>

    <h3>Перевантаження методів</h3>

    <p>Клас може мати багато методів з однаковими іменами. Але треба, щоб список їх параметрів відрізнявся. Якщо надаються різні типи параметрів та/або різна кількість параметрів, то можна визначити багато методів з одним іменем. Ця властивість називається <em>перевантаження метода</em>. Компілятор визначить виклик на користь правильного метода за кількістю та/або типами наданих аргументів.</p>

    <p>Реалізуємо метод в класі <tt class="prettyprint lang-java">Circle</tt> та назвемо його <tt class="prettyprint lang-java">fillColor()</tt>; він буде заповнювати об'єкт кола різними кольорами. При вказанні кольору треба використовувати якусь кольорову схему - одну з двох: RGB або HSB.</p>

    <ol>
        <li>В схемі RGB колір представляється як кобінація значень червоного (Red), зеленого (Green) та синього (Blue) компонентів. За домовленістю, кожна компонента надається як ціле значення в діапазоні від 0 до 255.</li>
        <li>В <a href="https://uk.wikipedia.org/wiki/HSV">схемі HSB</a> колір представляється як комбінація значень кольорного тону (Hue), насиченості (Saturation) та яскравості (Brightness). За домовленістю, кожне значення надається в діапазоні від 0.0 до 1.0.</li>
    </ol>

    <p>Оскільки значення RGB цілі, а значення HSB - з плаваючою крапкою, тобто, відрізняються за типами даних, в методі <tt class="prettyprint lang-java">fillColor()</tt> можна підтримувати обидві кольорові схеми.</p>

    <pre class="prettyprint lang-java">
class Circle {
    // інші члени
    public void fillColor (int red, int green, int blue) {
        /* розфарбувати коло з використанням значень RGB */
    }
    public void fillColor (float hue, float saturation, float brightness) {
        /* розфарбувати коло з використанням значень HSB */
    }
}
    </pre>

    <p>Обидва методи <tt class="prettyprint lang-java">fillColor()</tt> мають однакову назву та приймають по три параметри; однак, параметри відрізняються за типом. На основі типа аргумента при здійсненні виклику метода <tt class="prettyprint lang-java">fillColor()</tt> класа <tt class="prettyprint lang-java">Circle</tt>, компілятор точно визначить, який саме метод отримає виклик. Наприклад:</p>

    <pre class="prettyprint lang-java">
Circle c1 = new Circle(10, 20, 10);
c1.fillColor(0, 255, 255);
Circle c2 = new Circle(50, 100, 5);
c2.fillColor(0.5f, 0.5f, 1.0f);
    </pre>

    <p>Для об'єкта <tt class="prettyprint lang-java">c1</tt> виклик <tt class="prettyprint lang-java">fillColor()</tt> має аргументи 0, 255 та 255. Отже, компілятор приизначить цей виклик методу <tt class="prettyprint lang-java">fillColor(int red, int green, int blue)</tt>. Для об'єкта <tt class="prettyprint lang-java">c2</tt> виклик <tt class="prettyprint lang-java">fillColor()</tt> має аргументи 0.5f, 0.5f та 1.0f; отже він призначиться методу <tt class="prettyprint lang-java">fillColor(float hue, float saturation, float brightness)</tt>.</p>

    <p>Метод <tt class="prettyprint lang-java">fillColor()</tt> є перевантаженим методом. Методи мають однакову назву та однакову кількість параметрів, але типи параметрів відрізняються. Також можна перевантажувати метод, використовуючи різну кількість параметрів.</p>

    <p>Такі перевантажені методи корисні для запобігання повторюваности того ж коду в різних функціях. Подивимось на приклад в Лістингу <a href="#c02l04">2-4</a>.</p>

    <pre id="c02l04" class="prettyprint lang-java">
// Лістинг 2-4. HappyBirthday.java
class HappyBirthday {
    // перевантажений метод wish з параметром String
    public static void wish(String name) {
        System.out.println("З днем народження, " + name + "!");
    }
    // перевантажений метод wish без параметрів;
    // цей метод викликає метод wish(String)
    public static void wish() {
        wish("невідома людина");
    }
    public static void main(String []args) {
        wish();
        wish("Джеймс Гослінг"); // автор Java
    }
}
    </pre>

    <p>Він надрукує:</p>

    <pre>
З днем народження, невідома людина!
З днем народження, Джеймс Гослінг!
    </pre>

    <p>Метод <tt class="prettyprint lang-java">wish(String name)</tt> призначений для побажання "З днем народження, " людині з відомим іменем. Метод по замовчанню <tt class="prettyprint lang-java">wish()</tt> призначений для побажання будь-кому. Немає потреби повторювати оператор <tt class="prettyprint lang-java">System.out.println</tt> в методі <tt class="prettyprint lang-java">wish()</tt> - можна повторно використовувати визначення метода <tt class="prettyprint lang-java">wish(String)</tt>, передаючи значення "невідома людина" в якості аргумента по замовчанню в метод <tt class="prettyprint lang-java">wish()</tt>. Таке повторне використання ефективне для великих на пов'язаних визначень методів, оскільки зберігає час для написання однакового коду.</p>

    <h3>Перевантаження конструкторів</h3>

    <p>Конструктор по замовчанню корисний для створення об'єктів з ініціалізацію значеннями по замовчанню. При потребі ініціалізувати об'єкти різними значеннями при кожному створенні можна надавати конструктору ці значення як аргументи. В класі можна мати багато конструкторів, що є <em>перевантаженням конструкторів</em>. Конструктор по замовчанню може ініціалізувати об'єкт класа початковими значеннями по замовчанню, а інші конструктори можуть приймати аргументи, які будуть використані при ініціалізації об'єкта.</p>

    <p>Приклад класа <tt class="prettyprint lang-java">Circle</tt>, який має перевантажені конструктори (див. Лістинг <a href="#c02l05">2-5</a>).</p>

    <pre id="c02l05" class="prettyprint lang-java">
// Лістинг 2-5. Circle2.java
public class Circle2 {
    private int xPos;
    private int yPos;
    private int radius;
    // три перевантажені конструктори для Circle
    public Circle2(int x, int y, int r) {
        xPos = x;
        yPos = y;
        radius = r;
    }
    public Circle2(int x, int y) {
        xPos = x;
        yPos = y;
        radius = 10; // радіус по замовчанню
    }
    public Circle2() {
        xPos = 20; // значення для центра по замовчанню
        yPos = 20;
        radius = 10; // радіус по замовчанню
    }
    public String toString() {
        return "центр = (" + xPos + "," + yPos + ") та радіус = " + radius;
    }
    public static void main(String[]s) {
        System.out.println(new Circle2());
        System.out.println(new Circle2(50, 100));
        System.out.println(new Circle2(25, 50, 5));
    }
}
    </pre>

    <p>Ця програма друкує</p>

    <pre>
центр = (20,20) та радіус = 10
центр = (50,100) та радіус = 10
центр = (25,50) та радіус = 5
    </pre>

    <p>Компілятор визначив виклик конструктор по кількості аргументів. Конструктор по замовчанню не приймає аргументів та використовує деякі значення по замовчанню для <tt class="prettyprint lang-java">xPos</tt>, <tt class="prettyprint lang-java">yPos</tt> та <tt class="prettyprint lang-java">radius</tt> (20, 20 та 10 відповідно). Конструктор <tt class="prettyprint lang-java">Circle</tt> з двома параметрами (<tt class="prettyprint lang-java">int x</tt> та <tt class="prettyprint lang-java">int y</tt>) встановлює <tt class="prettyprint lang-java">xPos</tt> та <tt class="prettyprint lang-java">yPos</tt> в значення наданих аргументів, а для члена <tt class="prettyprint lang-java">radius</tt> використовує 10 як значення по замовчанню. Конструктор <tt class="prettyprint lang-java">Circle</tt>, який приймає три аргумента, встановлює відповідні поля об'єкта класа <tt class="prettyprint lang-java">Circle</tt>.</p>

    <p>Чи помітили ви дублювання коду в цих трьох конструкторах? Для уникнення такого дублювання - та зменшення зусиль для друкування- можна викликати один конструктор з іншого конструктора. Серед всіх трьох конструкторів той, який приймає координати x та y і radius, є найбільш загальним. Інші два конструктора можна переписати так, щоб вони викликали конструктор з трьома параметрами:</p>

    <pre class="prettyprint lang-java">
public Circle(int x, int y, int r) {
    xPos = x;
    yPos = y;
    radius = r;
}

public Circle(int x, int y) {
    this(x, y, 10);     // передати 10 як радіус по замовчанню
}

public Circle() {
    this(20, 20, 10);   // значення по замовчанню для xPos, yPos та radius
}
    </pre>

    <p>Вивід - такий самий, як і в попередній програмі, але ця версія - коротша. Для виклику одного конструктора з іншого конструктора того ж класа використовується ключове слово <tt class="prettyprint lang-java">this</tt> (посилання на поточний об'єкт).</p>

    <h3>Визначення перевантаження</h3>

    <p>Як компілятор визначає, який з перевантажених методів викликати? Спробуйте спрогнозувати вивід програми в Лістингу <a href="#c02l06">2-6</a>:</p>

    <pre id="c02l06" class="prettyprint lang-java">
// Лістинг 2-6. Overloaded.java
class Overloaded {
    public static void aMethod(int val)   { System.out.println ("int"); }
    public static void aMethod(short val) { System.out.println ("short"); }
    public static void aMethod(Object val){ System.out.println ("object"); }
    public static void aMethod(String val){ System.out.println ("String"); }

    public static void main(String[] args) {
        byte b = 9;
        aMethod(b);     // перший виклик
        aMethod(9);     // другий виклик
        Integer i = 9;
        aMethod(i);     // третій виклик
        aMethod("9");   // четвертий виклик
    }
}
    </pre>

    <p>Вивід такий:</p>

    <pre>
short
int
object
String
    </pre>

    <p>Як компілятори визначає ці виклики:</p>

    <ol>
        <li>В першому виклику метода оператор <tt class="prettyprint lang-java">aMethod(b)</tt> зі змінною <tt class="prettyprint lang-java">b</tt> байтового типу. Однак, визначення метода <tt class="prettyprint lang-java">aMethod</tt>, який приймав би байтовий аргумент, не існує. Найближчий (за розміром) тип - це тип <tt class="prettyprint lang-java">short</tt>, а не  <tt class="prettyprint lang-java">int</tt>, тож компілятор визначає виклик <tt class="prettyprint lang-java">aMethod(b)</tt> в визначення <tt class="prettyprint lang-java">aMethod(short val)</tt>.</li>

        <li>В другому виклику - оператор <tt class="prettyprint lang-java">aMethod(9)</tt>. Константа <tt class="prettyprint lang-java">9</tt> належить типу <tt class="prettyprint lang-java">int</tt>. Найближче співпадіння - <tt class="prettyprint lang-java">aMethod(int)</tt>, тож компілятор визначає виклик <tt class="prettyprint lang-java">aMethod(9)</tt> у визначення <tt class="prettyprint lang-java">aMethod(int val)</tt>.</li>

        <li>Tретій виклик метода - це <tt class="prettyprint lang-java">aMethod(i)</tt>, в якому змінна <tt class="prettyprint lang-java">i</tt> належіить типу <tt class="prettyprint lang-java">Integer</tt>. Визначення <tt class="prettyprint lang-java">aMethod</tt>, в якому приймається аргумент типу <tt class="prettyprint lang-java">Integer</tt>, не існує. Найближче співпадіння -  <tt class="prettyprint lang-java">aMethod(Object val)</tt>, тож, він і визивається. Чому не <tt class="prettyprint lang-java">aMethod(int val)</tt>? Для пошуку найближчого співпадіння компілятор дозволяє неявні приведення типів (за зростанням, не спадінням), тож метод <tt class="prettyprint lang-java">aMethod(int val)</tt> не розглядається.</li>

        <li>Останній виклик - це <tt class="prettyprint lang-java">aMethod("9")</tt>. Аргумент належить типу <tt class="prettyprint lang-java">String</tt>. Оскільки є точне співпадіння, викликається <tt class="prettyprint lang-java">aMethod(String val)</tt>.</li>
    </ol>

    <p>Процес <em>визначення</em> компілятором метода для виклику однієї з перевантажених версій визначень назівається <em>визначенням перевантаження</em>. Для визначення метода, що викликається, компілятор по-перше шукає <em>точне</em> співпадіння — визначення метода має точно таку саму кількість параметрів з такими самими типами. Якщо він не може знайти точне співпадіння, він шукає <em>найближче співпадіння</em> з використанням приведення типів (догори по ієрархії). Якщо компілятор не може знайти жодного співпадіння, він викликає помилку, як в Лістингу <a href="#c02l07">2-7</a>.</p>

    <pre id="c02l07" class="prettyprint lang-java">
class OverloadingError {
    public static void aMethod (byte val ) { System.out.println ("byte"); }
    public static void aMethod (short val ) { System.out.println ("short"); }
    
    public static void main(String[] args) {
        aMethod(9);
    }
}
    </pre>

    <p>Помилка:</p>

    <pre>
OverloadingError.java:6: error: no suitable method found for aMethod(int)
        aMethod(9);
        ^
    method OverloadingError.aMethod(byte) is not applicable
      (argument mismatch; possible lossy conversion from int to byte)
    method OverloadingError.aMethod(short) is not applicable
      (argument mismatch; possible lossy conversion from int to short)
1 error
    </pre>

    <p>Тип константи <tt class="prettyprint lang-java">9</tt> - це <tt class="prettyprint lang-java">int</tt>, а точного співпадіння для визначення метода <tt class="prettyprint lang-java">aMethod</tt> для виклику <tt class="prettyprint lang-java">aMethod(9)</tt> немає. Як ми бачили раніше для визначення перевантаження, компілятор може приводити типи (наприклад, <tt class="prettyprint lang-java">byte</tt> до <tt class="prettyprint lang-java">int</tt>) в пошуку найближчого співпадіння, але вні не робить спадний пошук (як, з <tt class="prettyprint lang-java">int</tt> до <tt class="prettyprint lang-java">byte</tt> чи <tt class="prettyprint lang-java">int</tt> до <tt class="prettyprint lang-java">short</tt>, як в нашому прикладі). Отже, компілятор не знаходить жодного співпадіння та викликає помилку.</p>

    <p>Якщо комілятор не знаходить співпадіння, також виникатиме поилка. Приклад - в Лістингу <a href="#c02l08">2-8</a>.</p>

    <pre id="c02l08" class="prettyprint lang-java">
// Listing 2-8. AmbiguousOverload.java
class AmbiguousOverload {
    public static void aMethod (long val1, int val2) {
        System.out.println ("long, int");
    }
    public static void aMethod (int val1, long val2) {
        System.out.println ("int, long");
    }
    public static void main(String[] args) {
        aMethod(9, 10);
    }
}
    </pre>

    <p>Помилка компілятора:</p>

    <pre>
AmbiguousOverload.java:10: error: reference to aMethod is ambiguous
        aMethod(9, 10);
        ^
  both method aMethod(long,int) in AmbiguousOverload and method aMethod(int,long) in AmbiguousOverload match
1 error
    </pre>

    <p>Чому цей виклик стає "неоднозначним"? Константи 9 та 10 - це <tt class="prettyprint lang-java">int</tt>-и. Є два визначення метода <tt class="prettyprint lang-java">aMethod</tt>: один <tt class="prettyprint lang-java">aMethod(long, int)</tt> та другий <tt class="prettyprint lang-java">aMethod(int, long)</tt>. Отже для виклику <tt class="prettyprint lang-java">aMethod(int, int)</tt> немає однозначного співпадіння. Ціле не може одночасно визначитися в тип <tt class="prettyprint lang-java">long</tt> та в тип <tt class="prettyprint lang-java">Integer</tt>. Що має обрати компілятор? При наявності двох варіантів компілятор викликає помилку.</p>

    <hr class="Bomb"/>
    <p>Визначення перевантаженя хибить (з помилкою компіляції), якщо немає співпадінь, або їх більше одного.</p>
    <hr/>

    <h3>Пам'ятка</h3>

    <p>Про перевантаження:</p>

    <ul>
        <li>Визначення перевантаження відбувається під час компіляції (не під час виконання).</li>
        <li>Якщо методи повертають значення різних типів, їх не можна перевантажувати.</li>
        <li>Якщо методи декларують різний набір винятків, їх не можна перевантажувати.</li>
        <li>Для успішного визначення перевантаження методи треба визначати так, щоб компілятор мав точно одно співпадіння. Якщо компілятор не знайде співпадіння для виклику, або їх буде декілька, визначення перевантаження закінчиться помилкою.</li>
    </ul>

    <hr class="Note"/>
    <p><em>Сигнатура</em> метода складається з його назви, кількості параметрів та їх типів. Можна перевантажувати методи з однаковими назвами, але з різними сигнатурами. Оскільки тип результата і специфікація винятків не формують сигнатуру, не можливо перевантажувати методи виключно на основі типу результата чи специфікації винятків.</p>
    <hr/>

    <h2>Перезаписування методів класа <tt class="prettyprint lang-java">Object</tt></h2>

    <p>Розглянемо перезаписування методів класа <tt class="prettyprint lang-java">Object</tt>. У власних класах можна перезаписувати методи <tt class="prettyprint lang-java">clone()</tt>, <tt class="prettyprint lang-java">equals()</tt>, <tt class="prettyprint lang-java">hashCode()</tt>, <tt class="prettyprint lang-java">toString()</tt> та <tt class="prettyprint lang-java">finalize()</tt>. Оскільки методи <tt class="prettyprint lang-java">getClass()</tt>, <tt class="prettyprint lang-java">notify()</tt>, <tt class="prettyprint lang-java">notifyAll()</tt> та перевантажені версії метода <tt class="prettyprint lang-java">wait()</tt> оголошені як <tt class="prettyprint lang-java">final</tt>, їх перезаписувати не можна.</p>

    <p>Навіщо взагалі перезаписувати методи класа <tt class="prettyprint lang-java">Object</tt>? Для відповіді на це питання подивимося, що відбувається якщо не перезаписати метод <tt class="prettyprint lang-java">toString()</tt> (Лістинг <a href="c02l09">2-9</a>).</p>

    <pre id="c02l09" class="prettyprint lang-java">
// Лістинг 2-9. Point.java
class Point {
    private int xPos, yPos;
    public Point(int x, int y) {
        xPos = x;
        yPos = y;
    }
    public static void main(String []args) {
        // Надання методу println об'єкта Point
        // автоматично викликає метод toString
        System.out.println(new Point(10, 20));
    }
}
    </pre>

    <p>Він друкує</p>

    <pre class="prettyprint lang-java">
Point@2f0e140b
    </pre>

    <p>Метод <tt class="prettyprint lang-java">toString()</tt> визначений в класі <tt class="prettyprint lang-java">Object</tt>, від якого спадкують всі класи в Java. Метод <tt class="prettyprint lang-java">toString()</tt> визначений в класі <tt class="prettyprint lang-java">Object</tt> так:</p>

    <pre class="prettyprint lang-java">
public String toString()
    </pre>

    <p>Метод <tt class="prettyprint lang-java">toString()</tt> не прймає аргументів та повертає представлення об'єкта у вигляді <tt class="prettyprint lang-java">String</tt>. Реалізація по замовчанню цього метода повертає версію геш-кода <tt class="prettyprint lang-java">ClassName@hex</tt> об'єкта. Саме тому ми отримуємо такий нечитабельний вивід. Для кожного об'єкта шістнадцяткове значення відрізнятиметься. Наприклад, повторний запуск програми надрукує: <tt class="prettyprint lang-java">Point@affc70</tt>. Отже, метод <tt class="prettyprint lang-java">toString</tt> треба перезаписати для нашого класа <tt class="prettyprint lang-java">Point</tt>.</p>

    <h3>Перезаписування метода <tt class="prettyprint lang-java">toString()</tt></h3>

    <p>При створенні нового класа скоріш за все знадобиться перезаписати цей метод для отримання бажаного строкового представлення об'єктів класа. Лістинг <a href="#c02l10">2-10</a> показує покращену версію класа <tt class="prettyprint lang-java">Point</tt> з перезаписаною версією метода <tt class="prettyprint lang-java">toString()</tt>.</p>

    <pre id="c02l10" class="prettyprint lang-java">
// Лістинг 2-10. Point2.java
// покращена версія класа Point з перезаписаним методом toString
class Point2 {
    private int xPos, yPos;
    public Point2(int x, int y) {
        xPos = x;
        yPos = y;
    }
    // цей метод toString перезаписує реалізацію метода toString по замовчанню,
    // яку надає базовий клас Object
    public String toString() {
        return "x = " + xPos + ", y = " + yPos;
    }
    public static void main(String []args) {
        System.out.println(new Point2(10, 20));
    }
}
    </pre>

    <p>Ця програма друкує</p>

    <pre>
x = 10, y = 20
    </pre>

    <p>Як і очікувалося, так представляти об'єкт значно краще. Нижче наведено ще трохи покращену версію метода <tt class="prettyprint lang-java">main()</tt> в реалізації нашого класа <tt class="prettyprint lang-java">Point</tt>:</p>

    <pre class="prettyprint lang-java">
public static void main(String []args) {
    Object obj = new Point(10, 20);
    System.out.println(obj);
}
    </pre>

    <p>Він друкує</p>

    <pre>
x = 10, y = 20
    </pre>

    <p>Статичний тип змінної <tt class="prettyprint lang-java">obj</tt> це клас <tt class="prettyprint lang-java">Object</tt>, а динамічний тип - <tt class="prettyprint lang-java">Point</tt>. Оператор <tt class="prettyprint lang-java">println</tt> викликає метод <tt class="prettyprint lang-java">toString()</tt> змінної <tt class="prettyprint lang-java">obj</tt>. Тут - метод <tt class="prettyprint lang-java">toString()</tt> породженого класа, тобто метод <tt class="prettyprint lang-java">toString()</tt> класа <tt class="prettyprint lang-java">Point</tt> - так працює поліморфізм часу виконання.</p>

    <h4>Проблеми перезаписування</h4>

    <p>При перезаписуванні треба бути уважним до рівнів доступу, назв методів та їх сигнатур. Нижче наведено метод <tt class="prettyprint lang-java">toString()</tt> обговорюваного класа <tt class="prettyprint lang-java">Point</tt>:</p>

    <pre class="prettyprint lang-java">
public String toString() {
    return "x = " + xPos + ", y = " + yPos;
}
    </pre>

    <p>Якщо в цьому визначенні метода використати специфікатор доступу <tt class="prettyprint lang-java">protected</tt> замість <tt class="prettyprint lang-java">public</tt> - чи буде воно працювати?</p>

    <pre class="prettyprint lang-java">
protected String toString() {
    return "x = " + xPos + ", y = " + yPos;
}
    </pre>

    <p>Ні, не буде. Після такої зміни компілятор зауважить</p>

    <pre>
Point.java:12: error: toString() in Point cannot override toString() in Object
protected String toString() {
                 ^
attempting to assign weaker access privileges; was public
1 error
    </pre>

    <p>При перезаписуванні можна надавати більш жорсткі привілеї доступу, а не більш м'які; інакше виникне помилка компіляції.</p>

    <p>Ще одна версія метода <tt class="prettyprint lang-java">toString()</tt>. Працюватиме?</p>

    <pre class="prettyprint lang-java">
public Object toString() {
    return "x = " + xPos + ", y = " + yPos;
}
    </pre>

    <p>Отримаємо таку помилку компілятора:</p>

    <pre>
Point.java:12: error: toString() in Point cannot override toString() in Object
public Object toString() {
              ^
return type Object is not compatible with String
1 error
    </pre>

    <p>В цьому разі компілятор повіомляє про помилку неспівпадіння оскільки тип результата в перезаписаному методі має бути саме таким, як в методі базового класа.</p>

    <p>Ще приклад:</p>

    <pre class="prettyprint lang-java">
public String ToString() {
    return "x = " + xPos + ", y = " + yPos;
}
    </pre>

    <p>Тепер компілятор не скаржиться. Але тепер метод називається <tt class="prettyprint lang-java">ToString</tt> та він не має жодного стосунку до метода <tt class="prettyprint lang-java">toString</tt> класа <tt class="prettyprint lang-java">Object</tt>. Отже, цей метод <tt class="prettyprint lang-java">ToString</tt> <em>не перезаписує</em> метод <tt class="prettyprint lang-java">toString</tt>.</p>

    <p>Для правильного перезаписування метода треба мати на увазі наступне. Перезаписуваний метод</p>

    <ul>
        <li>мусить мати той самий список типів параметрів (або сумісних типів), як в базовій версії.</li>
        <li>мусить мати той самий тип результата, що повертається.</li>
        <ul>
            <li>але, починаючи з Java 5, тип, що повертається може бути сумісним на рівні під-класа (про це детальніше - трохи пізніше).</li>
        </ul>
        <li><em>не</em> повинен мати більш обмежуючий модифікатор доступу в порівнянні з базовою версією.</li>
        <ul>
            <li>але може мати менш обмежуючий модифікатор доступу.</li>
        </ul>
        <li><em>не</em> може викликати нові або більш широкі винятки, що перевіряються.</li>
        <ul>
            <li>але може викликати більш вузькі (специфічні) винятки, або такі винятки, що не перевіряються.</li>
        </ul>
        <li>мусить мати таку саму назву!</li>
    </ul>

    <p>Не можна перезаписати метод без його спадкування. Приватні методи не можна перезаписати, оскільки від них не можна спадкувати.</p>

    <hr class="Note"/>
    <p>Сигнатури базового метода та перезаписуваного метода мають бути сумісні. Неправильне перезаписування доволі поширение джерело проблем в програмах на Java.</p>
    <hr/>

    <hr/>
    <span style="text-transform:uppercase"><p>Сумісність типів результату</p></span>
    <hr/>

    <p>При переписуванні методів тип їх результатів має повністю співпадати. You know that the return types of the methods should exactly match when overriding methods. Однак, після введення властивості сумісності типів в Java 5, в якості результата перезаписаного метода можна надавати похідний клас. Навіщо може знадобитися ця властивість? Подивимось на ці перезаисані методи з однаковими типами результата:</p>

    <pre class="prettyprint lang-java">
abstract class Shape {
    // інші методи пропущені
    public abstract Shape copy();
}

class Circle extends Shape {
    // інші методи пропущені
    public Circle(int x, int y, int radius) { /* тут ініціалізація */ }
    public Shape copy() { /* повернути копію цього об'єкта */ }
}

class Test {
    public static void main(String []args) {
        Circle c1 = new Circle(10, 20, 30);
        Circle c2 = c1.copy();
    }
}
    </pre>

    <p>Цей код викличе помилку компілятора <tt>"incompatible types: Shape cannot be converted to Circle"</tt>. Причина: в призначенні <tt class="prettyprint lang-java">"Circle c2 = c1.copy();"</tt> немає точного співпадіння для спадного приведення типу (downcast) від <tt class="prettyprint lang-java">Shape</tt> до <tt class="prettyprint lang-java">Circle</tt>.</p>

    <p>Оскільки точно відомо, що метод <tt class="prettyprint lang-java">copy</tt> класа <tt class="prettyprint lang-java">Circle</tt> повертає об'єкт класа <tt class="prettyprint lang-java">Circle</tt>, для уникнення помилки компіляції можна явно надати приведення типу:</p>

    <pre class="prettyprint lang-java">
Circle c2 = (Circle) c1.copy();
    </pre>

    <p>Оскільки такі спадні приведення типу надавати нудно (та більш-менш безглуздо), Java пропонує сумісні типи результата, в якості яких в перезаписаному методі можна надати похідний тип. Іншими словами, можна змінити визначення метода <tt class="prettyprint lang-java">copy</tt> класа <tt class="prettyprint lang-java">Circle</tt> таким чином:</p>

    <pre class="prettyprint lang-java">
public Circle copy() { /* повернути копію цього об'єкта */ }
    </pre>

    <p>Тепер призначення <tt class="prettyprint lang-java">Circle c2 = c1.copy();</tt> в методі <tt class="prettyprint lang-java">main</tt> правильне та явного спадного приведення типу не потрібне (це добре).</p>

    <hr/>
    <hr/>

    <h3>Перезаписування метода equals()</h3>

    <p>А тепер перезапишемо метод <tt class="prettyprint lang-java">equals</tt> класа <tt class="prettyprint lang-java">Point</tt>. Перед ци подивимось на сигнатуру метода <tt class="prettyprint lang-java">equals()</tt> класа <tt class="prettyprint lang-java">Object</tt>:</p>

    <pre class="prettyprint lang-java">
public boolean equals(Object obj)
    </pre>

    <p>Метод <tt class="prettyprint lang-java">equals()</tt> класа <tt class="prettyprint lang-java">Object</tt> є перезаписуваним та приймає в якості аргумента об'єкт типу <tt class="prettyprint lang-java">Object</tt>. Він перевіряє, чи наповнення поточного об'єкта співпадає з наповенням об'єкта, який надано в якості аргумента <tt class="prettyprint lang-java">obj</tt> . Якщо співпадає, метод <tt class="prettyprint lang-java">equals()</tt> повертає <tt class="prettyprint lang-java">true</tt>; інашке він повертає <tt class="prettyprint lang-java">false</tt>.</p>

    <p>Покращимо код в Лістингу <a href="c02l10">2-10</a> та перезапишемо метод <tt class="prettyprint lang-java">equals()</tt> в класі <tt class="prettyprint lang-java">Point</tt> (дивись Лістинг <a href="c02l11">2-11</a>). Чи буде така реалізація правильною?</p>

    <pre id="c02l11" class="prettyprint lang-java">
// Лістинг 2-11. Point3.java
public class Point3 {
    private int xPos, yPos;
    public Point3(int x, int y) {
        xPos = x;
        yPos = y;
    }
    // перезаписати метод equals для виконання
    // "глибокого" порівнянн двох об'єктів Point
    public boolean equals(Point3 other){
        if(other == null)
            return false;
        // дві точки (крапки?) еквівалентні лише якщо їх координати x та y співпадають
        if( (xPos == other.xPos) && (yPos == other.yPos) )
            return true;
        else
            return false;
    }

    public static void main(String []args) {
        Point3 p1 = new Point3(10, 20);
        Point3 p2 = new Point3(50, 100);
        Point3 p3 = new Point3(10, 20);
        System.out.println("p1 та p2 співпадають: " + p1.equals(p2));
        System.out.println("p1 та p3 співпадають: " + p1.equals(p3));
    }
}
    </pre>

    <p>Він друкує:</p>

    <pre>
p1 та p2 співпадають: false
p1 та p3 співпадають: true
    </pre>

    <p>Вивід такий, як очікується, але чи є реалізація метода <tt class="prettyprint lang-java">equals()</tt> правильною? Ні! Зробимо маленьку модифікацію в методі <tt class="prettyprint lang-java">main()</tt> (тепер змінні належать класу <tt class="prettyprint lang-java">Object</tt>):</p>

    <pre class="prettyprint lang-java">
public static void main(String []args) {
    Object p1 = new Point(10, 20);
    Object p2 = new Point(50, 100);
    Object p3 = new Point(10, 20);
    System.out.println("p1 та p2 співпадають: " + p1.equals(p2));
    System.out.println("p1 та p3 співпадають: " + p1.equals(p3));
}
    </pre>

    <p>Тепер програма надрукує</p>

    <pre>
p1 та p2 співпадають: false
p1 та p3 співпадають: false
    </pre>

    <p>Чому? Обидва методи <tt class="prettyprint lang-java">main()</tt> еквівалентні. Але в новій реалізації метода <tt class="prettyprint lang-java">main()</tt> для оголошення змінних <tt class="prettyprint lang-java">p1</tt>, <tt class="prettyprint lang-java">p2</tt> та <tt class="prettyprint lang-java">p3</tt> використовується тип <tt class="prettyprint lang-java">Object</tt>. Динамічний тип цих трьох змінних це <tt class="prettyprint lang-java">Point</tt>, тож має відбутися виклик переписаного метода <tt class="prettyprint lang-java">equals()</tt>. Однак, переписування невірне: Метод <tt class="prettyprint lang-java">equals()</tt> мусить мати аргумент <tt class="prettyprint lang-java">Object</tt>, а не <tt class="prettyprint lang-java">Point</tt>! Поточна реалізація метода <tt class="prettyprint lang-java">equals()</tt> в класі <tt class="prettyprint lang-java">Point</tt> маскує (а не перезаписує) метод <tt class="prettyprint lang-java">equals()</tt> класа <tt class="prettyprint lang-java">Object</tt>. Отже, метод <tt class="prettyprint lang-java">main()</tt> викликає базову версію, яка є реалізацією по замовчанню <tt class="prettyprint lang-java">Point</tt> в класі <tt class="prettyprint lang-java">Object</tt>!</p>

    <hr class="Bomb"/>
    <p>Якщо назви чи сигнатури метода базового класа та метода, який перезаписується, не співпадають, виникнуть помилки. Тож, треба бути впевненим в їх точному співпадінні.</p>
    <hr/>

    <p>Для подолання проблем при перевантаженні можна використовувати анотацію <tt class="prettyprint lang-java">@Override</tt>, яка була запропонована в Java 5. Ця анотація вказує компілятору Java на намір програміста перезаписати метод. В разі, коли компілятор не задоволений перезаписуваним методом, він поскаржиться, що буде корисним. Також, ця анотація робить програму біль зрозумілою, оскільки анотація <tt class="prettyprint lang-java">@Override</tt> перед визначенням метода допомагає у переписуванні метода.</p>

    <p>Приклад кода з анотацією <tt class="prettyprint lang-java">@Override</tt> для метода <tt class="prettyprint lang-java">equals</tt>:</p>

    <pre class="prettyprint lang-java">
@Override
public boolean equals(Point other) {
    if(other == null)
        return false;
    // дві точки (крапки?) еквівалентні лише якщо їх координати x та y співпадають
    if((xPos == other.xPos) && (yPos == other.yPos))
        return true;
    else
        return false;
}
    </pre>

    <p>Для цього кода виникне помилка компіляції:</p>

    <pre>
Point.java:11: error: method does not override or implement a method from a supertype
@Override
^
1 error
    </pre>

    <p>Як її виправити? Треба передавати аргумент типу <tt class="prettyprint lang-java">Object</tt> в метод <tt class="prettyprint lang-java">equals</tt>. Лістинг <a href="c02l12">2-12</a> показує приграму з правильним методом <tt class="prettyprint lang-java">equals</tt>.</p>

    <pre id="c02l12" class="prettyprint lang-java">
// Лістинг 2-12. Point4.java
public class Point4 {
    private int xPos, yPos;
    public Point4(int x, int y) {
        xPos = x;
        yPos = y;
    }
    // переписати метод equals для виконання "глибокого" порівняння двох об'єктів Point4
    @Override
    public boolean equals(Object other) {
        if(other == null)
            return false;
        // перевірити чи є динамічний тип параметра 'other' типом Point4
        // якщо 'other' належить іншому типу, два об'єкти не можуть співпадати
        // якщо 'other' належить типу Point4 (чи одному за похідних класів), то
        // привести тип об'єкта до Point4, а потім перевірити члени на співпадіння
        if(other instanceof Point4) {
            Point4 anotherPoint4 = (Point4) other;
            // дві точки (крапки?) еквівалентні лише якщо їх координати x та y співпадають
            if((xPos == anotherPoint4.xPos) && (yPos == anotherPoint4.yPos))
                return true;
        }
        return false;
    }

    public static void main(String []args) {
        Object p1 = new Point4(10, 20);
        Object p2 = new Point4(50, 100);
        Object p3 = new Point4(10, 20);
        System.out.println("p1 та p2 співпадають: " + p1.equals(p2));
        System.out.println("p1 та p3 співпадають: " + p1.equals(p3));
    }
}
    </pre>

    <p>Тепер програма надрукує</p>

    <pre>
p1 та p2 співпадають: false
p1 та p3 співпадають: true
    </pre>

    <p>Тепер вивід такий, як очікувалося, а реалізація метода <tt class="prettyprint lang-java">equals</tt> правильна.</p>

    <h4>Виклик методів суперкласа</h4>

    <p>Яасто корисно викликати в перезаписуваному методі метод базового класа. Для цього можна використовувати ключове слово <tt class="prettyprint lang-java">super</tt>. В конструкторах похідного класа можна викликати конструктор базового класа з використанням ключового слова <tt class="prettyprint lang-java">super</tt>. Такий виклик має бути <em>першим оператором</em> в конструкторі. Можна також використовувати ключове слово <tt class="prettyprint lang-java">super</tt> для посилання на члени мазового класа. В таких випадках таке ключове слово не повинно бути першим оператором в тілі метода. Розглянемо приклад.</p>

    <p>Ми реалізуємо клас <tt class="prettyprint lang-java">Point</tt> для точки на площині: вона має координати x та y. Також можна реалізувати клас точки в 3D просторі з координатами x, y та z. Для цього не треба починати реалізацію с нуля: можна розширити точку на площині та додати координату z в клас для 3D-точки. Спочатку перейменуємо просту реалізацію класа <tt class="prettyprint lang-java">Point</tt> в <tt class="prettyprint lang-java">Point2D</tt>. Потім створимо клас <tt class="prettyprint lang-java">Point3D</tt> для розширення <tt class="prettyprint lang-java">Point2D</tt> (дивись Лістинги <a href="#c02l13">2-13</a> та <a href="#c02l14">2-14</a>).</p>

    <pre id="c02l13" class="prettyprint lang-java">
// Лістинг 2-13. Point2D.java
class Point2D {
    private int xPos, yPos;
    public Point2D(int x, int y) {
        xPos = x;
        yPos = y;
    }
    public String toString() {
        return "x = " + xPos + ", y = " + yPos;
    }
    public static void main(String []args) {
        System.out.println(new Point2D(10, 20));
    }
}
    </pre>

    <pre id="c02l14" class="prettyprint lang-java">
// Лістинг 2-14. Point3D.java
// Створення класа Point3D через розширення класа Point2D
public class Point3D extends Point2D {
    private int zPos;
    // надати публічний конструктор, який приймає три аргументи (значення x, y та z)
    public Point3D(int x, int y, int z) {
        // виклик конструктора суперкласа з двома аргументами
        // тобто, викликати Point2D(int, int) з конструктора Point3D(int, int, int))
        super(x, y); // super - перший оператор в методі
        zPos = z;
    }
    // переписати метод toString
    public String toString() {
        return super.toString() + ", z = " + zPos;
    }
    // для перевірки правильного розширення викликати метод toString об'єкта Point3D
    public static void main(String []args) {
        System.out.println(new Point3D(10, 20, 30));
    }
}
    </pre>

    <p>Програма друкує</p>

    <pre>
x = 10, y = 20, z = 30
    </pre>

    <p>В класі <tt class="prettyprint lang-java">Point2D</tt> члени класа <tt class="prettyprint lang-java">xPos</tt> та <tt class="prettyprint lang-java">yPos</tt> приватні, тож до них немає безпосереднього доступу для їх ініціалізації в конструкторі <tt class="prettyprint lang-java">Point3D</tt>. Однак, можна викликати конструктор суперкласа з використанням ключового слова <tt class="prettyprint lang-java">super</tt> та надати йому аргументи. Тут <tt class="prettyprint lang-java">super(x, y);</tt> викликає конструктор базового класа <tt class="prettyprint lang-java">Point2D(int, int)</tt>. Цей виклик конструктора суперкласа має бути першим оператором; якщо його викликати після <tt class="prettyprint lang-java">zPos = z;</tt>, виникне помилка компілятора:</p>

    <pre class="prettyprint lang-java">
public Point3D(int x, int y, int z) {
    zPos = z;
    super(x, y);
}

Point3D.java:19: call to super must be first statement in constructor
        super(x, y);
    </pre>

    <p>Схожим чином, можна викликати метод <tt class="prettyprint lang-java">toString()</tt> базового класа <tt class="prettyprint lang-java">Point2D</tt> в реалізації <tt class="prettyprint lang-java">toString()</tt> породженого класа <tt class="prettyprint lang-java">Point3D</tt> з використанням ключового слова <tt class="prettyprint lang-java">super</tt>.</p>

    <h5>Переписування метода <tt class="prettyprint lang-java">hashCode()</tt></h5>

    <p>Перезаписування методів <tt class="prettyprint lang-java">equals</tt> та <tt class="prettyprint lang-java">hashCode</tt> важливо робити правильно для використання в таких класах, як <tt class="prettyprint lang-java">HashMap</tt> та <tt class="prettyprint lang-java">HashSet</tt>, проя які йтиметься в Главі 4. Лістинг <a href="#c02l15">2-15</a> містить простий приклад класа <tt class="prettyprint lang-java">Circle</tt> для кращого розуміння можливих проблем при використанні таких колекцій, як <tt class="prettyprint lang-java">HashSets</tt>.</p>

    <pre id="c02l15" class="prettyprint lang-java">
// Лістинг 2-15. TestCircle.java
// Програма показує важливість переписування методів equals() та hashCode()
import java.util.*;

class Circle {
    private int xPos, yPos, radius;
    public Circle(int x, int y, int r) {
        xPos = x;
        yPos = y;
        radius = r;
    }
    public boolean equals(Object arg) {
        if(arg == null) return false;
        if(this == arg) return true;
        if(arg instanceof Circle) {
            Circle that = (Circle) arg;
            if( (this.xPos == that.xPos) && (this.yPos == that.yPos)
            && (this.radius == that.radius )) {
                return true;
            }
        }
        return false;
    }
}

class TestCircle {
    public static void main(String []args) {
        Set&lt;Circle&gt; circleList = new HashSet&lt;Circle&gt;();
        circleList.add(new Circle(10, 20, 5));
        System.out.println(circleList.contains(new Circle(10, 20, 5)));
    }
}
    </pre>

    <p>Він друкує <tt class="prettyprint lang-java">false</tt> (не <tt class="prettyprint lang-java">true</tt>)! Чому? Клас <tt class="prettyprint lang-java">Circle</tt> перезаписує метод <tt class="prettyprint lang-java">equals()</tt>, але не перезаписує метод <tt class="prettyprint lang-java">hashCode()</tt>. При використанні об'єктів класа <tt class="prettyprint lang-java">Circle</tt> в стандартних контейнерах, це стає проблемою. Для швидкого пошуку контейнери порівнюють геш-коди об'єктів. Якщо метод <tt class="prettyprint lang-java">hashCode()</tt> не перезаписаний, тоді — навіть якщо передаються об'єкти з однаковим змістом — контейнер не знайде об'єкт! Тож треба перезаписати метод <tt class="prettyprint lang-java">hashCode()</tt>.</p>

    <hr class="Bomb"/>
    <p>При використанні об'єкта в контейнерах <tt class="prettyprint lang-java">HashSet</tt> чи <tt class="prettyprint lang-java">HashMap</tt>, треба правильно перезаписати методи <tt class="prettyprint lang-java">hashCode()</tt> та <tt class="prettyprint lang-java">equals()</tt>. Якщо цього не зробити, при використанні цих контейнерів можливі неприємні сюрпризи!</p>
    <hr/>

    <p>Як треба перезаписувати метод <tt class="prettyprint lang-java">hashCode()</tt>? В ідеальному випадку, методо <tt class="prettyprint lang-java">hashCode()</tt> має повертати унікальні геш-коди для різних об'єктів.</p>

    <p>Метод <tt class="prettyprint lang-java">hashCode()</tt> повинен повертати те саме геш-значення, якщо метод the <tt class="prettyprint lang-java">equals()</tt> повертає <tt class="prettyprint lang-java">true</tt>. А у випадку різних об'єктів (тобто метод <tt class="prettyprint lang-java">equals()</tt> повертає <tt class="prettyprint lang-java">false</tt>)? Краще (хоча й не обов'язково), щоб метод <tt class="prettyprint lang-java">hashCode()</tt> повертав різні значення для різних об'єктів. Причина полягає в тому, що складно написати такий метод <tt class="prettyprint lang-java">hashCode()</tt>, який повертав би унікальні значення для кожного об'єкта.</p>

    <hr class="Note"/>
    <p>Методи <tt class="prettyprint lang-java">hashCode()</tt> та <tt class="prettyprint lang-java">equals()</tt> мають відповідати один одному в межах класа. На практиці важливо слідувати правилу: метод <tt class="prettyprint lang-java">hashCode()</tt> має повертати те саме геш-значення для двох об'єктів, якщо для них метод <tt class="prettyprint lang-java">equals()</tt> повертає <tt class="prettyprint lang-java">true</tt>.</p>
    <hr/>

    <p>При реалізації метода <tt class="prettyprint lang-java">hashCode()</tt> можна використовувати значення членів екземпляра класа для створення геш-значення. Нижче наводиться проста реалізація метода <tt class="prettyprint lang-java">hashCode()</tt> класа <tt class="prettyprint lang-java">Circle</tt>:</p>

    <pre class="prettyprint lang-java">
public int hashCode() {
    // використання бітових операторів ^ для генерації майже унікальних
    // геш-кодів на базі простих чисел 7, 11 та 53,
    // але можна використовувати будь-які члени
    return (7 * xPos) ^ (11 * yPos) ^ (53 * yPos);
}
    </pre>

    <p>Якщо запустити метод <tt class="prettyprint lang-java">main()</tt>, він надрукує “<tt class="prettyprint lang-java">true”</tt>. В цій реалізації метода <tt class="prettyprint lang-java">hashCode()</tt>, значення множаться на прості числа та використовується побітова операція (виключне або). Для кращої геш-функції можна написати більш складний код для метода <tt class="prettyprint lang-java">hashCode()</tt>, але така реалізація достатня для практичних цілей.</p>

    <p>Побітові оператори можна використовувати для значень типу <tt class="prettyprint lang-java">int</tt>. А що з іншими типами, плаваючу крапку чи посилальні типи? Для приклада наведено реалізацію <tt class="prettyprint lang-java">hashCode()</tt> класа <tt class="prettyprint lang-java">java.awt.Point2D</tt>, який має значення дісного з плаваючою крапкою для <tt class="prettyprint lang-java">x</tt> та <tt class="prettyprint lang-java">y</tt>. Методи <tt class="prettyprint lang-java">getX()</tt> та <tt class="prettyprint lang-java">getY()</tt> повертають значення відповідно <tt class="prettyprint lang-java">x</tt> та <tt class="prettyprint lang-java">y</tt>:</p>

    <pre class="prettyprint lang-java">
public int hashCode() {
    long bits = java.lang.Double.doubleToLongBits(getX());
    bits ^= java.lang.Double.doubleToLongBits(getY()) * 31;
    return (((int) bits) ^ ((int) (bits >> 32)));
}
    </pre>

    <p>Цей метод використовує метод <tt class="prettyprint lang-java">doubleToLongBits()</tt>, який приймає значення <tt class="prettyprint lang-java">double</tt> та повертає значення <tt class="prettyprint lang-java">long</tt>. Для значень з плавоючою крапкою <tt class="prettyprint lang-java">x</tt> та <tt class="prettyprint lang-java">y</tt> (які повертаються методами <tt class="prettyprint lang-java">getX</tt> та <tt class="prettyprint lang-java">getY</tt>), ми отримаємо значення <tt class="prettyprint lang-java">long</tt>, з якими можна маніпулювати по-бітово в методі <tt class="prettyprint lang-java">hashCode()</tt>.</p>

    <p>Тепер - про реалізацію метода <tt class="prettyprint lang-java">hashCode</tt> для класа з членами посилальних типів? Наприклад, розглянемо використання екземпляра класа <tt class="prettyprint lang-java">Point</tt> в якості члена замість полів примітивних типів <tt class="prettyprint lang-java">xPos</tt> та <tt class="prettyprint lang-java">yPos</tt>:</p>

    <pre class="prettyprint lang-java">
class Circle {
    private int radius;
    private Point center;
    // інші члени пропущені
}
    </pre>

    <p>В такому випадку можна використати метод <tt class="prettyprint lang-java">hashCode()</tt> класа <tt class="prettyprint lang-java">Point</tt> для реалізації метода <tt class="prettyprint lang-java">hashCode</tt> класа <tt class="prettyprint lang-java">Circle</tt>:</p>

    <pre class="prettyprint lang-java">
public int hashCode() {
    return center.hashCode() ^ radius;
}
    </pre>

    <h3>Композиція об'єктів</h3>

    <p>Окремі абстрації пропонують певну функціональність, яку треба комбінувати з іншими об'єктами для представлення більшої абстракції: скомпонованого з менших об'єкта. Для вирішення реальних програмних проблем інколи треба створювати такі составні об'єкти. В таких випадках складений об'єкт вступає у відношення "МАЄ" з влкаденими об'єктами, а базова концепція називається <em>композицією об'єктів</em>.</p>

    <p>Для аналогії, комп'ютер це складений - композитний - об'єкт, який містить інші об'єкти, такі як CPU, пам'ять та жорсткий диск. Іншими словами, об'єкт комп'ютер знаходиться у відношенні "МАЄ" з іншими об'єктами. Лістинг <a href="c02l16">2-16</a> визначає клас <tt class="prettyprint lang-java">Circle</tt>, який використовує об'єкт <tt class="prettyprint lang-java">Point</tt> для визначення центра <tt class="prettyprint lang-java">Circle</tt>.</p>

    <pre id="c02l16" class="prettyprint lang-java">
// Лістинг 2-16. Circle3.java
// Point незалежний клас, який використовується з класом Circle3
class Point {
    private int xPos;
    private int yPos;
    public Point(int x, int y) {
        xPos = x;
        yPos = y;
    }
    public String toString() {
        return "(" + xPos + "," + yPos + ")";
    }
}

// Circle3.java
public class Circle3 {
    private Point center;   // Circle3 "містить" об'єкт Point
    private int radius;
    public Circle3(int x, int y, int r) {
        center = new Point(x, y);
        radius = r;
    }
    public String toString() {
        return "центр = " + center + " і радіус = " + radius;
    }
    public static void main(String []s) {
        System.out.println(new Circle3(10, 10, 20));
    }
    // інші члени (конструктори, метод area и т.п.) пропущені ...
}
    </pre>

    <p>В цьому прикладі, <tt class="prettyprint lang-java">Circle</tt> має об'єкт <tt class="prettyprint lang-java">Point</tt>. Іншими словами, <tt class="prettyprint lang-java">Circle</tt> та <tt class="prettyprint lang-java">Point</tt> знаходяться у відношенні "МАЄ; тобто, <tt class="prettyprint lang-java">Circle</tt> це складений об'єкт, який містить об'єкт <tt class="prettyprint lang-java">Point</tt>. Таке рішення краще у порівнянні з використанням незалежних цілих членів <tt class="prettyprint lang-java">xPos</tt> та <tt class="prettyprint lang-java">yPos</tt>. Чому? Можна повторно виористовувати функціональність, яку надає класом <tt class="prettyprint lang-java">Point</tt>. Зверніть увагу на метод <tt class="prettyprint lang-java">toString()</tt> в класі <tt class="prettyprint lang-java">Circle</tt>:</p>

    <pre class="prettyprint lang-java">
public String toString() {
    return "центр = " + center + " і радіус = " + radius;
}
    </pre>

    <p>Змінна <tt class="prettyprint lang-java">center</tt> використовується з методом <tt class="prettyprint lang-java">center.toString()</tt>, тож метод <tt class="prettyprint lang-java">toString</tt> класа <tt class="prettyprint lang-java">Point</tt> може бути повторно використаний в методі <tt class="prettyprint lang-java">toString</tt> класа <tt class="prettyprint lang-java">Circle</tt>.</p>

    <h3>Композиція та спадкування</h3>

    <p>Тепер ми маємо знання про композицію та спадкування. В деяких ситуаціях важко обрати між ними.Важливо пам'ятати, що срібної кулі не існує - всі проблеми одним механізмом не вирішити. Кожну ситуацію треба уважно аналізувати, а потім обирати той, що підходить краще.</p>

    <p>Допоміжне правило полягає у використанні фраз "МАЄ" та "ЦЕ" для композиції та спадкування, відповідно. Наприклад,</p>

    <ul>
        <li>Комп'ютер МАЄ CPU.</li>
        <li>Коло ЦЕ фигура.</li>
        <li>Коло МАЄ крапку.</li>
        <li>Лептоп ЦЕ комп'ютер.</li>
        <li>Вектор ЦЕ список.</li>
    </ul>

    <p>Це правило може стати у нагоді для пошуку неправильних відношень. Наприклад, відношення "авто ЦЕ колесо" повністю невірне, що означає, що не можна мати відношення спадкування між класами <tt class="prettyprint lang-java">Car</tt> та <tt class="prettyprint lang-java">Tire</tt>. Однак, відношення "авто МАЄ колесо" (в сенсі, що авто має одно чи більше колес) я правильним - можна скласти об'єкт <tt class="prettyprint lang-java">Car</tt>, який вміщує об'єкти <tt class="prettyprint lang-java">Tire</tt>.</p>

    <p>В реальних сцеаріях відмінності у відношеннях можуть бути нетривіальними. Можна створити базовий клас, та помістити в нього спільну функціональність багатьох класів. Завжди варто перевіряти, чи існує відношення "ЦЕ" між похідними класами та базовим класом. Якщо - ні, краще використати композицію замість спадкування.</p>

    <p>Наприклад, розглянемо класи наборів даних <tt class="prettyprint lang-java">DynamicDataSet</tt> та <tt class="prettyprint lang-java">SnapShotDataSet</tt>, які потребують спільну функціональність — скажімо, сортування. Тепер можна породити ці класи наборів даних від реалізації сортування, як в Лістингу <a href="c02l17">2-17</a>.</p>

    <pre id="c02l17" class="prettyprint lang-java">
// Лістинг 2-17. Sorting.java
import java.awt.List;

public class Sorting {
    public List sort(List list) {
        // реалізація сортування
        return list;
    }
}

class DynamicDataSet extends Sorting {
    // реалізація DynamicDataSet
}

class SnapshotDataSet extends Sorting {
    // реалізація SnapshotDataSet
}
    </pre>

    <p>Це погане рішення і ось чому:</p>

    <ul>
        <li>Не виконується згадане вище правило. <tt class="prettyprint lang-java">DynamicDataSet</tt> не є типом <tt class="prettyprint lang-java">Sorting</tt>. Такі помилки в проектуванні класів можуть дорого коштувати, а їх пізне виправлення може стати неможливим в разі, коли накопичено багато коду, який неправильно використовує відношення спадкування. Наприклад, <tt class="prettyprint lang-java">Stack</tt> розширює <tt class="prettyprint lang-java">Vector</tt> в бібліотеці Java. Оскільки стек явно не є вектором, то це призводить не лише до проблем із сумісністю, але й призводить до помилок. При створенні об'єкта класа <tt class="prettyprint lang-java">Stack</tt>, який представлений в бібліотеці Java, можливо додатвати та видаляти елементи в будь-якому місці контейнера, оскільки базовим класом є <tt class="prettyprint lang-java">Vector</tt>, який дозволяє таку поведінку.</li>

        <li>Якщо ці два типи класів наборів даних матимуть справжній базовий клас <tt class="prettyprint lang-java">DataSet</tt>? В такому випадку чи <tt class="prettyprint lang-java">Sorting</tt> буде базовим класом для <tt class="prettyprint lang-java">DataSet</tt>, або клас <tt class="prettyprint lang-java">Sorting</tt> розташують між <tt class="prettyprint lang-java">DataSet</tt> та двома типами наборів даних. Обидва рішення будуть невірними.</li>

        <li>Ще один виклик: якщо один клас <tt class="prettyprint lang-java">DataSet</tt> забажає використовувати один алгоритм сортування (наприклад, <tt class="prettyprint lang-java">MergeSort</tt>), а інший клас наборів даних забажає використовувати інший алгоритм сортування (скажімо, <tt class="prettyprint lang-java">QuickSort</tt>)? Треба буде спадкувати від двох класів, які реалізують два різні алгоритми сортування? По-перше, не можна безпосередньо спадкувати від магатьох класів, оскільки Java не підтримує спадкування від декількох класів. По-друге, навіть якщо б таке можна було б зробити, (<tt class="prettyprint lang-java">MergeSort</tt> розширює <tt class="prettyprint lang-java">QuickSort</tt>, <tt class="prettyprint lang-java">QuickSort</tt> розширює <tt class="prettyprint lang-java">DataSet</tt>), це був би ще гірший проект.</li>
    </ul>

    <p>В такому випадку краще використовувати композицію — іншими словами, використовувати відношення "МАЄ", а не "Є". Код з результатом проектування класів наведено в Лістингу <a href="#c02l18">2-18</a>.</p>

    <pre id="c02l18" class="prettyprint lang-java">
// Лістинг 2-18. Sorting2.java
import java.awt.List;

interface Sorting2 {
    List sort(List list);
}

class MergeSort implements Sorting2 {
    public List sort(List list) {
        // реалізація сортування
        return list;
    }
}
class QuickSort implements Sorting2 {
    public List sort(List list) {
        // реалізація сортування
        return list;
    }
}

class DynamicDataSet {
    Sorting2 sorting;
    public DynamicDataSet() {
        sorting = new MergeSort();
    }
    // реалізація DynamicDataSet
}

class SnapshotDataSet {
    Sorting2 sorting;
    public SnapshotDataSet() {
        sorting = new QuickSort();
    }
    // реалізація SnapshotDataSet
}
    </pre>

    <hr class="Note"/>
    <p>Використовуйте спадкування, коли підклас уточнює базовий клас, з використанням динамічного поліморфізму. В інших випадках використовуйте композицію для отримання кода, який легко змінювати, та який слабко зв'язаний. Тобто, <strong>надавайте перевагу використанню композиції, а не спадкування</strong>.</p>
    <hr/>

    <h2>Синглтон і незмінні класи</h2>

    <p>Існує багато ситуацій, коли треба стоврювати спеціальні різновили класів. В цьому розділі обговоримо два такі різновили: синглтони та незмінні класи.</p>

    <h3>Створення класа синглтон</h3>

    <p>Інколи треба гарантувати, щоб певний клас був представлений лише одним екземпляром. Наприклад, треба визначити клас для внесення змін в реєстр, чи клас, який керує чергою завдань принтера, чи клас менеджер потоків. У всіх цих ситуаціях бажано уникнути помилок, які важко знайти, - шляхом забезпечення існування не більше одного об'єкта таких класів. Для цього можна створити клас <em>синглтон</em>.</p>

    <p>Клас синглтон гарантує, що буде створений лише один екзземпляр такого класа. Для забезпечення точки доступу клас контролює створення свого об'єкта. Класи синглтон можна знайти в багатьох місцях Java Development Kit (JDK), наприклад, <tt class="prettyprint lang-java">java.lang.Runtime</tt>.</p>

    <p>Рисунок <a href="#c02i02">2-2</a> показує діаграму класів для класа синглтон. Вона містить один клас, який можна зробити синглтоном. Він має приватний конструктор та статичний метод для отримання синглтон об'єкта.</p>

    <p><img src="img/c02i02.png"/><br/>
        <em><strong>Рисунок 2-2.</strong> Діаграма класів UML класа синглтон</em>
    </p>

    <hr class="Note"/>
    <p>Клас синглтон пропонує дві речі: один та лише один екземпляр класа, та глобальну єдину точку доступу до того об'єкта.</p>
    <hr/>

    <p>Припустимо, що треба реалізувати клас для журналювання деталей програми для відслідковування ходу її виконання з метою відлагодження. Для досягнення цієї мети може знадобитися гарантувати існування лише одного екземпляра класа <tt class="prettyprint lang-java">Logger</tt>, отже клас <tt class="prettyprint lang-java">Logger</tt> можна зробити класом синглтон (дивись Лістинг <a href="#c02l19">2-19</a>).</p>

    <pre id="c02l19" class="prettyprint lang-java">
// Лістинг 2-19. Logger.java
// Клас Logger може мати в програмі лише один екземпляр; ця вимога гарантує
// використання програмою того самого екземпляра
public class Logger {
    // оголосити приватний конструктор для заборони створення екземплярів
    // цього класа безпосередньо клієнтами
    private Logger() {
    }
    // по замовчанню, це поле ініціалізується в null
    private static Logger myInstance;
    // статичний метод для використання клієнтами для отримання екземпляра класа Logger
    public static Logger getInstance() {
        if(myInstance == null) {
            // це перший раз виклику цього метода
            // тому myInstance is null
            myInstance = new Logger();
        }
        // повертати посилання на той самий об'єкт кожен раз
        // коли викликається getInstance
        return myInstance;
        }
        public void log(String s) {
            // тривіальна реалізація журналу,
            // в якій наданий рядок друкується в консолі
            System.err.println(s);
    }
}
    </pre>

    <p>Розглянемо реалізацію синглтон класа <tt class="prettyprint lang-java">Logger</tt>. Конструктор класа оголошений як приватний, тож не можливо просто створити новий екземпляр класа <tt class="prettyprint lang-java">Logger</tt> через оператор <tt class="prettyprint lang-java">new</tt>. Єдиний спосіб отримати екземпляр цього класа - викликати статичний метод класа <tt class="prettyprint lang-java">getInstance()</tt>. В ньому перевіряється, чи вже існує об'єкт класа <tt class="prettyprint lang-java">Logger</tt>. Якщо ні, метод створює екземпляр класа <tt class="prettyprint lang-java">Logger</tt> та призначає його статичній змінній-члену. В такий споіб при кожному виклику метода <tt class="prettyprint lang-java">getInstance()</tt> буде повертатися один той самий об'єкт класа <tt class="prettyprint lang-java">Logger</tt>.</p>

    <h4>Ваш синглтон - це дійсно синглтон?</h4>

    <p>Насправді важливо (але й складно) гарантувати, що реалізація синглтону дозволяє лише один екземпляр класа. Наприклад, реалізація, яку наведено в Лістингу <a href="#c02l19">2-19</a>, працює лише в разі, коли програма одно-потокова. В разі багатьох потоків, спроба отримати синглтон об'єкт може привести до створення багатьох обє'ктів, що - звісно - порушує ціль реалізації синглтона. Лістинг <a href="#c02l20">2-20</a> містить версію класа <tt class="prettyprint lang-java">Logger</tt>, яка реалізує шаблон проекту синглтона в багато-потоковому оточенні.</p>

    <pre id="c02l20" class="prettyprint lang-java">
// Лістинг 2-20. Logger2.java
public class Logger2 {
    private Logger2() {
        // приватний конструктор для заборони прямого створення екземпляра
    }
    private static Logger2 myInstance;
    public static synchronized Logger2 getInstance() {
        if(myInstance == null)
            myInstance = new Logger2();
        return myInstance;
    }
    public void log(String s){
        // реалізація журнала
        System.err.println(s);
    }
}
    </pre>

    <p>Зверніть увагу на ключове слово <tt class="prettyprint lang-java">synchronized</tt> в цій реалізації. Це кючове слово є механізмом паралелізму в Java, який дозволяє лише один потік в один момент часу у синхронизованій області. Детальніше про це йдеться в Главі 11, присвяченій паралелізму.</p>

    <p>Отже, для того, щоб до метода можна було б мати доступ з боку лише одного потока в одиницю часу, цей метод має бути синхронізований. Тепер рішення стає коректним, але виникає інша проблема: слабка продуктивність. Можливо зробити цей метод синхонізованим лише при першому виклику, але оскільки весь метод оголошений як синхронізований, то всі наступні його виклики утикаються в гірло пляшки.</p>

    <p>Лістинг <a href="#c02l21">2-21</a> містить іншу реалізацію класа <tt class="prettyprint lang-java">Logger</tt>, в основі якої лежить ідіома "ініціалізація за вимогою". Ця ідіома передбачає використання внутрішній класів та не використовує конструкції синхронізації (про внутрішні класи йдеться в Главі 3). Вона експлуатує той факт, що внутрішні класи не завантажуються до моменту з'явлення посилання на них.</p>

    <pre id="c02l21" class="prettyprint lang-java">
// Лістинг 2-21. Logger3.java
public class Logger3 {
    private Logger3() {
        // приватний конструктор
    }
    public static class Logger3Holder {
        public static Logger3 logger = new Logger3();
    }
    public static Logger3 getInstance() {
        return Logger3Holder.logger;
    }
    public void log(String s) {
        // реалізація журналу
        System.err.println(s);
    }
}
    </pre>

    <p>Це рішення щодо синглтонів є продуктивним та працює в програмах з багатьма потоками. Однак, перед закриттям обговорення синглтонів - ще зауваження. По-перше, використовуйте синглтони лише там, де вони дійсно потрібні. По-друге, впевніться в тому, що ваша реалізація синглтону створює дійсно один екземпляр навіть в багато-поточному оточенні.</p>

    <h3>Незмінні класи</h3>

    <p>Незмінний об'єкт після створення та ініціалізації не можна змінювати. Можна викликати методи доступу (так звані, геттери), копіювати об'єкти або передавати їх як аргументи — але методи не можуть дозволити зміну стану об'єкта. Класи-обгортки (такі як <tt class="prettyprint lang-java">Integer</tt> чи <tt class="prettyprint lang-java">Float</tt>) та клас <tt class="prettyprint lang-java">String</tt> - це відомі приклади незмінних класів.</p>

    <p>имо про клас <tt class="prettyprint lang-java">String</tt>. <tt class="prettyprint lang-java">String</tt> є незмінним: після створення об'єкта <tt class="prettyprint lang-java">String</tt> він не може бути змінений. А як же з такими методами, як <tt class="prettyprint lang-java">trim</tt>, який видаляю лідуючі чи прикінцеві пробільні символи – такі методи змінюють стан об'єкта <tt class="prettyprint lang-java">String</tt>? Ні. Метод <tt class="prettyprint lang-java">trim</tt> видаляє такі символи та повертає новий об'єкт <tt class="prettyprint lang-java">String</tt> замість змінення наданого в якості аргумента <tt class="prettyprint lang-java">String</tt>.</p>

    <p>Створення незмінних об'єктів надає багато переваг. Обговоримо деякі з них в контексті класа <tt class="prettyprint lang-java">String</tt>:</p>

    <ul>
        <li>Незмінні об'єкти є безпечнішими у порівнянні із змінними. Після однієї перевірки значення незмінного об'єкта можна бути впевненим в тому, що воно залишиться таким самим та не буде змінено "за вашою спиною" (чиїмось кодом). Використання незмінних об'єктів запобігає внесенню помилок. Наприклад, якщо існує посилання на рядок, в якому є символи "абв", то при будь-якому подальшому використанні можна бути впевненим в тому, що в рядку все ще є символи "абв" (оскільки не може існувати коду, який змінив би рядок).</li>

        <li>Незмінні об'єкти безпечні в сенсі потоків. Наприклад, потік може мати доступ до об'єкта <tt class="prettyprint lang-java">String</tt> без турботи про те, що інший потік може змінити його – цього не може статися, оскільки об'єкт <tt class="prettyprint lang-java">String</tt> незмінний.</li>

        <li>Незмінні об'єкти, які мають один той самий стан, можуть економити місце, розділяючи цей стан. Наприклад, коли вміст однаковий, об'єкти <tt class="prettyprint lang-java">String</tt> спільно використовують той вміст. Для ілюстрації такого інтернування можна використати метод <tt class="prettyprint lang-java">intern()</tt>:
            <pre class="prettyprint lang-java">
String str1 = new String("абв");
String str2 = new String("абв");
System.out.println("str1 == str2: " + (str1 == str2));
System.out.println("str1.intern() == str2.intern(): "
    + (str1.intern() == str2.intern()));
// код надрукує:
str1 == str2 is false
str1.intern() == str2.intern() is true
            </pre>
        </li>
    </ul>

    <p>Переваги використання незмінних об'єктів так підкреслює Joshua Bloch в своїй книзі "Effective Java": <em>"Класи мають бути незмінними поки не з'являється дуже вагома причина зробити їх змінними... Якщо клас не можна зробити незмінним, треба максимально обмежити його змінність.”</em></p>

    <h4>Визначення незмінних класів</h4>

    <p>При створенні власних незмінних об'єктів треба мати на увазі наступне:</p>

    <ul>
        <li>Треба робити поля фінальними та ініціалізувати їх в конструкторі. Для примітивних типів значення фінальних полів не можна змінювати, а для посилальних типів не можна змінювати посилання.</li>

        <li>Для забезбечення незмінності посилальних типів потрібні додаткові заходи. Навіть якщо зробити змінний посилальний тип фінальним, все одно можливо, що члени посилатимуться на об'єкти, створені поза межами класа, або на них можна буде посилатися. В таких випадках:
            <ul>
                <li>Треба впевнитися в тому, що методи не змінюють вміст таких змінюваних о'єктів.</li>

                <li>Не треба розділяти посилання поза межами класів – наприклад, в якості значення результата метода класа. Якщо посилання на змінювані поля доступні за межами класа, за ними наприкінці можна змінити вміст об'єкта.</li>

                <li>Якщо треба повернути посилання, то варто повертати глибоку копію об'єкта (так вміст оригінального об'єкта залишиться недоторканим навіть в разі змінення зовнішнього об'єкта, який повертається).</li>
            </ul>
        </li>

        <li>Варто надавати лише методи для читання (геттери), а методи для змінення надавати не треба (сеттери).
            <ul>
                <li>В разі потреби змінненя вмісту об'єкта треба створити новий незмінний об'єкт з необхідними змінами та повернути посилання на нього.</li>
            </ul>
        </li>
        <li>Оголошуйте клас фінальним: якщо клас припускає спадкування, методи в похідному класі можуть бути перезаписані таким чином, щоб вносити зміни.</li>
    </ul>

    <p>Обговорення ключового слова <tt class="prettyprint lang-java">final</tt> - в наступній Главі 3 "Продвинуте проектання класів".</p>

    <p>Оглянемо клас <tt class="prettyprint lang-java">String</tt> для розуміння того, як перелічені аспекти реалізовані в ньому:</p>

    <ul>
        <li>Всі його поля приватні. Конструктори <tt class="prettyprint lang-java">String</tt> ініціалізують поля.</li>
        <li>Деякі методи, як <tt class="prettyprint lang-java">trim</tt>, <tt class="prettyprint lang-java">concat</tt> та <tt class="prettyprint lang-java">substring</tt> вимагають змінення вмісту об'єкта <tt class="prettyprint lang-java">String</tt>. Для забезпечення незмінності такі методи повертають нові об'єкти <tt class="prettyprint lang-java">String</tt> із зміненим вмістом.</li>
        <li>Клас <tt class="prettyprint lang-java">String</tt> фінальний, тож його не можна розширювати та перезаписувати його методи.</li>
    </ul>

    <p>Нижче наведено незміний клас для кола. Для стислості в прикладі показані лише методи для ілюстрації визначення незмінного класа (Лістинг <a href="#c02l22">2-22</a>).</p>

    <pre id="c02l22" class="prettyprint lang-java">
// Лістинг 2-22. ImmutableCircle.java
// Point це змінюваний клас
class Point {
    private int xPos, yPos;
    public Point(int x, int y) {
        xPos = x;
        yPos = y;
    }
    public String toString() {
        return "x = " + xPos + ", y = " + yPos;
    }
    int getX() { return xPos; }
    int getY() { return yPos; }
}

// ImmutableCircle це незмінний клас – стан його об'єктів
// не може бути змінений після створення
public final class ImmutableCircle {
    private final Point center;
    private final int radius;
    public ImmutableCircle(int x, int y, int r) {
        center = new Point(x, y);
        radius = r;
    }
    public String toString() {
        return "центр: " + center + " і радіус = " + radius;
    }
    public int getRadius() {
        return radius;
    }
    public Point getCenter() {
        // повернути копію об'єкта для запобігання
        // змінення значення changed в коді поза класом
        return new Point(center.getX(), center.getY());
    }
    public static void main(String []s) {
        System.out.println(new ImmutableCircle(10, 10, 20));
    }
    // інші члени пропущені...
}
    </pre>

    <p>Ця програма надрукує</p>

    <pre>
центр: x = 10, y = 10 і радіус = 20
    </pre>

    <p>Зверніть увагу на наступні аспекти у визначенні класа <tt class="prettyprint lang-java">ImmutableCircle</tt>:</p>

    <ul>
        <li>Клас оголошений як фінальний <tt class="prettyprint lang-java">final</tt> для захисту від спадкування на перезаписування його методів</li>
        <li>Клас має лише фінальні члени даних та вони <tt class="prettyprint lang-java">private</tt></li>
        <li>Оскільки <tt class="prettyprint lang-java">center</tt> це змінюване поле, метод-геттер <tt class="prettyprint lang-java">getCenter()</tt> повертає копію об'єкта <tt class="prettyprint lang-java">Point</tt></li>
    </ul>

    <p>Незмінні об'єкти мають деякі вади. Для забезпечення незмінності методи в незмінних класах можуть настворювати велику кількість об'єктів. Наприклад, кожного разу при виклику <tt class="prettyprint lang-java">getCenter()</tt> класа <tt class="prettyprint lang-java">ImmutableCircle</tt>, цей метод створює копію об'єкта <tt class="prettyprint lang-java">Point</tt> та повертає її. За цієї причини може знадобитися визначити також змінювану версію класа, наприклад, клас <tt class="prettyprint lang-java">Circle</tt>.</p>

    <p>Клас <tt class="prettyprint lang-java">String</tt> корисний в багатьох сценаріях; якщо викликати методи <tt class="prettyprint lang-java">trim</tt>, <tt class="prettyprint lang-java">concat</tt> чи <tt class="prettyprint lang-java">substring</tt> в циклі, то вони створять багато (тимчасових) об'єктів<tt class="prettyprint lang-java">String</tt>. На щастя, Java пропонує класи <tt class="prettyprint lang-java">StringBuffer</tt> та <tt class="prettyprint lang-java">StringBuilder</tt>, які змінювані. Вони надають схожу в порівнянні з <tt class="prettyprint lang-java">String</tt> функціональність, але об'єкти можуть змінюватися. Отже, в залежності від контекста, можна використовувати клас <tt class="prettyprint lang-java">String</tt> або один з класів <tt class="prettyprint lang-java">StringBuffer</tt> or <tt class="prettyprint lang-java">StringBuilder</tt>.</p>

    <h2>Використання ключового слова "<tt class="prettyprint lang-java">static</tt>"</h2>

    <p>Ключове слово <tt class="prettyprint lang-java">static</tt> може використовуватися в Java різними способами. Припустимо написання простого класа, який підраховує кількість своїх створених об'єктів. Чи працюватиме програма в Лістингу <a href="#c02l23">2-23</a>?</p>

    <pre id="c02l23" class="prettyprint lang-java">
// Лістинг 2-23. Counter.java
// Клас Counter має рахувати кількість створених екземплярів класа
public class Counter {
    private int count; // змінна для збереження кількості створених об'єктів
    // для кожного створеного об'єкта Counter викликається конструктор по змовчанню;
    // тож, оновлювати лічильник треба всередині конструктора по замовчанню
    public Counter() {
        count++;
    }
    public void printCount() { // метод для друку значення лічильника
        System.out.println("Кількість створених екземплярів: " + count);
    }
    public static void main(String []args) {
        Counter anInstance = new Counter();
        anInstance.printCount();
        Counter anotherInstance = new Counter();
        anotherInstance.printCount();
    }
}
    </pre>

    <p>Вивід програми такий:</p>

    <pre>
Кількість створених екземплярів: 1
Кількість створених екземплярів: 1
    </pre>

    <p>З вивод видно, що клас не відслідковує кількість створений об'єктів. Чому?</p>

    <p>Для підрахунку кількості об'єктів використана <em>змінна екземпляра</em> <tt class="prettyprint lang-java">count</tt>. Оскільи кожен екземпляр має своє значення для цієї змінної, він завжди друкує 1! Тут потрібна змінна зі спільним доступом серед всіх екземплярів. Цього можна досягти оголошенням змінної як <tt class="prettyprint lang-java">static</tt>. Статична змінна пов'язана з самим класом, а не з об'єктом чи екземпляром; такі змінні називаються <em>змінними класа</em>. Статична змінна ініціалізується один раз на початку виконання програми. Статична змінна розділяє свій стан з усіма екземплярами класа. Доступ до статичної змінної відбувається з використанням назви класа (а не екземпляра). Лістинг <a href="#c02l24">2-24</a> показує правильну реалізацію класа <tt class="prettyprint lang-java">Counter</tt> зі змінною <tt class="prettyprint lang-java">count</tt> та методом <tt class="prettyprint lang-java">printCount</tt>, оголошеними як статичні.</p>

    <pre id="c02l24" class="prettyprint lang-java">
// Лістинг 2-24. Counter2.java
// Клас Counter має рахувати кількість створених екземплярів класа
public class Counter2 {
    private static int count; // змінна для збереження кількості створених об'єктів
    // для кожного створеного об'єкта Counter викликається конструктор по змовчанню;
    // тож, оновлювати лічильник треба всередині конструктора по замовчанню
    public Counter2() {
        count++;
    }
    public static void printCount() { // метод для друку значення лічильника
        System.out.println("Кількість створених екземплярів: " + count);
    }
    public static void main(String []args) {
        Counter2 anInstance = new Counter2();
        // printCount викликається з використанням назви класа
        // а не назви змінної екземпляра
        Counter2.printCount();
        Counter2 anotherInstance = new Counter2();
        Counter2.printCount();
    }
}
    </pre>

    <p>Програма надрукує:</p>

    <pre>
Кількість створених екземплярів: 1
Кількість створених екземплярів: 2
    </pre>

    <p>Статична змінна <tt class="prettyprint lang-java">count</tt> ініціаоізується з початком виконання. При створенні першого об'єкта лічильник збільшується на одиницю. Так само, при створенні другого об'єкта значення <tt class="prettyprint lang-java">count</tt> стає 2. Як видно, обидва об'єкти оновлюють одну копію змінної<tt class="prettyprint lang-java">count</tt>.</p>

    <p>Зверніть увагу на те, що виклик <tt class="prettyprint lang-java">printCount()</tt> тепер використовує назву класа <tt class="prettyprint lang-java">Counter</tt>: <tt class="prettyprint lang-java">Counter.printCount()</tt>. Компілятор сприйме попередні два виклики <tt class="prettyprint lang-java">anInstance.printCount()</tt> та <tt class="prettyprint lang-java">anotherInstance.printCount()</tt> тому що немає семантичної різниці між викликами статичного метода з використанням назви класа чи назви змінної екземпляра.Однак, використовувати змінні екземпляра для виклику статичного метода не рекомендується. Є практикою домовленостей викликати методи екземпляра, використовуючи змінні екземпляра, а статичні методи - використовуюяи назви класів.</p>

    <p>Статичний метод може мати доступ лише до статичніх змінних та викликати лише статичні методи. Навпаки, метод екземплляра (не статичний) може викликати статичний метод та мати доступ до статичної змінної.</p>

    <h3>Статичний блок</h3>

    <p>Окрім статичних змінних та методів у визначенні класа можна визначати <em>статичний блок</em>. Такий статичний блок буде виконаний JVM при завантаженні класа в пам'ять. Наприклад, в попередньому прикладі, для ініціалізації змінної в значення 1 замість 0 <tt class="prettyprint lang-java">count</tt> можна визначити статичний блок, як показано в Лістингу <a href="#c02l25">2-25</a>.</p>

    <pre id="c02l25" class="prettyprint lang-java">
// Лістинг 2-25. Counter3.java
public class Counter3 {
    private static int count;
    static {
        // код в цьому статичному блоці буде виконаний
        // коли JVM завантажить клас в пам'ять
        count = 1;
    }
    public Counter3() {
        count++;
    }
    public static void printCount() {
        System.out.println("Кількість створених екземплярів: " + count);
    }
    public static void main(String []args) {
        Counter3 anInstance = new Counter3();
        Counter3.printCount();
        Counter3 anotherInstance = new Counter3();
        Counter3.printCount();
    }
}
    </pre>

    <p>Програма надрукує:</p>

    <pre>
Кількість створених екземплярів: 2
Кількість створених екземплярів: 3
    </pre>

    <p>Не треба плутати статичний блок з конструктором. Конструктор викликається при створенні екземпляра класа, а статичний блок - при завантаженні відповідного класа віртуальною машиною Java.</p>

    <h3>Пам'ятка</h3>

    <ul>
        <li>Метод <tt class="prettyprint lang-java">main()</tt>, в якому починається головне виконання програми, завжди оголошується статичним. Якби він був методом екземпляра, викликати його було б неможливо - перед запуском програми треба було б створити екземпляр, я потім викликати метод.</li>

        <li>Статичний метод, наданий базовим класом, не можна перезаписати. Метод для виклику визначається на основі типу екземпляра (поліморфізм часу виконання). Оскільки статичні методи пов'язані з класом (а не екземпляром), не можна перезаписати статичні методи і поліморфізм часу виконання не можливий із статичними методами.</li>

        <li>Статичний метод не може використовувати в своєму тілі ключове слово <tt class="prettyprint lang-java">this</tt>. Статичні методи пов'язані з класом, а не екземпляром. Тільки методи екземпляра мають неявне посилання, пов'язане з ними; отже методи класа не мають такого посилання.</li>

        <li>Статичний метод не може використовувати ключове слово <tt class="prettyprint lang-java">super</tt> в своєму тілі. Ключове слово <tt class="prettyprint lang-java">super</tt> використовується для виклику метода базового класа з перезаписаного метода похідного класа. Оскільки статичні методи не можна перезаписувати, ключове слово <tt class="prettyprint lang-java">super</tt> не має сенсу в його тілі.</li>

        <li>Оскільки статичні методи не можуть мати доступу до змінних екземпляра (не-статичних змінних), вони більш підходять для функцій обслуговування. В Java таких методів дуже багато. Наприклад, всі методи бібліотеки <tt class="prettyprint lang-java">java.lang.Math</tt> статичні.</li>

        <li>Виклик статичного метода вважається трохи більш продуктивним у порівнянні з методом екземпляра. Це викликане тим, що компілятор не мусить передавати неявне посилання на об'єкт <tt class="prettyprint lang-java">this</tt> при виклику статичного метода - на відміну від метода екземпляра.</li>
    </ul>

    <h2>Підсумки</h2>

    <p>Коротеньк оглянемо ключові моменти цієї глави.</p>

    <p><strong>Реалізовувати інкапсуляцію</strong></p>

    <ul>
        <li><em>Інкапсуляція</em>: поєднання в одній одиниці даних та функцій, які оперують ними.</li>
        <li>З похідного класа не можна мати доступ до <em>приватних</em> методів базового класа.</li>
        <li>Можна мати доступ до <em>захищеного</em> метода з класа в тому ж пакеті (як і для приватних елементів пакета чи елементів по замовчанню) чи в похідному класі.</li>
        <li>Також можна мати доступ до метода з <em>модифкатором доступу по замовчанню</em> якщо він в тому ж пакеті.</li>
        <li>Можна мати доступ до <em>публічних</em> методів класа з будь-якого іншого класа.</li>
    </ul>

    <p><strong>Реалізовувати спадкування з модифікаторами видимості та композицію</strong></p>

    <ul>
        <li><em>Спадкування</em>: створення ієрархічних відношень між пов'язаними класами. Спадкування також називається відношенням <em>"Є"</em>.</li>
        <li>Для виклику методів базового класа можна використовувати ключове слово <tt class="prettyprint lang-java">super</tt>.</li>
        <li>Спадкування означає відношення "Є", а композиція - "МІСТИТЬ".</li>
        <li>Композиції слід віддавати перевагу перед спадкуванням.</li>
    </ul>

    <p><strong>Реалізовувати поліморфізм</strong></p>

    <ul>
        <li><em>Поліморфізм</em>: Трактування однакового повідомлення (тобто, виклика метода) по-різному в залежності від контекста.</li>
        <li>Визначення виклику метода на основі динамічного типа об'єкта називається <em>поліморфізмом часу виконання</em>.</li>
        <li>Перевантаження - приклад <em>статичного поліморфізму (раннє зв'язування)</em>, в той час як перезаписування - приклад <em>динамічного поліморфізму (пізнє зв'язування)</em>.</li>
        <li><em>Перевантаження метода</em>: створення методів з однаковою назвою але різними типами та/або кількістю параметрів.</li>
        <li>Можна мати <em>перевантажені конструктори</em>. З одного конструктора класа можна викликати інший конструктор того ж класа за допомогою ключового слова <tt class="prettyprint lang-java">this</tt>.</li>
        <li><em>Визначення перевантаження</em> це процес пошуку компілятором серед доступних перевантажених визначень правильного виклику.</li>
        <li>При <em>перезаписуванні</em> назва метода, кількість аргументів, їх типи та тип результата мають точно співпадати.</li>
        <li>Для <em>сумісних типів результата</em> в якості типа, який повертається перезаписуваним методом, можна надавати похідний клас.</li>
    </ul>

    <p><strong>Перезаписувати методи hashCode, equals та toString в класі Object</strong></p>

    <ul>
        <li>В своїх класах можна перезаписувати методи <tt class="prettyprint lang-java">clone()</tt>, <tt class="prettyprint lang-java">equals()</tt>, <tt class="prettyprint lang-java">hashCode()</tt>, <tt class="prettyprint lang-java">toString()</tt> та <tt class="prettyprint lang-java">finalize()</tt>. Оскільки <tt class="prettyprint lang-java">getClass()</tt>, <tt class="prettyprint lang-java">notify()</tt>, <tt class="prettyprint lang-java">notifyAll()</tt> та еревантажені версії метода <tt class="prettyprint lang-java">wait()</tt> оголошені як <tt class="prettyprint lang-java">final</tt>, ці методи перезаписати не можна.</li>
        <li>При використанні об'єкта в таких контейнерах як <tt class="prettyprint lang-java">HashSet</tt> чи <tt class="prettyprint lang-java">HashMap</tt>треба впевнитися в тому, зо методи <tt class="prettyprint lang-java">hashCode()</tt> та <tt class="prettyprint lang-java">equals()</tt>правильно перезаписані. Наприклад, треба впевнитися в тому, що метод <tt class="prettyprint lang-java">hashCode()</tt> повертає те саме геш значення для двох об'єктів, якщо для них метод <tt class="prettyprint lang-java">equals()</tt> повертає <tt class="prettyprint lang-java">true</tt>.</li>
    </ul>

    <p><strong>Створювати та використовувати класи синглтон та незмінні класи</strong></p>

    <ul>
        <li>Синглтон гарантує створення тільки одного об'єкта класа.</li>
        <li>Гарантування того, що реалізація синглтона дйсно є синглтоном - нетривіальна задача, особливо в багато-поточному оточенні.</li>
        <li>Після створення та ініціалізації незмінного об'єкта він не може змінюватися.</li>
        <li>Незмінні об'єкти більш безпечні у використанні у порівнянні з об'єктами, які змінюються; також - в сенсі потоків; незмінні об'єкти, які мають однаковий стан, можуть економити простір, розділяючи цей стан між собою.</li>
        <li>Для оголошення незмінного класа треба зробити його фінальним. Всі його поля - приватними та фінальними. Треба надати лише методи-геттери, без методів, які вносять зміни. Для полів змінюваних посилальних типів чи методів, які повинні змінювати стан об'єкта, треба робити глибоку копію об'єкта.</li>
    </ul>

    <p><strong>Розроблювати код з використанням ключового слова <tt class="prettyprint lang-java">static</tt> в блоках ініціалізації, змінних, методах та класах</strong></p>

    <ul>
        <li>Є два типи змінних членів: класові змінні та змінні екземпляра. Всі змінні, для доступа до яких потрібен екземпляр класа (об'єкт), називаються <em>змінні екземпляра</em>. Всі змінн, які розділяються серед всіх екземплярів та пов'язані з класом, а не з об'єктом, називаються <em>змінними класа</em> (оголошуються з ключовим словом <tt class="prettyprint lang-java">static</tt>).</li>
        <li>Для доступа до будь-якого статичного члена не потрібен екземпляр - достатньо назви класа.</li>
        <li>Статичний член може мати доступ лише до статичних методів того ж класа.</li>
    </ul>

    <h1>Лекція 3</h1>
	<h1>Продвинуте проектування класів Java</h1>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=java&lang=bsh"></script>
	<p>Цілі</p>

	<ul>
		<li>Розробляти код з використанням абстрактних класів та методів</li>
        <li>Розробляти код з використанням ключового слова <tt class="prettyprint lang-java">final</tt></li>
        <li>Створювати внутрішні класи, включаючи статичний внутрішній клас, локальний клас, вкладений клас та анонімний внутрішній клас</li>
        <li>Використовувати типи перелічень, включаючи методи та конструктори в типі <tt class="prettyprint lang-java">enum</tt></li>
        <li>Розробляти код, який оголошує, реалізує та/або розширює інтерфейси, та використовувати анотацію <tt class="prettyprint lang-java">atOverride</tt></li>
        <li>Створювати та використовувати вирази Lambda</li>
	</ul>

	<p>В минулій частині ви вивчили базові концепції ООП та навчилися використовувати їх для побудови програм Java. В цій главі ви вивчите продвинуті концепції проектування класів. Також ви дізнаєтеся про ключову особливість функціонального програмування, яка з'явилася в Java 8: лямбда-вирази.</p>

    <p>Значна частина питань екзамену OCPJP пов'язана із змінами, які з'явилися в мові Java та основній бібліотеці Java 8. Ця глава розповідає про лямбда-вирази, які є базою для розуміння Stream API та можливостей пакета <tt class="prettyprint lang-java">java.util.function</tt>. Отже, обов'язково прочитайте розділи про інтерфейси та лямбда вирази.</p>

	<h2>Абстрактні класи</h2>

	<p>Часто буває, що потрібно визначити якусь абстракцію без завдання деталей реалізації. В таких випадках можна використати <em>абстрактні класи</em> чи <em>інтерфейси</em>. Абстрактні класи використовуються, коли треба визначити абстракцію з певною загальною функціональністю.</p>

    <p>Подивимось на клас <tt class="prettyprint lang-java">Shape</tt>, який пропонує абстракцію різних фігур, які можна зобразити в програмі для малювання.</p>

    <pre class="prettyprint lang-java">
abstract class Shape {
    public double area() { return 0; } // реалізація по замовчанню
    // інші члени
}
    </pre>

    <p>Для оголошення того, що клас є абстрактним, перед його визначенням використовується ключове слово <tt class="prettyprint lang-java">abstract</tt>. Можна створювати об'єкти <tt class="prettyprint lang-java">Shapes</tt>, такі як <tt class="prettyprint lang-java">Square</tt> чи <tt class="prettyprint lang-java">Circle</tt>, але чи є сенс у створенні об'єкта безпосередньо класу <tt class="prettyprint lang-java">Shape</tt>? Ні, в реальності не існує об'єкта <tt class="prettyprint lang-java">Shape</tt>.</p>

    <p>При спробі створити екземпляр класу <tt class="prettyprint lang-java">Shape</tt> компілятор повідомить про помилку, оскількі абтрактні класи не можуть мати екземплярів.</p>

    <p>У визначенні класу <tt class="prettyprint lang-java">Shape</tt> є метод <tt class="prettyprint lang-java">area()</tt>, який повертає площу окремої фігури. Цей метод може бути застосований для всіх вігур, саме тому його місце - в базовому класі <tt class="prettyprint lang-java">Shape</tt>. Однак, якою має бути реалізація метода <tt class="prettyprint lang-java">area()</tt> в класі <tt class="prettyprint lang-java">Shape</tt>? Не можна надати реалізацію по замовчанню; така реалізація цього метода: <tt class="prettyprint lang-java">return 0;</tt> - це погане рішення, хоча компілятор прийме його. Краще оголосити цей метод в якості абстрактного:</p>

    <pre class="prettyprint lang-java">
public abstract double area(); // примітка: без реалізації (тобто, без визначення тіла методу)
    </pre>

    <p>Як і у випадку з оголошенням абстрактного класу, оголошення метода <tt class="prettyprint lang-java">area()</tt> в якості абстракного здійснюється з використанням ключового слова <tt class="prettyprint lang-java">abstract</tt>. Головна різниця між звичайним методом та абстрактним методом полягає в тому, що для абстрактного методу не надається тіло. Якщо надати тіло, виникне помилка:</p>

    <pre class="prettyprint lang-java">
public abstract double area() { return 0; } // помилка компілятора!
    </pre>

    <p>Отримаємо помилку для такого визначення: <tt class="prettyprint lang-java">"abstract methods cannot have a body"</tt>. Оголошення абстрактного метода примушує всі підкласи надавати для нього визначення, саме тому його не можна надати в самому абстрактному класі. Якщо породжений клас не реалізує всі абстрактні методи, визначені в базовому класі, такий породжений клас має бути оголошений як абстрактний клас, як в наступному прикладі:</p>

    <pre class="prettyprint lang-java">
abstract class Shape {
    public abstract double area(); // без реалізації
    // інші члени
}

class Rectangle extends Shape { }
    </pre>

    <p>Цей фрагмент викличе помилку компіляції <tt class="prettyprint lang-bash">"Rectangle is not abstract and does not override abstract method area() in Shape"</tt>. Для її виправлення треба оголосити породжений клас як <tt class="prettyprint lang-java">abstract</tt> або надати в породженому класі визначення метода <tt class="prettyprint lang-java">area()</tt>. Немає сенсу оголошувати <tt class="prettyprint lang-java">Rectangle</tt> як абстрактний; тож можна так визначити метод <tt class="prettyprint lang-java">area()</tt>:</p>

    <pre class="prettyprint lang-java">
class Rectangle extends Shape {
    private int length, height;
    public double area() { return length * height; }
    // інші члени ...
}
    </pre>

	<h3>Пам'ятка</h3>

    <p>Передивіться наступні вислови про абстрактні класи та абстрактні методи для екзамену OCPJP 8:</p>

    <ul>
        <li>Ключове слово <tt class="prettyprint lang-java">abstract</tt> можна застосувати до класа або до не-статичного метода.</li>
        <li>Абстрактний клас може мати методи або поля, оголошені як статичні. Однак, ключове слово <tt class="prettyprint lang-java">abstract</tt> не можна застосовувати до полів або статичних методів.</li>
        <li>Абстрактний клас може розширювати інший абстрактний клас або реалізовувати інтерфейс.</li>
        <li>Абстрактний клас може бути породжений від звичайного класу! Хоча мова це дозволяє, це не дуже добра ідея.</li>
        <li>Абстрактний клас не зобов'язаний оголошувати абстрактний метод, тобто в абстрактному класі не обов'язково мають оголошуватися абстрактні методи. Однак, якщо в класі є абстрактний метод, то і клас має бути оголошений як абстрактний.</li>
        <li>Підклас абстрактного класу має надавати реалізацію всіх абстрактних методів; інакше треба такий підклас теж оголошувати як абстрактний.</li>
    </ul>

    <h2>Використання ключового слова "final"</h2>

    <p>Ключове слово <tt class="prettyprint lang-java">final</tt> може застосовуватися для класів, методів та змінних. Фінальний клас не можна розширювати (породжувати від нього підкласи); фінальні методи не можна перевизначати; значення фінальної змінної не може бути змінено після ініціалізації.</p>

    <h3>Фінальні класи</h3>

    <p>Фінальний клас - це <em>неспадковий клас</em> - тобто, якщо клас оголошений як фінальний, він не матиме підкласів. Дві важливі причини, за якими можна заборонити класу мати нащадків:</p>

    <ol>
        <li><em>Для запобігання зміні поведінки через створення підкласів</em>. В деяких випадках можна визнати реалізацію класа повною та незмінною. Якщо перевизначення дозволено, тоді поведінка методів може бути змінена. Звісно, що можна використовувати породжений об'єкт там, де потребується використання об'єкта базового класу, а інколи це неприпустимо. Зробивши клас фінальним, можна гарантувати користувачам класа незмінну поведінку.</li>
        <li><em>Підвищена продуктивність</em>. Виклики методів фінального класу можна розв'язати під час компіляції. Оскільки немає можливості перевизначити методи, для фінального класу не існує потреби розв'язувати дійсні виклики під час роботи, що означає підвищену продуктивність. За тієї ж причини фінальні класи заохочують до вбудови методів. Це означає, що тілом метода можна розширити код в місці виклику метода, уникаючи таким чином накладних витрат на виклик функції. Якщо виклики розв'язуються під час роботи, вони не можуть бути вбудовані.</li>
    </ol>

    <p>В бібліотеці Java багато класів оголошено як <tt class="prettyprint lang-java">final</tt>; наприклад, класи <tt class="prettyprint lang-java">String</tt> (<tt class="prettyprint lang-java">java.lang.String</tt>) та <tt class="prettyprint lang-java">System</tt> (<tt class="prettyprint lang-java">java.lang.System</tt>). Ці класи інтесивно використовуються в програмах Java. Якщо не оголосити їх як <tt class="prettyprint lang-java">final</tt>, можливо змінити поведінку цих класів через породження підкласів, і тоді ціла програма може почати поводитися інакше. Для уникнення цієї проблеми, такі широко використовані класи як ці, та такі класи-обгортки як <tt class="prettyprint lang-java">Number</tt> та <tt class="prettyprint lang-java">Integer</tt> зроблені в бібліотеці Java як <tt class="prettyprint lang-java">final</tt>.</p>

    <hr class="Note"/>

    <p>Приріст продуктивності, зумовлений фіналізацією класа, доволі помірний; треба використовувати <tt class="prettyprint lang-java">final</tt> там, де це доречно. Екзамен OCPJP 8 перевіряє знання щодо правильного використання ключового слова <tt class="prettyprint lang-java">final</tt>. Не треба перейматися деталями продуктивності.</p>

    <h3>Фінальні методи та змінні</h3>

    <p>В класі можна оголосити фінальний метод. Фнальний метод не можна перевизначити. Отже, якщо оголосити фінальний метод в не-фінальному класі, то буде можна розширити клас, але не можна перевизначити фінальний метод. Однак, інші - не-фінальні - методи базового класа можна перевизначити в реалізації породженого класа.</p>

    <p>Розглянемо методи <tt class="prettyprint lang-java">setParentShape()</tt> та <tt class="prettyprint lang-java">getParentShape()</tt> в класі <tt class="prettyprint lang-java">Shape</tt> (Лістинг <a href="#c03l01">3-1</a>).</p>

    <pre id="c03l01" class="prettyprint lang-java">
// Лістинг 3-1. Shape.java
public abstract class Shape {
    // інші члени класу пропущено
    final public void setParentShape(Shape shape) {
        // тіло методу
    }
    public Shape getParentShape() {
        // тіло методу
    }
}
    </pre>

    <p>Тут клас <tt class="prettyprint lang-java">Circle</tt> (підклас <tt class="prettyprint lang-java">Shape</tt>) може перевизначити лише <tt class="prettyprint lang-java">getParentShape()</tt>; якщо спробувати перевизначити фінальний метод, виникне наступна помилка: <tt class="prettyprint lang-java">"Cannot override the final method from Shape"</tt>.</p>

    <p>Фінальні змінні схожі на CD-ROM: після запису чогось на них знову записати не вийде. В програмуванні такі константи як PI можуть бути оголошені як фінальні, оскільки не треба, щоб хтось міг змінити їх значення. Якщо спробувати змінити значення фінальної змінної після ініціалізації, виникне помилка компіляції.</p>

    <h3>Пам'ятка</h3>

    <p>Передивіться наступні твердження для екзамену OCPJP 8:</p>

    <ul>
        <li>Можифікатор <tt class="prettyprint lang-java">final</tt> може застосовуватися для класу, методу або змінної. Всі методи фіінального класу неявно <tt class="prettyprint lang-java">final</tt> (їх не можна перевизначити).</li>
        <li>Змінна <tt class="prettyprint lang-java">final</tt> може отримати значення лише один раз. Якщо оголошення змінної визначає її як <tt class="prettyprint lang-java">final</tt>, але не ініціалізує її, тоді вона називається порожньою фінальною (blank final). Треба ініціалізувати порожню фінальну в усіх конструкторах, визначених в класі, або в блоці ініціалізації.</li>
        <li>Ключове слово <tt class="prettyprint lang-java">final</tt> можна застосувати до параметрів. Значення параметра <tt class="prettyprint lang-java">final</tt> не можна змінювати після призначення.</li>
    </ul>

    <h2>Різновиди вкладених класів</h2>

    <p>Класи, визначені в тілі іншого класу (чи інтерфейсу) відомі як <em>вкладені класи</em>. Зазвичай визначається клас як клас вищого рівня, який належить безпосередньо пакету. Навпаки, вкладені класи - це класи, які містяться всередині іншого класа чи інтерфейса.</p>

    <p>Для чого створювати класи всередині іншого класа чи інтерфейса? Існує декілька переваг. По-перше, можна покласти пов'язані класи разом як одну логічну групу. По-друге, вкладені класи мають доступ до всіх членів оточуючого класа, що може бути корисним в деяких випадках. По-третє, вкладені класи спрощують код. Наприклад, анонімні внутрішні класи корисні для написання спрощеного коду керування подіями з AWT/Swing.</p>

    <p>Існує чотири типи чи <em>різновиди (аромати, flavors)</em> вкладених класів Java:</p>

    <ul>
        <li>Статичний вкладений клас</li>
        <li>Внутрішній клас</li>
        <li>Локальний внутрішній клас</li>
        <li>Анонімний внутрішній клас</li>
    </ul>

    <p>На перший погляд різниця між цими різновидами не очевидна. Рисунок <a href="#c03i01">3-1</a> допоможе прояснити різниці між ними. <em>Локальний клас</em> визначається в блоці коду (методі, конструкторі чи блоці ініціалізації), в той час як <em>не-локальний клас</em> визначається всередині класа. <em>Статичний клас</em> кваліфікується з використанням ключового слова <tt class="prettyprint lang-java">static</tt>, в той час як a <em>не-статичний клас</em> не використовує ключове слово <tt class="prettyprint lang-java">static</tt> у визначенні класа. В <em>анонімному класі</em> не надається ім'я класа - лише визначається його тіло.</p>

    <p><img id="c03i01" src="img/c03i01.png"/><br/>
        <em><b>Рисунок 3-1</b>. Типи вкладених класів з прикладами</em>
    </p>

    <p>Як видно з Рисунку <a href="#c03i01">3-1</a>, <em>статичні вкладені класи</em> є статичні і не-локальні, в той час як <em>внутрішні класи</em> є не-статичні і не-локальні. Не-статичний і локальний вкладений клас - це <em>локальний внутрішній клас</em>, а локальний та анонімний вкладений клас - це <em>анонімний внутрішній клас</em>.</p>

    <p>Розглянемо кожен з цих чотирьох різновидів більш детально.</p>

    <h3>Статичні вкладені класи (чи інтерфейси)</h3>

    <p>Можна визначити клас (чи інтерфейс) як статичний член всередині іншого класа (чи інтерфейса).Оскільки зовнішній тип може бути класом або інтерфейсом, а внутрішні також можуть бути класом або інтерфейсом, то існує чотири комбінації. Нижче наведені приклади цих чотирьох типів:</p>

    <pre class="prettyprint lang-java">
class Outer {           // зовнішній клас має статичний вкладений клас
    static class Inner {}
}

interface Outer {       // зовнішній інтерфейс має статичний вкладений клас
    static class Inner {}
}

class Outer {           // зовнішній клас має статичний вкладений інтерфейс
    static interface Inner {}
}

interface Outer {       // зовнішній інтерфейс має статичний вкладений інтерфейс
    static interface Inner {}
}
    </pre>

    <p>Явно використовувати ключове слово <tt class="prettyprint lang-java">static</tt> із вкладеним інтерфейсом не потрібно, оскільки він неявно статичний. Подивимось на приклад створення та використання статичних вкладених класів.</p>

    <p>Розглянемо клас <tt class="prettyprint lang-java">Color</tt> (Лістинг <a href="#c03l02">3-2</a>) з полями <tt class="prettyprint lang-java">m_red</tt>, <tt class="prettyprint lang-java">m_green</tt> та <tt class="prettyprint lang-java">m_blue</tt>. Оскільки всі фігури можуть бути забарвлені, можна визначити клас <tt class="prettyprint lang-java">Color</tt> всередині класа <tt class="prettyprint lang-java">Shape</tt>.</p>

    <pre id="c03l02" class="prettyprint lang-java">
// Лістинг 3-2. TestColor.java
abstract class Shape {
    public static class Color {
        int m_red, m_green, m_blue;
        public Color() {
            // викликати інший перевантажений конструктор Color з наданням значень по замовчуванню
            this(0, 0, 0);
        }
        public Color(int red, int green, int blue) {
            m_red = red; m_green = green; m_blue = blue;
        }
        public String toString() {
            return " red = " + m_red + " green = " + m_green + " blue = " + m_blue;
        }
        // інші члени Color пропущені
    }
    // інші члени Shape пропущені
}

public class TestColor {
    public static void main(String []args) {
        // оскільки Color це статичний вкладений клас,
        // доступ до нього здійснюється з використанням імені зовнішнього класа: Shape.Color
        // зауважте, що екземпляр класа Shape для використання класа Color не створюється (і не може)
        Shape.Color white = new Shape.Color(255, 255, 255);
        System.out.println("Білий колір має значення:" + white);
    }
}
    </pre>

    <p>Він надрукує</p>

    <pre id="c03l02output">
Білий колір має значення: red = 255 green = 255 blue = 255
    </pre>

    <p>Тут клас <tt class="prettyprint lang-java">Shape</tt> оголошений як <tt class="prettyprint lang-java">abstract</tt>. Клас <tt class="prettyprint lang-java">Color</tt> визначений як <tt class="prettyprint lang-java">public static</tt> всередині класа <tt class="prettyprint lang-java">Shape</tt>. Клас <tt class="prettyprint lang-java">TestColor</tt> використовує синтаксис <tt class="prettyprint lang-java">Shape.Color</tt> для посилання на цей клас. Окрім цієї мінімальної відмінності клас <tt class="prettyprint lang-java">Color</tt> не відрізняється від визначення класу <tt class="prettyprint lang-java">Color</tt> ззовні класа <tt class="prettyprint lang-java">Shape</tt>. Отже, статичний вкладений клас - такий самий, як клас, визначений як зовнішній, за однією різницею - фізично він визначається всередині іншого класу!</p>

    <h4>Пам'ятка</h4>

    <p>Нижче наведено деякі примітні аспекти статичних вкладених класів (та інтерфейсів) для допомоги на екзамені OCPJP 8:</p>

    <ul>
        <li>Доступність (<tt class="prettyprint lang-java">public</tt>, <tt class="prettyprint lang-java">protected</tt> і т.п.) статичного вкладеного класу визначається зовнішнім класом.</li>
        <li>Ім'я статичного вкладеного класа виражається через синтаксис <tt class="prettyprint lang-java">OuterClassName.NestedClassName</tt>.</li>
        <li>При визначенні внутрішнього вкладеного класу (чи інтерфейсу) всередині інтерфейса вкладений клас оголошується неявно як <tt class="prettyprint lang-java">public</tt> та <tt class="prettyprint lang-java">static</tt>. Це просто запам'ятати: всі поля інтерфейса неявно оголошуються як <tt class="prettyprint lang-java">public</tt> та <tt class="prettyprint lang-java">static</tt>, і статичний вкладений клас має таку саме поведінку.</li>
        <li>Статичні вкладені класи можуть бути оголошені як <tt class="prettyprint lang-java">abstract</tt> чи <tt class="prettyprint lang-java">final</tt>.</li>
        <li>Статичні вкладені класи можуть розширювати інший клас чи використовуватися як базові класи.</li>
        <li>Статичні вкладені класи можуть мати статичні члени. (Нижче показано, що це твердження не стосується інших різновидів вкладених класів).</li>
        <li>Статичні вкладені класи можуть мати доступ до членів зовнішнього класу (лише до статичних, звичайно).</li>
        <li>Зовнішній клас також має доступ до членів (навіть приватних) вкладеного класу через об'єкт вкладеного класу. Якщо екземпляр вкладеного класу не оголошується, зовнішній клас не матиме безпосереднього доступу до елементів вкладеного класу.</li>
    </ul>

    <h3>Внутрішні класи</h3>

    <p>Всередині класа можна визначити клас (чи інтерфейс) як не-статичний член. А що на рахунок оголошення класу чи інтерфейсу всередині інтерфейсу? Як показано в третьому пункті вище про статичні внутрішні класи, при визначенні класу чи інтерфейсу всередині інтерфейсу він неявно є <tt class="prettyprint lang-java">static</tt>. Отже, оголосити не-статичний внутрішній інтерфейс неможжливо! Лишається дві можливості:</p>

    <pre class="prettyprint lang-java">
class Outer {   // зовнішній клас має внутрішній клас
    class Inner {}
}

class Outer {   // зовнішній клас має внутрішній інтерфейс
    interface Inner {}
} 
    </pre>

    <p>Створимо клас <tt class="prettyprint lang-java">Point</tt> для реалізації центра <tt class="prettyprint lang-java">Circle</tt>. Оскільки кожне коло <tt class="prettyprint lang-java">Circle</tt> має центральну <tt class="prettyprint lang-java">Point</tt>, добра ідея зробити <tt class="prettyprint lang-java">Point</tt> внутрішнім класом <tt class="prettyprint lang-java">Circle</tt> (Лістинг <a href="#c03l03">3-3</a>).</p>

    <pre id="c03l03" class="prettyprint lang-java">
// Лістинг 3-3. Circle.java
public class Circle {
    // виначити Point як внутрішній клас всередині класа Circle
    class Point {
        private int xPos;
        private int yPos;
        // для внутрішнього класа можна надати конструктор
        public Point(int x, int y) {
            xPos = x;
            yPos = y;
        }
        // внутрішній клас як будь-який інший - можна перевизначати методи
        public String toString() {
            return "(" + xPos + "," + yPos + ")";
        }
    }

    // використання внутрішнього класа для
    private Point center;
    private int radius;
    public Circle(int x, int y, int r) {
        // як його використовувати
        center = this.new Point(x, y);
        radius = r;
    }

    public String toString() {
        return "центр = " + center + " та радіус = " + radius;
    }

    public static void main(String []s) {
        System.out.println(new Circle(10, 10, 20));
    }
    // інші методи (наприклад, area) пропущені
}
    </pre>

    <p>В цій реалізації Point визначено як приватний член <tt class="prettyprint lang-java">Circle</tt>. Зауважте на створення екземпляра внутрішнього класу:</p>

    <pre class="prettyprint lang-java">
center = this.new Point(x, y);
    </pre>

    <p>Може здивувати, чому не використати звичайний оператор <tt class="prettyprint lang-java">new</tt> :</p>

    <pre class="prettyprint lang-java">
center = new Point(x, y);
    </pre>

    <p>Для створення екземпляра внутрішнього класа потрібно використовувати префікс з посиланням на об'єкт зовнішнього класа. В цьому випадку це посилання <tt class="prettyprint lang-java">this</tt>, отже треба використовувати <tt class="prettyprint lang-java">this</tt> перед оператором <tt class="prettyprint lang-java">new</tt>.</p>

    <hr class="Note"/>
    <p>Кожен внутрішній клас пов'язаний з екземпляром зовнішнього класа. Іншими словами, внутрішній клас завжди пов'язаний з оточуючим об'єктом.</p>
    <hr/>

    <p>Зовнішній та внутрішній класи розділяють особливе відношення, як друзі чи члени однієї родини. Доступ до членів можливий поза залежністю від специфікаторі доступу, навіть private. Але є тонка різниця. Із внутрішнього класу можна мати доступ до членів зовнішнього класу без створення екземпляра; але для доступу із зовнішнього класу до членів внутрішнього класу треба створити екземпляр внутрішнього класу.</p>

    <p>Єдине обмеження внутрішнього класа: не можна оголошувати ститичні члени:</p>

    <pre class="prettyprint lang-java">
class Outer {
    class Inner {
        static int i = 10;
    }
}
    </pre>

    <p>При спробі зробити це виникне помилка компілятора:</p>

    <pre class="prettyprint lang-bash">
Outer.java:3: inner classes cannot have static declarations
                static int i = 10;
    </pre>

    <h4>Пам'ятка</h4>

    <p>Вадливі правила про внутрішні класи та інтерфейси:</p>

    <ul>
        <li>Доступність (<tt class="prettyprint lang-java">public</tt>, <tt class="prettyprint lang-java">protected</tt> і т.п.) внутрішнього класа визначається зовнішнім класом.</li>
        <li>Як в разі класів найвищого рівня, внутрішній клас може розширювати клас чи реалізувати інтерфейси. Також інші класи можуть розширювати внутрішній клас, а інші класи чи інтерфейси можуть розширювати чи реалізовувати внутрішній інтерфейс.</li>
        <li>An inner class can be declared <tt class="prettyprint lang-java">final</tt> або <tt class="prettyprint lang-java">abstract</tt>.</li>
        <li>Внутрішні класи можуть мати внутрішні класи, але це може ускладнити читання та розуміння коду. Слід уникати надмірно ускладненої ієрархії!</li>
    </ul>

    <h3>Локальні внутрішні класи</h3>

    <p><em>Локальний внутрішній клас</em> визначається в блоці коду (наприклад, в методі, конструкторі чи блоці ініціалізації). На відміну від статичних вкладених класів та внутрішніх класів, локальні внутрішні класи не є членами зовнішнього класу; вони локальні по відношенню до метода чи коду, в яких визначені.</p>

    <p>Приклад загального синтаксису локального класа:</p>

    <pre class="prettyprint lang-java">
class SomeClass {
    void someFunction() {
        class Local { }
    }
}
    </pre>

    <p>Як видно в коді, <tt class="prettyprint lang-java">Local</tt> це клас, визначений всередині <tt class="prettyprint lang-java">someFunction</tt>. Він не доступний ззовні <tt class="prettyprint lang-java">someFunction</tt>, навіть членам <tt class="prettyprint lang-java">SomeClass</tt>. Оскільки не можна оголосити локальну змінну як <tt class="prettyprint lang-java">static</tt>, також не можливо оголосити локальний клас як <tt class="prettyprint lang-java">static</tt>.</p>

    <p>Оскільки в інтерфейсах не можна визначати методи, всередині інтерфейсів не можна мати локальні класи чи інтерфейси. Не можна створити локальні інтерфейси. Іншими словами, всередині методів, конструкторів чи блоків ініціалізації не можна визначити інтерфейс.</p>

    <p>Після знайомства із синтаксисом розглянемо практичний приклад. Раніше клас <tt class="prettyprint lang-java">Color</tt> був реалізований як статичний вкладений клас (Лістинг <a href="#c03l02">3-2</a>):</p>

    <pre class="prettyprint lang-java">
abstract class Shape {
    public static class Color {
        int m_red, m_green, m_blue;
        public Color() {
            this(0, 0, 0);
        }
        public Color(int red, int green, int blue) {
            m_red = red; m_green = green; m_blue = blue;
        }
        public String toString() {
            return " red = " + m_red + " green = " + m_green + " blue = " + m_blue;
        }
        // інші члени Color пропущені
    }
    // інші члени Shape пропущені
}
    </pre>

    <p>Метод <tt class="prettyprint lang-java">toString()</tt> показує строкове представлення <tt class="prettyprint lang-java">Color</tt>. Припустимо, що потрібно показувати строку <tt class="prettyprint lang-java">Color</tt> в такому форматі: <tt class="prettyprint lang-java">"Ви обрали колір із такими значеннями RGB: red = 0 green = 0 blue = 0"</tt>. Для цього в класі <tt class="prettyprint lang-java">StatusReporter</tt> потрібно визначити метод <tt class="prettyprint lang-java">getDescriptiveColor()</tt>. В <tt class="prettyprint lang-java">getDescriptiveColor()</tt> потрібно створити похідний клас <tt class="prettyprint lang-java">Shape.Color</tt>, в якому метод <tt class="prettyprint lang-java">toString</tt> повертатиме це описове повідомлення. Лістинг <a href="#c03l04">3-4</a> є реалізацією з використанням локальних класів.</p>

    <pre id="c03l04" class="prettyprint lang-java">
// Лістинг 3-4. StatusReporter.java
class StatusReporter {
    // важливо зауважити, що параметр "color" оголошений як final
    static Shape.Color getDescriptiveColor(final Shape.Color color) {
        // локальний клас DescriptiveColor розширює клас Shape.Color class
        class DescriptiveColor extends Shape.Color {
            public String toString() {
                return "Ви обрали колір із такими значеннями RGB:" + color;
            }
        }
        return new DescriptiveColor();
    }

    public static void main(String []args) {
        Shape.Color descriptiveColor =
                StatusReporter.getDescriptiveColor(new Shape.Color(0, 0, 0));
        System.out.println(descriptiveColor);
    }
}
    </pre>

    <p>Метод <tt class="prettyprint lang-java">main</tt> перевіряє правильність роботи <tt class="prettyprint lang-java">StatusReporter</tt>. Програма друкує</p>

    <pre id="c03l04output">
Ви обрали колір із такими значеннями RGB: red = 0 green = 0 blue = 0
    </pre>

    <p>Подивимось, як визначений локальний клас. Метод <tt class="prettyprint lang-java">getDescriptiveColor()</tt> отримує звичайний класовий об'єкт <tt class="prettyprint lang-java">Shape.Color</tt> та повертає об'єкт <tt class="prettyprint lang-java">Shape.Color</tt>. Всередині метода <tt class="prettyprint lang-java">getDescriptiveColor()</tt> визначений клас <tt class="prettyprint lang-java">DescriptiveColor</tt> - локальний для цього метода. Цей <tt class="prettyprint lang-java">DescriptiveColor</tt> є породженим класом від <tt class="prettyprint lang-java">Shape.Color</tt>. Всередині класа <tt class="prettyprint lang-java">DescriptiveColor</tt> визначений єдиний метод <tt class="prettyprint lang-java">toString()</tt>, який перевизначає метод <tt class="prettyprint lang-java">toString()</tt> базового класа <tt class="prettyprint lang-java">Shape.Color</tt>. Після визначення класа <tt class="prettyprint lang-java">DescriptiveColor</tt> метод <tt class="prettyprint lang-java">getDescriptiveColor</tt> створює об'єкт класа <tt class="prettyprint lang-java">DescriptiveColor</tt> та повертає його.</p>

    <p>В класі <tt class="prettyprint lang-java">StatusReporter</tt> метод <tt class="prettyprint lang-java">main()</tt> викликає метод <tt class="prettyprint lang-java">StatusReporter.getDescriptiveColor()</tt> та зберігає результат в посиланні <tt class="prettyprint lang-java">Shape.Color</tt>. Метод <tt class="prettyprint lang-java">getDescriptiveColor()</tt> повертає об'єкт <tt class="prettyprint lang-java">DescriptiveColor</tt>, який породжений від <tt class="prettyprint lang-java">Shape.Color</tt>, то ж ініціалізація змінної <tt class="prettyprint lang-java">descriptiveColor</tt> спрацьовує. В <tt class="prettyprint lang-java">println</tt> динамічний тип <tt class="prettyprint lang-java">descriptiveColor</tt> є об'єктом <tt class="prettyprint lang-java">DescriptiveColor</tt>, отже друкується детальний опис кольорового об'єкта.</p>

    <p>Ще цікава деталь в методі <tt class="prettyprint lang-java">getDescriptiveColor(</tt>. Його параметр оголошений як <tt class="prettyprint lang-java">final</tt>. Навіть якщо не надавати ключове слово <tt class="prettyprint lang-java">final</tt>, компілятор трактуватиме параметр як <em>фактично фінальний</em> - це означає, в локальному класі не можна змінити цю змінну. Якщо спробувати, виникне помилка компіляції:</p>

    <pre class="prettyprint lang-java">
static Shape.Color getDescriptiveColor(Shape.Color color) {
    // local class DescriptiveColor that extends Shape.Color class
    class DescriptiveColor extends Shape.Color {
        public String toString() {
            return "You selected a color with RGB values" + color;
        }
    }
    </pre>
    <b>
        <pre>
    color = null; // присвоєння – НЕ скомпілюється
        </pre>
    </b>
    <pre>
    return new DescriptiveColor();
}
    </pre>

    <p>Виникне помилка:</p>

    <pre>
StatusReporter.java:8: error: local variables referenced from an inner class must be final or effectively final
return "You selected a color with RGB values" + color;
^
1 error
    </pre>

    <p>З-за присвоєння змінній <tt class="prettyprint lang-java">color</tt> вона стає не фінальною, отже компілятор видає помилку при спробі отримати доступ до неї з боку локального внутрішнього класу.</p>

    <hr class="Note"/>

    <p>В локальний внутрішній клас можна передавати лише <b>фінальні</b>. Якщо не оголосити змінну, до якої має доступ локальний внутрішній клас фінальною, компілятор трактуватиме її як <em>фактично фінальну</em>.</p>

    <hr/>

    <h4>Пам'ятка</h4>

    <p>Про локальні класи:</p>

    <ul>
        <li>Можна створювати не-статичний локальний клас всередині тіла коду. Інтерфейси не можуть мати локальних класів, не можна створити локальні інтерфейси.</li>
        <li>Локальні класи доступні лише з тіла коду, в якому вони визначені. Локальні класи повністю не доступні з-за меж тіла коду, в якому вони визначені.</li>
        <li>При визначенні локального класу можна розширювати клас чи реалізувати інтерфейси.</li>
        <li>Локальний клас моє доступ до всіх змінних, доступних в тілі коду, в якому він визначений. Змінні, до яких має доступ локальний внутрішній клас, трактуються як фактично фінальні.</li>
    </ul>

    <h3>Анонімні внутрішні класи</h3>

    <p>Як видно з імені, <em>анонімний внутрішній клас</em> не має імені. Оголошення класа автоматично породжується з виразу створення екземпляра. Також їх називають просто <em>анонімними класами</em>.</p>

    <p>Анонімний клас корисний майже у всіх випадках, де використовуться локальний внутрішній клас. Локальний внутрішній клас має ім'я, в той час як анонімний клас - ні, і в цьому полягає головна відмінність. Додактова відмінність полягає в тому, що анаонімний внутрішній клас не має жодного явного конструктора. Ім'я конструктора співпадає з іменем класа, а оскільки у анонімного класа немає імені, то ж і конструктора бути не може!</p>

    <p>(Зауваження: немає такого поняття як "анонімні інтерфейси").</p>

    <p>Приклад для розуміння синтаксису локального класа:</p>

    <pre class="prettyprint lang-java">
class SomeClass {
    void someFunction() {
        new Object() { };
    }
}
    </pre>

    <p>В операторі <tt class="prettyprint lang-java">new Object() { };</tt> оголошується породжений клас <tt class="prettyprint lang-java">Object</tt> через пряме використання ключового слова <tt>new</tt>. Він не визначає код та повертає екземпляр того породженого об'єкта. Створений об'єкт ніде не використовується, то ж ігнорується. Вираз <tt class="prettyprint lang-java">new</tt> викликає конструктор по замовчанню; можна викликати конструктор базового класу з декількома параметрами, передаючи аргументи у виразі <tt>new</tt>.</p>

    <p>Розглянемо більш практичний приклад. В попередньому прикладі (Лістинг <a href="#c03l04">3-4</a>), клас <tt class="prettyprint lang-java">DescriptiveColor</tt> визначений всередині метода <tt class="prettyprint lang-java">getDescriptiveColor</tt> в класі <tt class="prettyprint lang-java">StatusReporter</tt>. Можна спростити код, перетворивши локальний клас на анонімний клас, як показано в Лістингу <a href="#c03l05">3-5</a>.</p>

    <pre id="c03l05" class="prettyprint lang-java">
// Лістинг 3-5. StatusReporter2.java
class StatusReporter2 {
    static Shape.Color getDescriptiveColor(final Shape.Color color) {
        // використання анонімного інутрішнього класа
        // -- зокрема, немає імені класа, він конструюється
        // та використовується "на льоту" в операторі return!
        return new Shape.Color() {
            public String toString() {
                return "Ви обрали колір з такими значеннями RGB:" + color;
            }
        };
    }

    public static void main(String []args) {
        Shape.Color descriptiveColor =
                StatusReporter.getDescriptiveColor(new Shape.Color(0, 0, 0));
        System.out.println(descriptiveColor);
    }
}
    </pre>

    <p>Він друкує</p>

    <pre id="c03l05output">
Ви обрали колір з такими значеннями RGB: red = 0 green = 0 blue = 0
    </pre>

    <p>Залишок програми, включаючи метод <tt class="prettyprint lang-java">main()</tt>залишається таким самим, а метод <tt class="prettyprint lang-java">getDescriptiveColor()</tt> стає простішим! Явно клас з іменем не створюється (а був <tt class="prettyprint lang-java">DescriptiveColor)</tt>; замість цього створюється породжений клас від <tt class="prettyprint lang-java">Shape.Color</tt> "на льоту" в операторі <tt class="prettyprint lang-java">return</tt>. Ключове слово <tt class="prettyprint lang-java">class</tt> також не потрібне.</p>

    <h4>Пам'ятка</h4>

    <p>Про анонімні класи:</p>

    <ul>
        <li>Анонімні класи визначаються саме у виразі <tt class="prettyprint lang-java">new</tt>.</li>
        <li>Не можна явно розширити клас або явно реалізувати інтерфейси при визначенні анонімного класу.</li>
    </ul>

    <h2>Тип даних Enum</h2>

    <p>Припустимо, користувач має вибрати з набору констант, які визначають декілька типів принтерів:</p>

    <pre class="prettyprint lang-java">
public static final int DOTMATRIX = 1;
public static final int INKJET = 2;
public static final int LASER= 3;
    </pre>

    <p>Таке рішення працює. Однак, якщо передати будь-яке інше значення цілого (наприклад, 10), компілятор при'ме його. Отже, таке рішення не є <em>типо-безпечним</em>. В Java 5 з'явився тип даних <em>enum</em> для допомоги в таких ситуаціях.</p>

    <p>Лістинг <a href="#c03l06">3-6</a> визначає клас перелічень (перелічення - це клас) для приклада вище.</p>

    <pre id="c03l06" class="prettyprint lang-java">
// Лістинг 3-6. EnumTest.java
// визначити тип перелічення для класифікації типів принтерів
enum PrinterType {
    DOTMATRIX, INKJET, LASER
}
// перевірити перелічення
public class EnumTest {
    PrinterType printerType;
    public EnumTest(PrinterType pType) {
        printerType = pType;
    }
    public void feature() {
        // вибір на основі типу принтера, наданого конструктору
        switch(printerType){
            case DOTMATRIX:
            System.out.println("Матричні принтери економічні та майже застарілі");
            break;
            case INKJET:
            System.out.println("Струмінні принтери пропонують пристойну якість друку");
            break;
            case LASER:
            System.out.println("Лазерні принтери пропонують найкращу якість друку");
            break;
        }
    }
    public static void main(String[] args) {
        EnumTest enumTest = new EnumTest(PrinterType.LASER);
        enumTest.feature();
    }
}
    </pre>

    <p>Він друкує</p>

    <pre id="c03l06output">
Лазерні принтери надають найкращу якість друку
    </pre>

    <p>Розглянемо Лістинг <a href="#c03l06">3-6</a> більш детально.</p>

    <ul>
        <li>В операторі switch-case не треба надавати повнстю кваліфіковані імена елементів перелічення - switch приймає екземпляр типу перелічення, а отже розуміє контекст, в якому вказані елементи перелічення.</li>
        <li>Значення <tt class="prettyprint lang-java">PrinterType.LASER</tt> надається при створенні об'єкта перелічення <tt class="prettyprint lang-java">EnumTest</tt>. Якщо надати будь-яке інше значення окрім значень перелічення, виникне помилка компілятора. Іншими словами, перелічення є типо-безпечними.</li>
    </ul>

    <p>Можна оголосити перелічення (<tt class="prettyprint lang-java">PrinterType</tt> в прикладі) в окремому файлі, як оголошуються звичайні класи Java.</p>

    <p>Розглянемо приклад, в якому визначаються члени типу даних перелічення: атрибути та методи (Лістинг <a href="#c03l07">3-7</a>).</p>

    <pre id="c03l07" class="prettyprint lang-java">
// Лістинг 3-7. EnumTest2.java
enum PrinterType {
    DOTMATRIX(5), INKJET(10), LASER(50);
    private int pagePrintCapacity;
    private PrinterType(int pagePrintCapacity) {
        this.pagePrintCapacity = pagePrintCapacity;
    }
    public int getPrintPageCapacity() {
        return pagePrintCapacity;
    }
}

public class EnumTest2 {
    PrinterType printerType;
    public EnumTest2(PrinterType pType) {
        printerType = pType;
    }
    public void feature() {
        switch (printerType) {
            case DOTMATRIX:
            System.out.println("Матричні принтери економічні");
            break;
            case INKJET:
            System.out.println("Струмінні принтери пропонують пристойну якість друку");
            break;
            case LASER:
            System.out.println("Лазерні принтери пропонують найкращу якість друку");
            break;
        }
        System.out.println("Швидкість друку за хвилину: " +
                printerType.getPrintPageCapacity());
    }

    public static void main(String[] args) {
        EnumTest2 enumTest1 = new EnumTest2(PrinterType.LASER);
        enumTest1.feature();
        EnumTest2 enumTest2 = new EnumTest2(PrinterType.INKJET);
        enumTest2.feature();
    }
}
    </pre>

    <p>The output of the above program is given below:</p>

    <pre id="c03l07output">
Лазерні принтери пропонують найкращу якість друку
Швидкість друку за хвилину: 50
Струмінні принтери пропонують пристойну якість друку
Швидкість друку за хвилину: 10
    </pre>

    <p>В цій програмі для класа перелічення визначаються новий атрибут, новий конструктор та новий метод. Атрибут <tt class="prettyprint lang-java">pagePrintCapacity</tt> встановлюється початковими значеннями, вказаними з елементами перелічення (такими як <tt class="prettyprint lang-java">LASER(50)</tt>), які викликають конструктор класа перелічення. Однак, клас перелічення не може мати публічний конструктор, інакше компілятор поскаржиться з таким повідомленням: <tt class="prettyprint lang-java">"Illegal modifier for the enum constructor; only private is permitted"</tt>.</p>

    <hr class="Note"/>
    <p>Конструктор в класі перелічення може бути вказаний лише приватним.</p>
    <hr/>

    <h3>Пам'ятка</h3>

    <ul>
        <li>Перелічення неявно оголошуються як <tt class="prettyprint lang-java">public</tt>, <tt class="prettyprint lang-java">static</tt> та <tt class="prettyprint lang-java">final</tt>, тобто, їх не можна розширювати.</li>
        <li>При визначенні перелічення воно неявно породжується від <tt class="prettyprint lang-java">java.lang.Enum</tt>. Внутрішньо перелічення перетворюються на класи. Далі константи перелічень є екземплярами класа перелічення, для якого константа оголошена як член.</li>
        <li>До елемента перелічення можна застосувати методи <tt class="prettyprint lang-java">valueOf()</tt> та <tt class="prettyprint lang-java">name()</tt>, щоб повернути назву елемента перелічення.</li>
        <li>Якщо оголосити перелічення всередині класа, воно по замовчанню буде статичним.</li>
        <li>Для типів даних перелічення не можна використовувати оператор <tt>new</tt>, навіть всередині класа перелічення.</li>
        <li>Два перелічення можна порівняти на тотожність, використовуючи оператор <tt class="prettyprint lang-java">==</tt>.</li>
        <li>Якщо константи перелічення походять з двох різних перелічень, метод <tt class="prettyprint lang-java">equals()</tt> не поверне <tt>true</tt>.</li>
        <li>Коли викликається метод константи перелічення <tt class="prettyprint lang-java">toString()</tt>, він друкує назву константи перелічення.</li>
        <li>Статичний метод <tt class="prettyprint lang-java">values()</tt> в класі <tt class="prettyprint lang-java">Enum</tt> повертає масив констант перелічення при виклику на типі перелічення.</li>
        <li>Константи перелічення не можна клонувати. Спроба призведе до <tt class="prettyprint lang-java">CloneNotSupportedException</tt>.</li>
    </ul>

    <hr class="Note"/>
    <p>Перелічення Enum уникає магічних чисел, що покращує читабельність та розумілість коду. Перелічення - типо-безпечні конструкції. Отже, слід використовувати перелічення там, де є потреба в наборі пов'язаних констант.</p>

    <hr/>

    <h2>Інтерфейси</h2>

    <p>Інтерфейс - це набір абстрактних методів, який визначає протокол (тобто, договір щодо поведінки). Класи, які реалізують інтерфейс, мають реалізувати методи, вказані в інтерфейсі. Інтерфейс визначає протокол, а клас, який реалізує інтерфейс, забезпечує виконання цього протоколу. Іншими словами, інтерфейс обіцяє певну функціональність своїм клієнтам, визначаючи абстракцію. Всі класи, які реалізують інтерфейс, надають власні реалізації обіцяної функціональності.</p>

    <h3>Оголошення та реалізація Інтерфейсів</h3>

    <p>Реалізуємо власний інтерфейс для об'єктів фігур. Деякі округлі об'єкти (наприклад, <tt class="prettyprint lang-java">Circle</tt> та <tt class="prettyprint lang-java">Ellipse</tt>) можуть бути <em>прокатані (rolled)</em> на певний градус. Можна створити інтерфейс <tt class="prettyprint lang-java">Rollable</tt> та оголосити метод <tt class="prettyprint lang-java">roll()</tt>:</p>

    <pre class="prettyprint lang-java">
interface Rollable {
    void roll(float degree);
}
    </pre>

    <p>Інтерфейс визначається з використанням ключового слова <tt class="prettyprint lang-java">interface</tt>; оголошується метод <tt class="prettyprint lang-java">roll()</tt>, який приймає один аргумент - <tt class="prettyprint lang-java">degree</tt>, градус кута повороту. Тепер реалізуємо цей інтерфейс в класі <tt class="prettyprint lang-java">Circle</tt> (дивись Лістинг <a href="#c03l08">3-8</a>).</p>

    <pre id="c03l08" class="prettyprint lang-java">
// Лістинг 3-8. Circle2.java
// Shape - базовий клас для всіх об'єктів фігур; об'єкти фігур, які пов'язані з
// батьківським об'єктом фігури, запам'ятовують його в полі parentShape
abstract class Shape {
    abstract double area();
    private Shape parentShape;
    public void setParentShape(Shape shape) {
        parentShape = shape;
    }
    public Shape getParentShape() {
        return parentShape;
    }
}

// Інтерфейс Rollable може біти реалізований округлими фігурами, наприклад, Circle
interface Rollable {
    void roll(float degree);
}

abstract class CircularShape extends Shape implements Rollable { }

// Circle це певний клас, під-тип CircularShape;
// його можна прокатити, отже він реалізує Rollable через базовий клас CircularShape
public class Circle2 extends CircularShape {
    private int xPos, yPos, radius;
    public Circle2(int x, int y, int r) {
        xPos = x;
        yPos = y;
        radius = r;
    }
    public double area() { return Math.PI * radius * radius; }
    @Override
    public void roll(float degree) {
        // тут реалізувати функціональність качення...
        // поки просто надрукувати кут качення в консолі
        System.out.printf("качення кругу на %f градусів\n", degree);
    }
    public static void main(String[] s) {
        Circle2 circle = new Circle2(10,10,20);
        circle.roll(45);
    }
}
    </pre>

    <p>Тут <tt class="prettyprint lang-java">CircularShape</tt> реалізує інтерфейс <tt class="prettyprint lang-java">Rollable</tt> та розширює абстрактний клас <tt class="prettyprint lang-java">Shape</tt>. Тепер певний (конкретний) клас як <tt class="prettyprint lang-java">Circle</tt> може розширити цей абстрактний клас та визначити метод <tt class="prettyprint lang-java">roll()</tt>. Декілька важливих зауважень до цього прикладу:</p>

    <ul>
        <li>Абстрактний клас <tt class="prettyprint lang-java">CircularShape</tt> реалізує фнтерфейс <tt class="prettyprint lang-java">Rollable</tt>, але не має визначати метод <tt class="prettyprint lang-java">roll()</tt>. Певний клас <tt class="prettyprint lang-java">Circle</tt>, який розширює <tt class="prettyprint lang-java">CircularShape</tt>, визначає цей метод пізніше.</li>
        <li>Для реалізації інтерфейса використовується ключове слово <tt class="prettyprint lang-java">implements</tt>. Назва метода, його параметри та тип, що повертається, у визначенні класу мають точно співпадати з наданими в інтерфейсі; якщо цього не відбувається, клас не розглядається як такий, що реалізує той інтерфейс.</li>
        <li>Опціонально можна використовувати анотацію <tt class="prettyprint lang-java">@Override</tt> для вказівки на те, що метод перевизначений з базового типу. В прикладі метод <tt class="prettyprint lang-java">roll</tt> перевизначений в класі <tt class="prettyprint lang-java">Circle</tt>, та використовує анотацію <tt class="prettyprint lang-java">@Override</tt>.</li>
    </ul>

    <p>Клас може реалізувати багато інтерфейсів одночасно як безпосередньо, так і через свій базовий клас. Наприклад, клас <tt class="prettyprint lang-java">Circle</tt> також може реалізувати стандартний інтерфейс <tt class="prettyprint lang-java">Cloneable</tt> (для створення копій об'єктів <tt class="prettyprint lang-java">Circle</tt>) та інтерфейс <tt class="prettyprint lang-java">Serializable</tt> (для збереження об'єкта в файлі для подальшого відтворення, тощо):</p>

    <pre class="prettyprint lang-java">
class Circle extends CircularShape implements Cloneable, Serializable {
    /* визначення таких методів як clone */
}
    </pre>

    <h4>Пам'ятка</h4>

    <p>Про інтерфейси:</p>

    <ul>
        <li>Інтерфейс не може мати екземпляр. Посилання на інтерфейс є посиланням на об'єкт будь якого типу, що реалізує цей інтерфейс.</li>
        <li>Інтерфейс може розширити інший інтерфейс. Для цього використовується ключове слово <tt class="prettyprint lang-java">extends</tt> (а не <tt class="prettyprint lang-java">implements</tt>).</li>
        <li>Інтерфейси не можуть містити змінні екземплярів. При оголошенні в інтерфейсі члена даних, він має бути ініціалізований, та всі такі члени трактуються як "<tt class="prettyprint lang-java">public static final</tt>".</li>
        <li>Інтерфейс може мати три типи методів: абстрактні методи, методи по замовчаннб та статичні методи.</li>
        <li>Інтерфейс можна оголосити з порожнім тілом (тобто, інтерфейс без членів). Наприклад, <tt class="prettyprint lang-java">java.util</tt> визначає інтерфейс <tt class="prettyprint lang-java">EventListener</tt> без тіла.</li>
        <li>Інтерфейс можна оголосити всередині іншого інтерфейса або класа; такі інтерфейси називають вкладеними інтерфейсами.</li>
        <li>На відміну від інтерфейсів найвищого рівня, які можуть бути лише <tt class="prettyprint lang-java">public</tt> чи <tt class="prettyprint lang-java">default</tt>, вкладені інтерфейси можуть оголошувати доступ <tt class="prettyprint lang-java">public</tt>, <tt class="prettyprint lang-java">protected</tt> або <tt class="prettyprint lang-java">private</tt>.</li>
        <li>При реалізації інтерфейса в абстрактному класі не треба визначати метод. Але в певному (конкретному) класі абстрактний метод, оголошений в інтерфейсі, має бути обов'язково визначений.</li>
        <li>Для вказівки на те, що метод перевизначає базовий, можна використовувати анотацію <tt class="prettyprint lang-java">@Override</tt>.</li>
    </ul>

    <h3>Абстрактні класи та інтерфейси</h3>

    <p>Абстрактні класи та інтерфейси мають багато спільного. Наприклад, можуть оголошувати методи, обов'язкові для визначення породженими класами. Також вони схожі тим, що не можна створити екземпляр ні абстрактного класу, ні інтерфейсу. В Таблиці <a href="#c03t01">3-1</a> перелічено деякі з важливих відмінностей.</p>

    <p><em><b>Таблиця 3-1</b>. Абстрактні класи та інтерфейси</em></p>

    <table id="c03t01">
        <tr>
            <th>&nbsp;</th>
            <th>Абстрактні класи</th>
            <th>Інтерфейси</th>
        </tr>
        <tr>
            <td>Ключові слова</td>
            <td><tt class="prettyprint lang-java">abstract</tt> та <tt class="prettyprint lang-java">class</tt> для визначення класа.</td>
            <td><tt class="prettyprint lang-java">interface</tt> для визначення інтерфейса.</td>
        </tr>
        <tr>
            <td>Ключові слова для реалізації класа</td>
            <td><tt class="prettyprint lang-java">extends</tt> для спадкування від абстрактного класа.</td>
            <td><tt class="prettyprint lang-java">implements</tt> для реалізації інтерфейса.</td>
        </tr>
        <tr>
            <td>Поля</td>
            <td>Абстрактний клас може мати статичні та не-статичні поля.</td>
            <td>Не можна мати не-статичні поля (змінні екземплярів); всі поля по замовчанню public static final</td>
        </tr>
        <tr>
            <td>Константи</td>
            <td>Абстрактний клас може мати як статичні так і не-статичні константи.</td>
            <td>Інтерфейси можуть мати лише татичні. При визначенні поля воно має бути ініціалізоване. Всі поля неявно трактуються як <tt class="prettyprint lang-java">public static</tt> та <tt class="prettyprint lang-java">final</tt>.</td>
        </tr>
        <tr>
            <td>Конструктори</td>
            <td>В абстрактному класі можна визначити конструктор (корисний для ініціалізації полів, наприклад).</td>
            <td>В інтерфейсі оголосити/визначити конструтор не можна.</td>
        </tr>
        <tr>
            <td>Специфікатори доступу</td>
            <td>В абстрактному класі можна мати приватні та захищені члени.</td>
            <td>В інтерфейсі не можна мати приватні чи захищені члени; всі члени по замовчанню публічні.</td>
        </tr>
        <tr>
            <td>Одиночне та множинне спадкування</td>
            <td>Клас може спадкувати лише від одного класа (абстрактного чи конкретного).</td>
            <td>Клас може реалізувати скільки завгодно інтерфейсів.</td>
        </tr>
        <tr>
            <td>Призначення</td>
            <td>Абстрактний клас надає протокол; крім того, слугує в якості базового у відношенні "являється".</td>
            <td>Інтерфейс лише надає протокол. Він вказує функціональність, яка має бути надана класом, який реалізує інтерфейс.</td>
        </tr>
    </table>

    <h4>Методи: абстрактні, по замовчанню та статичні</h4>

    <p>В прикладі <tt class="prettyprint lang-java">Rollable</tt> був лише один метод - <tt class="prettyprint lang-java">roll()</tt>. Однак, зазвичай інтерфейси мають багато методів. Наприклад, <tt class="prettyprint lang-java">java.util</tt> визначає інтерфейс <tt class="prettyprint lang-java">Iterator</tt> так:</p>

    <pre class="prettyprint lang-java">
public interface Iterator&lt;E&gt; {
    boolean hasNext();

    E next();
    
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer&lt;? super E&gt; action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
    </pre>

    <p>Цей інтерфейс призначений для проходження колекції. (Не звертайте уваги на “<tt class="prettyprint lang-java">&lt;E&gt;</tt>” d <tt class="prettyprint lang-java">Iterator&lt;E&gt;</tt>. Це — посилання на тип елементу, мова про це піде в наступній главі). Він оголошує два методи <tt class="prettyprint lang-java">hasNext()</tt> та <tt class="prettyprint lang-java">next()</tt> - тож, класи, які реалізовуватимуть цей інтерфейс, мають визначити ці два методи. Немає потреби використовувати ключове слово <tt class="prettyprint lang-java">abstract</tt> (але за бажанням можна) тому що методи без тіла неявно вважаються абстрактними.</p>

    <p>Інтерфейс також має визначення для методів <tt class="prettyprint lang-java">remove()</tt> та <tt class="prettyprint lang-java">forEachRemaining()</tt>. Ці методи відомі як <em>методи по замовчанню</em> та вони супроводжуються ключовим словом <tt class="prettyprint lang-java">default</tt>. Класи, які реалізують інтерфейс <tt class="prettyprint lang-java">Iterator</tt>, наслідують ці два методи та можуть їх перевизначити.</p>

    <p>Інтерфейс може містити також статичні методи. Наприклад, <tt class="prettyprint lang-java">java.util.stream.Stream</tt> має статичні методи <tt class="prettyprint lang-java">builder</tt>, <tt class="prettyprint lang-java">empty</tt>, <tt class="prettyprint lang-java">of</tt>, <tt class="prettyprint lang-java">iterate</tt>, <tt class="prettyprint lang-java">generate</tt> та <tt class="prettyprint lang-java">concat</tt>.</p>

    <hr class="Note"/>
    <p>До Java 8 інтерфейси могли лише оголошувати методи(тобто, вони могли надавати лише абстрактні методи).</p>
    <p>Для підтримки лямбда-функцій Java 8 запропонувала великі зміни до інтерфейсів: тепер в інтерфейсі можна визначати методи по замовчанню та статичні методи.</p>
    <hr/>

    <h5>Методи по замовчанню</h5>

    <p>В інтерфейсах методи по замовчанню це методи, визначені з тілом методу з використанням ключового слова <tt calss="prettyprint lang-java">default</tt>. Методи по замовчанню це методи екземпляра. Всередині методів по замовчанню ключове слово <tt class="prettyprint lang-java">this</tt> посилається на оголошуючий інтерфейс. Методи по замовчуванню можуть викликати методи інтерфейсів, в яких вони оточені.</p>

    <p>Чому в Java 8 до інтерфейсів були додані методи по замовчуванню? Коротка відповідь: для підтримки виразів лямбда-функцій (в наступному розділі піде мова про лямбди). Методи по замовчуванню спрощують розвиток інтерфейсів. Яким чином? До Java 8 не можна було визначати методи — можна було лише оголошувати їх. Тож, при додаванні нового методу до існуючого інтерфейсу можна було порушити класи, які реалізують цей інтерфейс, але не визначають цей новий метод. Але в Java 8, з методами по замовчанню, можливо розвивати інтерфейси з більшою легкістю.</p>

    <p>Поглянемо для прикладу на інтерфейс  <tt class="prettyprint lang-java">java.lang.Iterable</tt>До Java 8 він мав лише один метод:</p>

    <pre class="prettyprint lang-java">
Iterator&lt;T&gt; iterator();
    </pre>

    <p>В Java 8 інтерфейс <tt class="prettyprint lang-java">Iterable</tt> був розширений двома методами: <tt class="prettyprint lang-java">forEach</tt> та <tt class="prettyprint lang-java">spliterator</tt>. Для запобігання порушенню класів, які реалізують цей інтерфейс, ці методи визначені як методи по замовчанню. Тож всі класи, які реалізують інтерфейс <tt class="prettyprint lang-java">Iterable</tt> (наприклад, клас <tt class="prettyprint lang-java">ArrayList</tt>), тепер також мають ці два методи. Нижче наведено визначення інтерфейсу <tt class="prettyprint lang-java">Iterable</tt> (без коментарів документації).</p>

    <pre class="prettyprint lang-java">
public interface Iterable&lt;T&gt; {
    Iterator&lt;T&gt; iterator();
    default void forEach(Consumer&lt;? super T&gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    default Spliterator&lt;T&gt; spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
    </pre>

    <p>Додавання методів <tt class="prettyprint lang-java">forEach</tt> та <tt class="prettyprint lang-java">spliterator</tt> до цього інтерфейсу не порушує існуючі класи, які реалізують інтерфейс <tt class="prettyprint lang-java">Iterator</tt>, тому що ці методи — методи по замовчанню. В такий спосіб методи по замовчанню допомагають розвитку інтерфейсів. Методи по замовчанню також спрощують життя за рахунок того, що всередині інтерфейсів можна надавати закінченні визначення — без потреби їх перевизначення.</p>

    <p>Багато класів існуючих бібліотек (зокрема, <tt class="prettyprint lang-java">Collections</tt>)було додано до Java 8 з методами по замовчанню. Наприклад, інтерфейс <tt class="prettyprint lang-java">List</tt> має наступні три методи, які були додані в Java 8:</p>

    <pre class="prettyprint lang-java">
default void sort(Comparator&lt;? super E&gt; c)
default Spliterator&lt;E&gt; spliterator()
default void replaceAll(UnaryOperator&lt;E&gt; operator)
    </pre>

    <h4>Пам'ятка</h4>

    <p>Про методи: абстрактні, по замовчанню та статичні</p>

    <ul>
        <li>Не можна оголошувати члени як <tt class="prettyprint lang-java">protected</tt> або <tt class="prettyprint lang-java">private</tt>. Лише <tt class="prettyprint lang-java">public</tt> доступ дозволений для членів інтерфейса. Оскільки всі методи публічні по замовчанню, ключове слово <tt class="prettyprint lang-java">public</tt> можна пропускати.</li>
        <li>Всі методи, оголошені в інтерфейсі (методи без тіла) неявно трактуються як абстрактні. Для метода можна за бажанням вказати кваліфікатор <tt class="prettyprint lang-java">abstract</tt>.</li>
        <li>Методи по замовчанню повинні мати тіло методу. Методи по замовчанню повинні бути кваліфіковані з використанням ключового слова <tt class="prettyprint lang-java">default</tt>. Класи, які реалізують інтерфейс, спадкують визначення методів по замовчанню, які можуть бути перевизначені.</li>
        <li>Метод по замовчанню може бути перевизначений в породженому класі як абстрактний метод; для такого перевизначення можна використовувати анотацію <tt class="prettyprint lang-java">@Override</tt>.</li>
        <li>Не можна кваліфікувати методи по замовчанню як <tt class="prettyprint lang-java">synchronized</tt> або <tt class="prettyprint lang-java">final</tt>.</li>
        <li>Статичні методи повинні мати тіло методу та кваліфікуються з використанням ключового слова <tt class="prettyprint lang-java">static</tt>.</li>
        <li>Не можна надавати ключове слово <tt class="prettyprint lang-java">abstract</tt> для статичних методів: В породжених класах не можна перевизначати статичні методи, тож залишити статичні методи абстрактними шляхом не надання тіла метода концептуально не можливо.</li>
        <li>Не можна використовувати ключове слово <tt class="prettyprint lang-java">default</tt> для статичних методів, оскільки всі методи по замовчанню є методами екземпляра.</li>
    </ul>

    <h3>Діамантова проблема</h3>

    <p>В Java інтерфейс або клас може розширювати багато інтерфейсів. Наприклад, на Рисунку <a href="#c03i02">3-2</a> наведено ієрархію класів з пакету <tt class="prettyprint lang-java">java.nio.channels</tt>. Базовим є інтерфейс <tt class="prettyprint lang-java">Channel</tt>. Два інтерфейси - <tt class="prettyprint lang-java">ReadableByteChannel</tt> та <tt class="prettyprint lang-java">WriteableByteChannel</tt> - розширюють цей базовий інтерфейс. Наприкінці, інтерфейс <tt class="prettyprint lang-java">ByteChannel</tt> розширює <tt class="prettyprint lang-java">ReadableByteChannel</tt> та <tt class="prettyprint lang-java">WriteableByteChannel</tt>. Форма ієрархії нагадує ромб, або діамант.</p>

    <p><img id="c03i02" src="img/c03i02.png"><br/>
        <em><b>Рисунок 3-2</b>. Діамантова ієрархія в пакеті java.nio.channels</em>
    </p>

    <p>В цьому прикладі базовий інтерфейс <tt class="prettyprint lang-java">Channel</tt> не має методів. Інтерфейс <tt class="prettyprint lang-java">ReadableByteChannel</tt> оголошує метод <tt class="prettyprint lang-java">read</tt>, а інтерфейс <tt class="prettyprint lang-java">WriteableByteChannel</tt> оголошує метод <tt class="prettyprint lang-java">write</tt>; інтерфейс <tt class="prettyprint lang-java">ByteChannel</tt> спадкує обидва методи - <tt class="prettyprint lang-java">read</tt> та <tt class="prettyprint lang-java">write</tt> від цих базових типів. Оскільки два методи різні, то конфлікту немає, а ієрархія робоча.</p>

    <p>Але що, якщо б в цих базових типах визначалися два методи з однаковою сигнатурою - який з них наслідував би інтерфейс <tt class="prettyprint lang-java">ByteChannel</tt>? Ця проблема відома під назвою "діамантової".</p>

    <p>еред обговоренням робочого прикладу з діамантовою проблемою треба чітко зрозуміти обставини її можливого з'явлення в Java.</p>

    <ul>
        <li>В Java не можна розширювати багато класів одночасно; отже, діамантова проблема не може виникнути внаслідок розширення двох класів. Однак, діамантова проблема може трапитися в породженому класі, якщо абстрактний клас та інтерфейс визначають методи з однаковими сигнатурами.</li>
        <li>Коли два базових інтерфейса мають абстрактні методи з однаковими сигнатурами, це насправді не призводить до діамантової пролеми, оскільки йдеться лише про оголошення, а не про визначення методів.</li>
        <li>Інтерфейси можуть лише визначати методи, а не поля (вони можуть містити константи). Отже, діамантова проблема не трапляєтсья для полів в інтерфейсах - лише при визначенні методів.</li>
    </ul>

    <p>На щастя, існують правила для розв'язання (адресації, resolve) методів у випадку, коли породжений тип наслідує від двох різних базових типів визначення методів з однаковою сигнатурою. Розглянемо два важливих сценарія.</p>

    <p><b>Сценарій 1</b>: Якщо два супер-інтерфейси визначають методи з однаковими сигнатурами, компілятор викличе помилку. Треба розв'язати конфлікт вручну (Лістинг <a href="#c03l09">3-9</a>).</p>

    <pre id="c03l09" class="prettyprint lang-java">
// Лістинг 3-9. Diamond.java
interface Interface1 {
    default public void foo() { System.out.println("Метод foo 1"); }
}

interface Interface2 {
    default public void foo() { System.out.println("Метод foo 2"); }
}

public class Diamond implements Interface1, Interface2 {
    public static void main(String []args) {
        new Diamond().foo();
    }
}
    </pre>

    <pre>
Diamond.java:10: error: types Interface1 and Interface2 are incompatible;
public class Diamond implements Interface1, Interface2 {
       ^
  class Diamond inherits unrelated defaults for foo() from types Interface1 and Interface2
1 error
    </pre>

    <p>В цьому випадку треба розв'язати конфлікт вручну, застосовуючи ключове слово <tt class="prettyprint lang-java">super</tt> всередині класа <tt class="prettyprint lang-java">Diamond</tt> для явного указання на те, визначення якого саме методу слід використовувати:</p>

    <pre class="prettyprint lang-java">
public void foo() { Interface1.super.foo(); }
    </pre>

    <p>Після додавання цього визначення метода в клас <tt class="prettyprint lang-java">Diamond</tt> та виконання програма друкує:</p>

    <pre>
Метод foo 1
    </pre>

    <p><b>Сценарій 2</b>: Якщо базовий клас та базовий інтерфейс визначають методи з однаковими сигнатурами, використовується визначення метода в класі, а визначення в інтерфейсі ігнорується (Лістинг <a href="#c03l10">3-10</a>).</p>

    <pre id="c03l10" class="prettyprint lang-java">
// Лістинг 3-10. Diamond2.java
class BaseClass {
    public void foo() { System.out.println("Метод foo класа"); }
}

interface BaseInterface {
    default public void foo() { System.out.println("Метод foo інтерфейса"); }
}

public class Diamond2 extends BaseClass implements BaseInterface {
    public static void main(String []args) {
        new Diamond2().foo();
    }
}
    </pre>

    <p>В цьому випадку не виникає помилки компіляції: компілятор розв'язує визначення на користь визначення в класі, а визначення в інтерфейсі ігнорується. Ця програма друкує "Метод foo класа". Таку поведінка трактується як правило "клас виграє". Це правило допомагає підтримувати сумісність з попередніми версіями Java. Коли до інтерфейса додається метод по замовчанню, він може отримати таку саму сигнатуру, як і у метода, який визначений в базовому класі. Розв'язуючи конфлікт за правилом "клас виграє", завжди обирається метод з базового класа.</p>

    <h4>Функціональні інтерфейси</h4>

    <p>В бібліотеці Java існує багато методів, які оголошують єдиний абстрактний метод; наприклад:</p>

    <pre class="prettyprint lang-java">
// в пакеті java.lang
interface Runnable { void run(); }

// в пакеті java.util
interface Comparator&lt;T&gt; { boolean compare(T x, T y); }

// в пакеті java.awt.event:
interface ActionListener { void actionPerformed(ActionEvent e); }

// в пакеті java.io
interface FileFilter { boolean accept(File pathName); }
    </pre>

    <p>В Java 8 було запроваджено концепцію "функціональних інтерфейсів", яка формалізує цю ідею. Функціональний інтерфейс вказує лише один абстрактний метод. Оскільки функціональні інтерфейси вказують лише один абстрактний метод, вони інколи називаються типом або інтерфейсом Single Abstract Method (SAM).</p>

    <p>Примітка: Функціональні інтерфейси можуть мати узагальнені параметри, як в інтерфейсах <tt class="prettyprint lang-java">Comparator&lt;T&gt;</tt> та <tt class="prettyprint lang-java">Callable&lt;T&gt;</tt> з прикладів вище. Узагальнення будуть розглянуті в наступній главі (Глава 4).</p>

    <hr class="Note"/>
    <p>Оголошення функціонального інтерфейса свторює "тип функціонального інтерфейса", який може бути використаний з виразами лямбда. Далі, функціональні інтерфейси широко використовуються в пакетах <tt class="prettyprint lang-java">java.util.function</tt> та <tt class="prettyprint lang-java">java.util.stream</tt>, запроваджених в Java 8.</p>
    <hr/>

    <p>Для того, щоб інтерфейс трактувався як функціональний, він повинен мати лише один абстрактний метод. Однак, він може мати багато визначених методів по замовчанню або статичних методів. Розглянемо декілька прикладів з бібліотеки Java для кращого розуміння цього.</p>

    <p>Нижче наведено визначення інтерфейса <tt class="prettyprint lang-java">java.util.function.IntConsumer</tt> (без анотацій та коментарів javadoc):</p>

    <pre class="prettyprint lang-java">
public interface IntConsumer {
    void accept(int value);
    default IntConsumer andThen(IntConsumer after) {
        Objects.requireNonNull(after);
        return (int t) -&gt; { accept(t); after.accept(t); };
    }
}
    </pre>

    <p>Хоча цей інтерфейс має два члени, метод <tt class="prettyprint lang-java">andThen</tt> є методом по замовчанню і лише метод <tt class="prettyprint lang-java">accept</tt> є абстрактним методом. Отже, інтерфейс <tt class="prettyprint lang-java">IntConsumer</tt> є функціональним інтерфейсом.</p>

    <p>Інший приклад, інтерфейс <tt class="prettyprint lang-java">java.util.function.Predicate</tt> є функціональним інтерфейсом, оскільки має лише один абстрактний метод:</p>

    <pre class="prettyprint lang-java">
boolean test(T t)
    </pre>

    <p>Але важливо зауважити, що <tt class="prettyprint lang-java">Predicate</tt> також має наступні визначення методів по замовчанню:</p>

    <pre class="prettyprint lang-java">
default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)
default Predicate&lt;T&gt; negate()
default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)
    </pre>

    <p>Більш за те, він також має визначення статичного метода <tt class="prettyprint lang-java">isEqual</tt>:</p>

    <pre class="prettyprint lang-java">
static &ltT&gt; Predicate&lt;T&gt; isEqual(Object targetRef)
    </pre>

    <p>При всіх цих визначеннях методів <tt class="prettyprint lang-java">Predicate</tt> є функціональним інтерфейсом, оскільки має лише один абстрактний метод <tt class="prettyprint lang-java">test</tt>.</p>

    <h4>Анотація @FunctionalInterface</h4>

    <p>Компілятор Java сприймає будь-який інтерфейс з єдиним абстрактним методом в якості функціонального інтерфейса. Однак, можна помітити функціональний інтерфейс анотацією <tt class="prettyprint lang-java">@FunctionalInterface</tt> для більшої впевненості. Надання анотації <tt class="prettyprint lang-java">@FunctionalInterface</tt> функціональним інтерфейсам є рекомендованою практикою, оскільки компілятор надає кращі повідомлення про помилки та попередження при наявності такої анотації.</p>

    <p>Приклад використання <tt class="prettyprint lang-java">@FunctionalInterface</tt> з одним абстрактним методом, тож без проблем з компіляцією:</p>

    <pre class="prettyprint lang-java">
@FunctionalInterface
public abstract class AnnotationTest {
    abstract int foo();
}
    </pre>

    <p>Інший приклад</p>

    <pre class="prettyprint lang-java">
@FunctionalInterface
public interface AnnotationTest {
    default int foo() {};
}
    </pre>

    <p>Виникає помилка компіляції “no abstract method found in interface”, оскільки є лише метод по замовчанню, а абстрактного метода немає. Ще приклад.</p>

    <pre class="prettyprint lang-java">
@FunctionalInterface
public interface AnnotationTest { /* методів немає */ }
    </pre>

    <p>Цей інтерфейс не має методів. Оскільки бракує абстракного метода, але є анотація <tt class="prettyprint lang-java">@FunctionalInterface</tt>, виникне помилка компіляції.</p>

    <p>Інший варіант:</p>

    <pre class="prettyprint lang-java">
@FunctionalInterface
public interface AnnotationTest {
    int foo();
    int bar();
}
    </pre>

    <p>Цей код теж призведе до помилки компіляції “multiple non-overriding abstract methods found”, оскільки в ньому більше одного абстрактного метода, а функціональний інтерфейс вимагає рівно одного.</p>

    <hr/>

    <span style="text-transform:uppercase"><p>Методи класа Object в функціональних інтерфейсах</p></span>

    <p>У відповідності із спецификацією мови програмування Java (версія 8.0), "інтерфейси не спадкують від Object, а натомість неявно оголошують такі самі методи, як в Object". При наданні в інтерфейсі абстрактного метода з класа <tt class="prettyprint lang-java">Object</tt> цей інтерфейс залишається функціональним інтерфейсом.</p>
    
    <p>Наприклад, розглянемо інтерфейс <tt class="prettyprint lang-java">Comparator</tt>, який оголошує два абстрактних методи:</p>

    <pre class="prettyprint lang-java">
@FunctionalInterface
public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
    boolean equals(Object obj);
    // інші методи є методами по замовчанню чи статичними на пропущені
}
    </pre>

    <p>Цей інтерфейс є функціональним інтерфейсом, хоча він декларує два абстрактних методи: <tt class="prettyprint lang-java">compare()</tt> та <tt class="prettyprint lang-java">equals()</tt>. Як таке можливо? Це пояснюється тим, що сигнатура метода <tt class="prettyprint lang-java">equals()</tt> співпадає з такою із <tt class="prettyprint lang-java">Object</tt>, і метод <tt class="prettyprint lang-java">compare()</tt> лишається єдиним абстрактним методом, отже інтерфейс <tt class="prettyprint lang-java">Comparator</tt> є функціональним інтерфейсом.</p>

    <p>Розглянемо визначення інтерфейса:</p>

    <pre class="prettyprint lang-java">
@FunctionalInterface
interface EqualsInterface {
    boolean equals(Object obj);
}
    </pre>

    <p>Компілятор сповістить про помилку: <tt class="prettyprint lang-java">“EqualsInterface is not a functional interface: no abstract method found in interface EqualsInterface”</tt>. Оскільки метод <tt class="prettyprint lang-java">equals</tt> походить від <tt class="prettyprint lang-java">Object</tt>, цей інтерфейс не може розглядатися як функціональний.</p>
    
    <hr/>

    <h4>Пам'ятка</h4>

    <p>Про функціональні інтерфейси:</p>

    <ul>
        <li>Супроводжуйте функціональні інтерфейси анотацією <tt class="prettyprint lang-java">@FunctionalInterface</tt>. Без цього компілятор не повідомить про помилку при невірному визначенні функціонального інтерфейса (наприклад, якщо в ньому два абстрактних методи).</li>
        <li>Можна використовувати анотацію <tt class="prettyprint lang-java">@FunctionalInterface</tt> лише для інтерфейсів - не для класів, перелічень, тощо.</li>
        <li>Породжений інтерфейс може бути іункціональним, якщо він має лише один абстрактний метод, або спадкує лише один абстрактний метод.</li>
        <li>Для функціонального інтерфейса оголошення методів із класа <tt class="prettyprint lang-java">Object</tt> не враховується як абстрактні методи.</li>
    </ul>

    <h2>Лямбда функції</h2>

    <p>Одна з головних новинок в Java 8 - це лямбда функції. Фактично, це одне з найбільших нововведень з часів Java 1. Лямбди широко використовуються у світі мов програмування, включаючи ті, що компілюють для платформи Java. Наприклад, мова Groovy компілює для платформи Java та має дуже добру підтримку лямбда функцій (також відомих як замикання). Oracle вирішив привнести лямбди до основної мови для JVM &mdash; саме мови Java &mdash; в Java 8.</p>

    <hr/>

    <span style="text-transform:uppercase"><p>Зміни в Java 8, пов'язані з лямбда функціями</p></span>

    <p>Введення лямбд потребує зкоординованих змін в мові, бібліотеці та реалізації VM:</p>

    <ul>
        <li>Оператор стрілка (“<tt class="prettyprint lang-java">-&gt;</tt>”) для визначення лямбда функцій, оператор подвійної двокрапки (“<tt class="prettyprint lang-java">::</tt>”), який використовується для посилання на метод, та ключове слово <tt class="prettyprint lang-java">default</tt></li>
        <li>Бібліотека потоків та інтеграція бібліотеки колекцій з потоками</li>
        <li>Лямбда функції реалізовані з використанням інструкції <tt class="prettyprint lang-java">invokedynamic</tt>, запропонованої в Java 7</li>
    </ul>

    <p>Для підтримки введення лямбд в мову виведення типів також було покращено в Java 8. Лямбди дозволяють авторам бібліотек створювати паралельні алгоритми для використання наслідуваного паралелізму сучасного обладнання (наприклад, багатоядерність).</p>

    <p>В Java 8 <tt class="prettyprint lang-java">java.util</tt> був значно покращений з використанням лямбда функцій, про що йдеться в наступній главі (Глава 4). Java 8 отримала два нові пакети <tt class="prettyprint lang-java">java.util.function</tt> та <tt class="prettyprint lang-java">java.util.streams</tt>. Типи в <tt class="prettyprint lang-java">java.util.function</tt> обговорюватимуться в Главі 5, а <tt class="prettyprint lang-java">java.util.streams</tt> (відомому як Stream API, чи потоковий API) - в Главі 6.</p>

    <hr/>

    <p>Лямбди можуть значно змінити те, як пишеться код. <em>Лямбди підтримують парадигму функціонального програмування</em> &mdash; це означає, що вивчення та використання лямбд може здвинути вашу парадигму. Але непокоїтися через значний зсув парадигми не варто &mdash; Java легко інтегрує функціональні можливості з існуючими об'єктно-орієнтованими рисами, а використання все більшої кількості функціональних рис можна здійснювати поступово.</p>

    <p>В парадигмі функціонального програмування лямбда функції можуть зберігатися в змінних, передаватися як аргументи в інші функції, або повертатися від інших функцій так само, як примітивні типи чи посилальні змінні. Оскільки "лямбда функції" є частками коду, який може передаватися, можна говорити, що функціональна парадигма підтримує парадигму "код як дані". Можливість передавати "виконувані фрагменти коду" покращує виразну силу Java.</p>

    <h3>Лямбда функціі: синтаксис</h3>

    <p>Лямбда функція складається з опціональних параметрів, значка стрілки та тіла:</p>

    <pre class="prettyprint lang-java">
LambdaParameters -&gt; LambdaBody
    </pre>

    <ul>
        <li><tt class="prettyprint lang-java">LambdaParameters</tt> це параметри до лямбда функції, передаються без відкритих дужок "(" та закритих дужок ")". Декілька аргументів розділяються комою.</li>
        <li>Оператор стрілка. Для підтримки лямбд в Java представлено новий оператор "<tt class="prettyprint lang-java">-&gt;</tt>", також відомий як лямбда оператор чи оператор стрілка. Цей оператор стрілка необхідний для синтаксичного відокремлення параметрів від тіла.</li>
        <li><tt class="prettyprint lang-java">LambdaBody</tt> може бути виразом або блоком. Тіло може складатися з одного оператора (в такому випадку фігурні дужки не потрібні); таке лямбда тіло відоме як "вираз лямбда". Декілька операторів в тілі лямбда мають знаходитися в блоці коду (відомому як "блок лямбда")є</li>
    </ul>

    <p>Компілятор виконує виведення типу для лямбда виразів:</p>

    <ul>
        <li>Компілятор виводить тип аргументів в разі, якщо у визначенні лямбда функції не вказані типи параметрів. При указанні типів параметрів треба вказати їх для всіх параметрів, або не для одного - інакше виникне помилка компіляції.</li>
        <li>Можна пропустити дужки для одного параметра. Але тоді не можна буде явно вказати тип параметра - можна залишити компілятору вивести тип такого єдиного параметра.</li>
        <li>Тип, що повертається лямбда функцією, виводиться з тіла. Якщо будь-який фрагмент кода повертає знаення, треба гарантувати, що значення повертається поза залежністю від шляху виконання; інакше виникне помилка компіляції.</li>
    </ul>

    <p>Деякі приклади валідних лямбда виразів (в припущенні доступності відповідних функціональних інтеріфейсів):</p>

    <ul>
        <li><tt class="prettyprint lang-java">(int x) -&gt; x + x</tt></li>
        <li><tt class="prettyprint lang-java">x -&gt; x % x</tt></li>
        <li><tt class="prettyprint lang-java">() -&gt; 7</tt></li>
        <li><tt class="prettyprint lang-java">(int arg1, int arg2) -&gt; (arg1 + arg2) / (arg1 - arg2)</tt></li>
    </ul>

    <p>Приклади невалідних лямбда виразів:</p>

    <ul>
        <li><tt class="prettyprint lang-java">-&gt; 7<br/>// без параметрів треба надати порожні дужки ()</tt></li>
        <li><tt class="prettyprint lang-java">(arg1, int arg2) -&gt; arg1 / arg2<br/>// якщо задається тип параметра, треба це робити для всіх параметрів</tt></li>
    </ul>

    <h4>Лямбда функція &mdash; приклад</h4>

    <p>Почнемо з простого прикладу лямбда функції "hello world" (Лістинг <a href="#c03l11">3-11</a>).</p>

    <pre id="c03l11" class="prettyprint lang-java">
// Лістинг 3-11. FirstLambda.java
interface LambdaFunction {
    void call();
}
class FirstLambda {
    public static void main(String []args) {
        LambdaFunction lambdaFunction = () -&gt; System.out.println("Всем привет!");
        lambdaFunction.call();
    }
}
    </pre>

    <p>Програма надрукує</p>

    <pre>
Всем привет!
    </pre>

    <p>В цій програмі інтерфейс  <tt class="prettyprint lang-java">LambdaFunction</tt> оголошує абстрактний метод <tt class="prettyprint lang-java">call()</tt>; отже, цей інтерфейс є функціональним. Всередині метода <tt class="prettyprint lang-java">main</tt> класа <tt class="prettyprint lang-java">FirstLambda</tt> ляюмбда функція присвоюється змінній типу функціонального інтерфейса <tt class="prettyprint lang-java">LambdaFunction</tt>.</p>

    <pre class="prettyprint lang-java">
LambdaFunction lambdaFunction = () -&gt; System.out.println("Всем привет!");
    </pre>

    <p>Вираз <tt class="prettyprint lang-java">() -&gt; System.out.println("Всем привет!")</tt> є лямбда виразом:</p>

    <ul>
        <li>Синтаксис <tt class="prettyprint lang-java">()</tt> вказує на відсутність параметрів.</li>
        <li>Оператор стрілка "<tt class="prettyprint lang-java">-&gt;</tt>" відділяє параметри метода від лямбда тіла.</li>
        <li>Оператор <tt class="prettyprint lang-java">System.out.println("Всем привет!")</tt> є тілом лямбда виразу.</li>
    </ul>

    <p>Яким чином лямбда вираз відноситься до функціонального інтерфейса <tt class="prettyprint lang-java">LambdaFunction</tt>? Це відбувається через єдиний абстрактний метод всередині інтерфейса <tt class="prettyprint lang-java">LambdaFunction</tt>: <tt class="prettyprint lang-java">void call()</tt>. Сигнатури цього абстрактного метода та лямбда вираза повинні співпадати:</p>

    <ul>
        <li>Лямбда вираз має <tt class="prettyprint lang-java">()</tt>, що вказує на відустність параметрів &mdash; це співпадає з тим, що метод <tt class="prettyprint lang-java">call</tt> не приймає аргументів.</li>
        <li>Оператор <tt class="prettyprint lang-java">System.out.println("Всем привет!")</tt> є тілом лямбда виразу. Це тіло слугує в якості реалізації лямбда функції.</li>
        <li>Оператора <tt class="prettyprint lang-java">return</tt> немає в цьому тілі лямбда виразу, отже компілятор виводить тип цього виразу як тип <tt class="prettyprint lang-java">void</tt> &mdash; це співпадає з типом результату метода <tt class="prettyprint lang-java">call</tt>.</li>
    </ul>

    <p>Наступний оператор <tt class="prettyprint lang-java">lambdaFunction.call();</tt> викликає лямбда функцію. Результат цього виклику функції: в консолі друкується <tt class="prettyprint lang-bash">"Всем привет!"</tt>.</p>

    <p>Навіщо співпадіння типу лямбда функції і типу абстрактного метода в даному функціональному інтерфейсі? Для перевірки типів. Якщо типи не співпадають, виникне помилка компіляції:</p>

    <pre class="prettyprint lang-java">
LambdaFunction lambdaFunction = (<strong>int i</strong>) -&gt; System.out.println("Всем привет!");
    </pre>

    <p>Оскільки цей лямбда вираз має цілий аргумент, а метод <tt class="prettyprint lang-java">call()</tt> в <tt class="prettyprint lang-java">LambdaFunction</tt> не приймає аргументів, компілятор викличе помилку: <tt class="prettyprint lang-bash">“incompatible types: incompatible parameter types in lambda expression"</tt>.</p>

    <h5>Блоки лямбда</h5>

    <p>Блок лямбда це блок кода всередині "<tt class="prettyprint lang-java">{</tt>" та "<tt class="prettyprint lang-java">}</tt>":</p>

    <pre class="prettyprint lang-java">
LambdaFunction lambdaFunction = (int i) -&gt; { System.out.println("Всем привет!"); }
    </pre>

    <p>Блоки лямбда корисні при наданні декількох операторів в тілі лямбда (в виразі лямбда можна мати лише один оператор). Далі, в блоці лямбда можна надавати явно оператор <tt class="prettyprint lang-java">return</tt> (дивись Лістинг <a href="#c03l12">3-12</a>).</p>

    <pre id="c03l12" class="prettyprint lang-java">
// Лістинг 3-12. BlockLambda.java
class BlockLambda {
    interface LambdaFunction {
        String intKind(int a);
    }

    public static void main(String []args) {
        int a0 = Integer.parseInt(args[0]);
        LambdaFunction lambdaFunction =
                (int i) -&gt; {
            if((i % 2) == 0) return "парне";
            else return "непарне";
        };
        System.out.println(lambdaFunction.intKind(a0));
    }
}
    </pre>

    <p>В цьому коді визначений блок лямбда. З нього повертається <tt class="prettyprint lang-java">String</tt> та використовується явні оператори повернення результату.При визначенні блоків лямбда треба гарантувати, що такі оператори закінчують кожен з можливих шляхів виконання. Оператор повернення результату має співпадати з типом, який повертає абстрактний метод, визначений у відповідному функціональному інтерфейсі (в нашому випадку це <tt class="prettyprint lang-java">String</tt> для функції <tt class="prettyprint lang-java">intKind</tt> в інтерфейсі <tt class="prettyprint lang-java">LambdaFunction</tt>).</p>

    <h5>Анонімні внутрішні класи та лямбда вирази</h5>

    <p>До Java 8 програмісти на Java звикли писати анонімні внутрішні класи. Лістинг <a href="#c03l13">3-13</a> еквівалентний попередній програмі (Лістинг <a href="#c03l11">3-11</a>) за винятком того, що в ній використовується анонімний внутрішній клас замість лямбда функції.</p>

    <pre id="c03l13" class="prettyprint lang-java">
// Лістинг 3-13. AnonymousInnerClass.java
interface Function {
    void call();
}

class AnonymousInnerClass {
    public static void main(String []args) {
        Function function = new Function() {
            public void call() {
                System.out.println("Всем привет!");
            }
        };
        function.call();
    }
}
    </pre>

    <p>Функціональність така сама, як в Лістингу <a href="#c03l11">3-11</a> та Лістингу <a href="#c03l12">3-12</a>, але використання анонімного внутрішнього класу багатослівне у порівнянні з лаконічним лябда виразом.</p>

    <hr class="Note"/>
    <p>Один спосіб сприймати лямбди - думати про них я про "анонімні функції" чи "безіменні функції": вони - це функції без імені та вони не асоційовані з будь-яким класом. Зокрема, вони НЕ статичні, не члени екземпляра класа, в якому визначені. При використанні ключового слова <tt class="prettyprint lang-java">this</tt> всередині лямбда функції воно посилається на об'єкт в межах видимості, в якій визначена лямбда.</p>
    <hr/>

    <h5>Фактично фінальні змінні</h5>

    <p>Лямбда функції можуть посилатися на локальні змінні з оточуючої області видимості. Змінна повинна бути явно оголошена фінальною, або трактуватися як <em>фактично фінальна</em>. Фактична фінальність означає, що компілятор трактує змінну як фінальну змінну ті викличе помилку в разі спроби змінити її в лямбда функції чи в іншій частині функції. Така поведінка лямбд схожа на доступ до змінної у зовнішній області з локального та анонімного класів. Змінні, до яких вони мають доступ, теж трактуються як фактично фінальні (як обговорювалося раніше).</p>

    <p>В наступному прикладі до слова додається суфікс "іус" (так діти змінюють звичайні слова, щоби вони звучали смішно, як в грі "Pig Latin") - (Лістинг <a href="#c03l14">3-14</a>).</p>

    <pre id="c03l14" class="prettyprint lang-java">
// Лістинг 3-14. PigLatin.java
interface SuffixFunction {
    void call();
}

class PigLatin {
    public static void main(String []args) {
        String word = args[0];
        SuffixFunction suffixFunc = () -&gt; System.out.println(word + "іус");
        suffixFunc.call();
    }
}
    </pre>

    <p>В лямбда виразі використовується локальна змінна <tt class="prettyprint lang-java">word</tt>. Оскільки вона використовується в лямбда виразі, ця змінна має трактуватися як <tt class="prettyprint lang-java">final</tt> (хоча явно не оголошена як <tt class="prettyprint lang-java">final</tt>). Якщо спробувати цю програму з додатковим оператором, який призначає змінній <tt class="prettyprint lang-java">suffix</tt> (навіть перед викликом лямбда функції):</p>

    <pre class="prettyprint lang-java">
String word = "hello";
SuffixFunction suffixFunc = () -&gt; System.out.println(word + "ay");
word = "e";
suffixFunc.call();
    </pre>

    <p>то компілятор викличе помилку:</p>

    <pre class="prettyprint lang-bash">
PigLatin.java:11: error: local variables referenced from a lambda expression must be final or effectively final
SuffixFunction suffixFunc = () -&gt; System.out.println(word + "іус");
                                                             ^
1 error
    </pre>

    <p>Це відбувається тому, що суфікс додається до значення "e" після того, як ним ініціалізовано змінну, отже вона не може сприйматися як фінальна.</p>

    <p>Чому локальні змінні сприймаютсья як фактично фінальні при доступі до них з лямбда виразів? Причина в тому, що такі мутації не є безпечними для потоків.</p>

    <p>Це обмеження не стосується членів даних та членів класів. Тож можна опинитися в зоні ризику, коли змінні змінюються декіькома потоками одночасно у лямбда виразі. Крім того, фактична фінальність стосується лише посилань, а не значень, на які ці посилання вказують. Отже, в лямбда функції можна змінювати значення в локальному масиві - це не безпечно, але можливо.</p>

    <h4>Пам'ятка</h4>

    <p>Про лямбда функції:</p>

    <ul>
        <li>Лямбда вирази можуть зустрічатися лише в контексті, в якому може зустричатися призначення, виклик функції чи приведення типів (casts).</li>
        <li>Лямбда функція трактується як вкладений блок. Тому як і у вкладеному блоці в ній не можна оголосити змінну з іменем, яке зайняте в оточуючому блоці.</li>
        <li>Лямбда функції мають повертати значення з усіх гілок &mdash; інакше виникне помилка компіляції.</li>
        <li>При оголошенні типів параметрів лямбда стає "явно типізованою"; якщо типи виводяться - "неявно типізованою".</li>
        <li>Якщо лямбда викликає виняток, що перевіряється, тоді метод функціонального інтерфейса мусить оголошувати це; якщо виняток, який не перевіряється, виникне помилка компіляції.</li>
    </ul>

    <h2>Резюме</h2>

    <p>Коротко оглянемо ключові моменти для кожної з цілей глави.</p>

    <p><strong>Розробляти код з використанням абстрактних класів та методів</strong></p>

    <ul>
        <li>Абстракція вказує підтримувану функціональність без розкриття тонких деталей.</li>
        <li>Не можна створити екземпляр абстрактного класа.</li>
        <li>Абстрактні класи дозволяють поліморфізм часу виконання, який дозволяю пізнє зв'язування.</li>
    </ul>

    <p><strong>Розробляти код з використанням ключового слова final</strong></p>

    <ul>
        <li>Фінальний клас не дозволяє спадкування (тобто, не можна спадкувати від фінального класу).</li>
        <li>Фінальний метод не дозволяє перевизначення.</li>
        <li>Всі методи фінального класа неявно фінальні.</li>
        <li>Фінальна змінна може прийняти значення лише один раз.</li>
    </ul>

    <p><strong>Створювати внутрішні класи: статичний внутрішній клас, локальний клас, вкладений клас та анонімний внутрішній клас</strong></p>

    <ul>
        <li>Java підтримує чотири типи вкладених класів: статичні вкладені класи, внутрішні класи, локальні внутрішні класи и анонімні внутрішні класи.</li>
        <li>Статичні вкладені класи можуть мати статичні члени, інші - ні.</li>
        <li>Статичні вкладені класи та внутрішні класи мають доступ до членів зовнішнього класа (навіть приватних). Однак, статичні вкладені класи мають доступ лише до статичних членів зовнішніх класів.</li>
        <li>Локальні класи (як локальні внутрішні класи так і анонімні внутрішні класи) мають доступ до всіх змінних, оголошених в зовнішньому просторі (методі, конструкторі чи блоці операторів).</li>
    </ul>

    <p><strong>Використовувати типи перелічень з методами та конструкторами в типі enum</strong></p>

    <ul>
        <li>Перелічення типо-безпечний спосіб обмеження користувацького вводу.</li>
        <li>Оператор new не можна використовувати з переліченнями, навіть всередені визначення перелічення.</li>
        <li>Класи перелічень по замовчанню фінальні.</li>
        <li>Всі класи перелічень неявно породжені від <tt class="prettyprint lang-java">java.lang.Enum</tt>.</li>
    </ul>

    <p><strong>Розробляти код з оголошенням, реалізацією т/або розширенням інтерфейсів та використовувати анотацію atOverride</strong></p>

    <ul>
        <li>Інтерфейс може мати три типи методів: абстрактні методи, методи по замовчанню та статичні методи.</li>
        <li>Діамантова проблема трапляється при спадкуванні типом від різних базових типів двох методів з однаковими сигнатурами.</li>
        <ul>
            <li>Якщо два супер інтерфейси мають методи з однаковим ім'ям, та один з них має визначення, компілятор викличе помилку; такий конфлікт має бути врегульований вручну.</li>
            <li>Якщо базовий клас та базовий інтерфейс визначають методи з однаковими сигнатурами, використовується визначення метода в класі, а визначення інтерфейса ігнорується.</li>
        </ul>
        <li>Функціональний інтерфейс містить рівно один абстрактний метод, але може містити скільки завгодно методів по замовчанню або статичних методів.</li>
        <li>Оголошення функціонального інтерфейса приводить до "типу функціонального інтерфейса", який можна використовувати з лямбда виразами.</li>
        <li>Для функціонального інтерфейса оголошення в інтерфейсі методів з класу Object не враховуються як абстрактні методи.</li>
    </ul>

    <p><strong>Створювати та використовувати лямбда вирази</strong></p>

    <ul>
        <li>В лямбда виразі ліва частина <tt class="prettyprint lang-java">-&gt;</tt> надає аргументи, а права - тіло. Оператор стрілка (“<tt class="prettyprint lang-java">-&gt;</tt>”) допомагає у вираженні виразів лямбда функцій.</li>
        <li>Можна створити посилання на функціональний інтерфейс та призначити йому лямбда вираз. При виклику абстрактного метода того інтерфейса буде викликаний призначений лямбда вираз.</li>
        <li>Компілятор може виконувати виведення типів лямбда параметрів в разі, якщо вони не типізовані. При оголошенні параметри можуть мати такі модифікатори, як <tt class="prettyprint lang-java">final</tt>.</li>
        <li>Змінні, до який має доступ лямбда функція, трактуються як <em>фактично фінальні</em>.</li>
    </ul>


    <h1>Лекція 4</h1>
    <h1>Узагальнення та Колекції</h1>
    <p>Розглянуті питання:
	    <ul>
	        <li>Створення та використання узагальненого класу</li>
	        <li>Створення та використання об'єктів <tt class="prettyprint lang-java">ArrayList</tt>, <tt class="prettyprint lang-java">TreeSet</tt>, <tt class="prettyprint lang-java">TreeMap</tt> та <tt class="prettyprint lang-java">ArrayDeque</tt></li>
	        <li>Використання інтерфейсів <tt class="prettyprint lang-java">java.util.Comparator</tt> та <tt class="prettyprint lang-java">java.lang.Comparable</tt></li>
	        <li>Потоки та фільтри колекцій</li>
	        <li>Ітеративне використання методів <tt class="prettyprint lang-java">forEach</tt> класів <tt class="prettyprint lang-java">Streams</tt> та <tt class="prettyprint lang-java">List</tt></li>
	        <li>Опис інтерфейсу <tt class="prettyprint lang-java">Stream</tt> та використання <tt class="prettyprint lang-java">Stream</tt></li>
	        <li>Фільтрація колекції з використанням виразів лямбда</li>
	        <li>Використання посилань на методи з потоками</li>
	    </ul>
    </p>
    <p>Кожен нетривіальний додаток Java використовує структури даних та алгоритми. Середовице колекцій Java пропонує великий набір готових до використання структур даних та алгоритмів загального призначення. Ці структури даних та алгоритми можуть використовуватися з будь-яким типом даних у безпечний спосіб; це можливе через використання такої властивості мови як узагальнення (generics).</p>

    <p>Колекції в Java реалізують структури даних та алгоритми, які релізовані з використанням узагальнень та лямбда функцій. Отже, в розкладі екзамену 1Z0-809 ці дві теми об'єднані в одну. В цій главі ми почнемо з обговорення узагальнень. Оскільки наш досвід свідчить про те, що надати вірні відповіді про узагальнення доволі складно, ми розглянемо узагальнення доволі детально. Потім ми обговоримо важливі колекції, та інтерфейси <tt class="prettyprint lang-java">java.lang.Comparator</tt> і <tt class="prettyprint lang-java">java.lang.Comparable</tt>. Наприкінці детально розглянемо лямбда функції та потоки, які можна використовувати з колекціями Java. Під час екзамену OCPJP 8 слід очікувати багато питань про узагальнення, колекції та потоки, тож ця глава пропонує детальний опис цих тем.</p>

    <p><em>Узагальнення (Generics)</em> це властивість мови, яка була представлена в версії Java 1.5. Перед введенням узагальнень в якості альтернативи в Java використовувався базовий клас <tt class="prettyprint lang-java">Object</tt>. З узагальненнями ви пишете код для одного типу (наприклад, <tt class="prettyprint lang-java">T</tt>) таким чином, що він може бути застосований для всіх типів, замість того, щоб створювати майже однакові класи для кожного з типів. Почнемо з простого прикладу.</p>

    <p>Припустимо, що існує потреба друкувати значення об'єкта в квадратних дужках. Наприклад, при друкуванні об'єкта <tt class="prettyprint lang-java">Integer</tt> із значенням <tt class="prettyprint lang-java">10</tt> замість друкування в консолі "<tt class="prettyprint lang-java">10</tt>", нам треба надрукувати значення всередині "коробки" ось так: "<tt class="prettyprint lang-java">[10]</tt>". <a href="#c04l01">Лістинг 4-1</a> містить узагальнену версію класа <tt class="prettyprint lang-java">BoxPrinter</tt>.</p>

    <pre id="c04l01" class="prettyprint lang-java">
    // Лістинг 4-1. BoxPrinterTest.java
    class BoxPrinter&lt;T&gt; {
        private T val;
        public BoxPrinter(T arg) {
            val = arg;
        }
        public String toString() {
            return "[" + val + "]";
        }
    }

    class BoxPrinterTest {
        public static void main(String []args) {
            BoxPrinter&lt;Integer&gt; value1 = new BoxPrinter&lt;Integer&gt;(Integer.valueOf(10));
            System.out.println(value1);

            BoxPrinter&lt;String&gt; value2 = new BoxPrinter&lt;String&gt;("Всім привіт!");
            System.out.println(value2);
        }
    }
    </pre>

    <p>Програма надрукує:</p>
    <pre>
    [10]
    [Всім привіт!]
    </pre>

    <p>Треба звернути увагу на багато речей.</p>

    <p>1. Оголошення <tt class="prettyprint lang-java">BoxPrinter</tt>:</p>

    <pre class="prettyprint lang-java">
    class BoxPrinter&lt;T&gt;
    </pre>

    <p>Ми надаємо класу <tt class="prettyprint lang-java">BoxPrinter</tt> <em>наповнювач типу</em> <tt class="prettyprint lang-java">&lt;T&gt;</tt> &ndash; ім'я типу <tt class="prettyprint lang-java">T</tt> всередині кутових дужок "<tt class="prettyprint lang-java">&lt;</tt>" та "<tt class="prettyprint lang-java">&gt;</tt>" одразу після імені класу. Це ім'я типу можна використовувати всередині класу для демонстрації того, що це наповнювач типу для дійсного типу, який буде наданий пізніше.</p>

    <p>2. Всередині класу <tt class="prettyprint lang-java">T</tt> вперше використовується при оголошенні поля:</p>

    <pre class="prettyprint lang-java">
    private T val;
    </pre>

    <p> <em>val</em> оголошується як <em>змінна узагальненого типу</em>  &ndash; дійсний тип буде вказано пізніше при використанні <tt class="prettyprint lang-java">BoxPrinter</tt>. В <tt class="prettyprint lang-java">main()</tt> оголошується змінна типу <tt class="prettyprint lang-java">BoxPrinter</tt> для <tt class="prettyprint lang-java">Integer</tt>:</p>

    <pre class="prettyprint lang-java">
    BoxPrinter&lt;Integer&gt; value1
    </pre>

    <p>Тут вказується, що <tt class="prettyprint lang-java">T</tt> є типом <tt class="prettyprint lang-java">Integer</tt> &ndash; ідентифікатор <tt class="prettyprint lang-java">T</tt> (наповнювач) замінюється типом <tt class="prettyprint lang-java">Integer</tt>. Отже, <tt class="prettyprint lang-java">val</tt> всередині <tt class="prettyprint lang-java">BoxPrinter</tt> стає <tt class="prettyprint lang-java">Integer</tt> тому що <tt class="prettyprint lang-java">T</tt> намінюється на <tt class="prettyprint lang-java">Integer</tt>.</p>

    <p>3. Ще одне місце використання <tt class="prettyprint lang-java">T</tt>:</p>

    <pre class="prettyprint lang-java">
    public BoxPrinter(T arg) {
    	val = arg;
    }
    </pre>

    <p>Як і з оголошенням <tt class="prettyprint lang-java">val</tt> типу <tt class="prettyprint lang-java">T</tt>, вказується, що аргумент для конструктора <tt class="prettyprint lang-java">BoxPrinter</tt> належить типу <tt class="prettyprint lang-java">T</tt>. Пізніше в методі <tt class="prettyprint lang-java">main()</tt> при виклику конструктора з <tt class="prettyprint lang-java">new</tt> вказується, що <tt class="prettyprint lang-java">T</tt> є типом <tt class="prettyprint lang-java">Integer</tt>:</p>

    <pre class="prettyprint lang-java">
    new BoxPrinter&lt;Integer&gt;(Integer.valueOf(10));
    </pre>

    <p>Тепер в конструкторі <tt class="prettyprint lang-java">BoxPrinter</tt> <tt class="prettyprint lang-java">arg</tt> та <tt class="prettyprint lang-java">val</tt> повинні належати до одного типу, оскільки оголошені як <tt class="prettyprint lang-java">T</tt>. Наприклад при зміні конструктора наступним чином:</p>

    <pre class="prettyprint lang-java">
    new BoxPrinter&lt;String&gt;(Integer.valueOf(10));
    </pre>

    <p><tt class="prettyprint lang-java">BoxPrinter</tt> є типом <tt class="prettyprint lang-java">String</tt>, а аргумент передається типу <tt class="prettyprint lang-java">Integer</tt>, тож компілятор сповістить про неспівдпадіння типів при використання узагальнення (і це добре, бо проблему виявлено рано).</p>

    <p>Розглянемо інший приклад. Тут узагальнений клас <tt class="prettyprint lang-java">Pair</tt>, який містить об'єкти двох різних типів <tt class="prettyprint lang-java">T1</tt> та <tt class="prettyprint lang-java">T2</tt> (<a href="#c04l02">Лістинг 4-2</a>).</p>

    <pre id="c04l02" class="prettyprint lang-java">
    // Лістинг 4-2. PairTest.java
    class Pair&lt;T1, T2&gt; {
        T1 object1;
        T2 object2;
        Pair(T1 one, T2 two) {
            object1 = one;
            object2 = two;
        }
        public T1 getFirst() {
            return object1;
        }
        public T2 getSecond() {
            return object2;
        }
    }

    class PairTest {
        public static void main(String []args) {
            Pair&lt;Integer, String&gt; worldCup = new Pair&lt;Integer, String&gt;(2018, "Росія");
            System.out.println("Місце проведення чемпіоната світу з футболу в " + worldCup.getFirst() +
                " році: " + worldCup.getSecond());
        }
    }
    </pre>

    <p>Ця програма надрукує наступне:</p>

    <pre>
    Місце проведення чемпіоната світу з футболу в 2018 році: Росія
    </pre>

    <p>Тут <tt class="prettyprint lang-java">T1</tt> та <tt class="prettyprint lang-java">T2</tt> наповнювачі типів. Вони вказуються всередині кутових дужок: <tt class="prettyprint lang-java">&lt;T1, T2&gt;</tt>. При використання класу <tt class="prettyprint lang-java">Pair</tt> треба указати, які певні типи мають використовуватися замість <tt class="prettyprint lang-java">T1</tt> та <tt class="prettyprint lang-java">T2</tt>. Наприклад, в методі <tt class="prettyprint lang-java">main()</tt> використовуються <tt class="prettyprint lang-java">Integer</tt> та <tt class="prettyprint lang-java">String</tt> для <tt class="prettyprint lang-java">Pair</tt>: <tt class="prettyprint lang-java">Pair&lt;Integer, String&gt;</tt>. Тепер поглянемо на клас <tt class="prettyprint lang-java">Pair</tt> якби він мав таке тіло:</p>

    <pre class="prettyprint lang-java">
    // як можна трактувати Pair&lt;Integer, String&gt;
    class Pair {
    	Integer object1;
    	String object2;
    	Pair(Integer one, String two) {
    		object1 = one;
    		object2 = two;
    	}

    	public Integer getFirst() {
    		return object1;
    	}

    	public String getSecond() {
    		return object2;
    	}
    }
    </pre>

    <p>Іншими словами, спробуйте руками замінити в коді наповнювачі типів дійсними типами. Це допоможе зрозуміти, як насправді працюють узагальнення. Так можна побачити, як методи <tt class="prettyprint lang-java">getFirst()</tt> та <tt class="prettyprint lang-java">getSecond()</tt> в методі <tt class="prettyprint lang-java">main()</tt> повертають значення <tt class="prettyprint lang-java">Integer</tt> та <tt class="prettyprint lang-java">String</tt>.</p>

    <p>В операторі</p>

    <pre class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair&lt;Integer, String&gt;(2018, "Росія");
    </pre>

    <p>зауважте точне співпадіння типів. Якщо спробувати</p>

    <pre class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair&lt;String, String&gt;(2018, "Росія");
    </pre>

    <p>виникне помилка компіляції:</p>

    <pre>
    TestPair.java:20: cannot find symbol
    symbol  : constructor Pair(int,java.lang.String)
    location: class Pair&lt;java.lang.String,java.lang.String&gt;
    </pre>

    <p>Розглянемо наступний оператор.</p>

    <pre class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair&lt;Number, String&gt;(2018, "Росія");
    </pre>

    <p>Виникне інша помилка компіляції з-за того, що не співпадають типи: вказаний в оголошенні <tt class="prettyprint lang-java">worldCup</tt> та наданий у виразі ініціалізації:</p>

    <pre>
    TestPair.java:20: incompatible types
    found   : Pair&lt;java.lang.Number,java.lang.String&gt;
    required: Pair&lt;java.lang.Integer,java.lang.String&gt;
    </pre>

    <p>Модифікуємо узагальнений клас <tt class="prettyprint lang-java">Pair</tt>. <tt class="prettyprint lang-java">Pair&lt;T1, T2&gt;</tt> зберігає об'єкти типів <tt class="prettyprint lang-java">T1</tt> та <tt class="prettyprint lang-java">T2</tt>. Завдамося метою створити узагальнений парний клас, який приймає тип <tt class="prettyprint lang-java">T</tt> та зберігає два об'єкти цього типу <tt class="prettyprint lang-java">T</tt>. Очевидно, один спосіб зробити це &ndash; створити <tt class="prettyprint lang-java">Pair&lt;T1, T2&gt;</tt> с одним типом, скажімо <tt class="prettyprint lang-java">Pair&lt;String, String&gt;</tt>, але це погане рішення. Чому? Не існує шляху гарантувати створення <tt class="prettyprint lang-java">Pair</tt> з однаковими типами! <a href="#c04l03">Лістинг 4-3</a> це модифікована версія <tt class="prettyprint lang-java">Pair</tt> &ndash; назвемо її <tt class="prettyprint lang-java">PairOfT</tt>, &ndash; яка приймає наповнювачі одного типу <tt class="prettyprint lang-java">T</tt>.</p>

    <pre id="c04l03" class="prettyprint lang-java">
    // Лістинг 4-3. PairOfT.java
    class PairOfT&lt;T&gt; {
        T object1;
        T object2;
        PairOfT(T one, T two) {
            object1 = one;
            object2 = two;
        }
        public T getFirst() {
            return object1;
        }
        public T getSecond() {
            return object2;
        }
    }
    </pre>

    <p>Чи працюватиме наступний оператор?</p>

    <pre class="prettyprint lang-java">
    PairOfT&lt;Integer, String&gt; worldCup = new PairOfT&lt;Integer, String&gt;(2018, "Росія");
    </pre>

    <p>Ні, тому що <tt class="prettyprint lang-java">PairOfT</tt> приймає параметр одного типу, а тут передаються параметри двох типів. Тож, виникне помилка компіляції. А що з наступним оператором?</p>

    <pre class="prettyprint lang-java">
    PairOfT&lt;String&gt; worldCup = new PairOfT&lt;String&gt;(2018, "Росія");
    </pre>

    <p>Також матиме місце помилка компіляції:</p>

    <pre>
    TestPair.java:20: cannot find symbol
    symbol : constructor PairOfT(int,java.lang.String)
    	location: class PairOfT&lt;java.lang.String&gt;
    PairOfT&lt;String&gt; worldCup = new PairOfT&lt;String&gt;(2018, "Росія");
    </pre>

    <p>Причина полягає в тому, що 2018 &ndash; при огортанні в клас &ndash; стає <tt class="prettyprint lang-java">Integer</tt>, а очікується <tt class="prettyprint lang-java">String</tt>. Що з цим оператором?</p>

    <pre class="prettyprint lang-java">
    PairOfT&lt;String&gt; worldCup = new PairOfT&lt;String&gt;("2018", "Росія");
    </pre>

    <p>А ось це вже скомпілюється та працюватиме.</p>

    <h3><a name="D0.94.D1.96.D0.B0.D0.BC.D0.B0.D0.BD.D1.82.D0.BE.D0.B2.D0.B8.D0.B9_.D1.81.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81">Діамантовий синтаксис</a></h3>

    <p>В попередньому розділі обговорювалося створення екземплярів узагальненого типу, як в наступному операторі:</p>

    <pre id="c04s017" class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair&lt;Integer, String&gt;(2018, "Росія");
    </pre>

    <p>Також обговорювалася помилка компілятора при невідповідності цих типів, як в наступному операторі, який не можна скомпілювати:</p>

    <pre id="c04s018" class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair&lt;String, String&gt;(2018, "Росія");</pre>

    <p>Забезпечувати надання параметрів одного типу при оголошенні (<tt class="prettyprint lang-java">Pair&lt;Integer, String&gt;</tt> в даному випадку) та у виразі створення нового об'єкту (<tt class="prettyprint lang-java">new Pair&lt;String,
    String&gt;()</tt> в даному випадку) може стати втомливим заняттям.</p>

    <p>Для спрощення життя в Java 1.7 було запропоновано діамантовий синтаксис, в якому параметри типів можуть бути опущені: типи визначить компілятор з оголошення типу. Отже оголошення може бути спрощене:</p>

    <pre id="c04s019" class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair&lt;&gt;(2018, "Росія");
    </pre>

    <p><a href="#c04l04">Лістинг 4-4</a> містить цілу програму, в якій використовується діамантовий синтаксис.</p>

    <pre id="c04l04">
    // Лістинг 4-4. TestPair.java
    class Pair&lt;T1, T2&gt; {
        T1 object1;
        T2 object2;
        Pair(T1 one, T2 two) {
            object1 = one;
            object2 = two;
        }
        public T1 getFirst() {
            return object1;
        }
        public T2 getSecond() {
            return object2;
        }
    }

    class TestPair {
        public static void main(String []args) {
            Pair&lt;Integer, String&gt; worldCup = new Pair&lt;&gt;(2018, "Росія");
            System.out.println("Місце проведення чемпіоната світу з футболу в " + worldCup.getFirst() +
                " році: " + worldCup.getSecond());
        }
    }
    </pre>

    <p>Ця програма успішно компілюється та друкує:</p>

    <pre>
    Місце проведення чемпіоната світу з футболу в 2018 році: Росія
    </pre>

    <p>Зауважте на поширену помилку: діамантовий оператор <tt class="prettyprint lang-java">&lt;&nbsp;&gt;</tt> часто забувають у виразах ініціалізації:</p>

    <pre id="c04s020" class="prettyprint lang-java">
    Pair&lt;Integer, String&gt; worldCup = new Pair(2018, "Росії");
    </pre>

    <p>Компілятор надасть попередження (при наданні до <tt class="prettyprint lang-java">javac</tt> опції командного рядку <tt class="prettyprint lang-java">-Xlint:unchecked</tt>):</p>

    <pre id="c04s021">
    Pair.java:19: warning: [unchecked] unchecked call to Pair(T1,T2) as a member of the raw type Pair
    Pair&lt;Integer, String&gt; worldCup = new Pair(2018, "Росії");
                                     ^
    where T1,T2 are type-variables:
      T1 розширює Object declared in class Pair
      T2 розширює Object declared in class Pair

    Pair.java:19: warning: [unchecked] unchecked conversion
    Pair&lt;Integer, String&gt; worldCup = new Pair(2018, "Росії");
                                     ^
      required: Pair&lt;Integer,String&gt;
      found:    Pair
    2 warnings
    </pre>

    <p>Оскільки <tt class="prettyprint lang-java">Pair</tt> це узагальнений тип та коли забувають використовувати <tt class="prettyprint lang-java">&lt;&nbsp;&gt;</tt> чи явно надати параметри типів, компілятор трактує це як необроблений тип (raw type), що передаються до <tt class="prettyprint lang-java">Pair</tt> як два параметри типу <tt class="prettyprint lang-java">Object</tt>. Хоча така поведінка не викликає проблем в даному конкретному фрагменті коду, вона вважається небезпечною та може привести до помилок, як продемонстровано в наступному розділі.</p>

    <h3><a name="D0.92.D0.B7.D0.B0.D1.94.D0.BC.D0.BD.D0.B0_.D1.80.D0.BE.D0.B1.D0.BE.D1.82.D0.B0_.D0.B7_.D0.BD.D0.B5.D0.BE.D0.B1.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BD.D0.B8.D0.BC.D0.B8_.D1.82.D0.B8.D0.BF.D0.B0.D0.BC.D0.B8_.D1.82.D0.B0_.D1.83.D0.B7.D0.B0.D0.B3.D0.B0.D0.BB.D1.8C.D0.BD.D0.B5.D0.BD.D0.B8.D0.BC.D0.B8_.D1.82.D0.B8.D0.BF.D0.B0.D0.BC.D0.B8">Взаємна робота з необробленими типами та узагальненими типами</a></h3>

    <p>Узагальнений тип може використовуватися без указання його асоційованого типу. В такому випадку тип назівається необробленим (<em>raw type</em>). Наприклад, <tt class="prettyprint lang-java">List&lt;T&gt;</tt> має використовуватися з асоційованим типом, таким як <tt class="prettyprint lang-java">List&lt;String&gt;</tt>; однак, він може використовуватися без указання супутнього типу: <tt class="prettyprint lang-java">List</tt>. В останньому випадку <tt class="prettyprint lang-java">List</tt> називається необробленим типом.</p>

    <p>При використанні необробленого типу втрачається перевага безпеки типів, яку надають узагальнення. Наприклад, тип <tt class="prettyprint lang-java">Vector</tt> це необроблений тип. Необроблені типи уникають перевірки типів під час копіляції; однак, вони можуть викликати виняткові ситуації під час виконання (наприклад, <tt class="prettyprint lang-java">ClassCastException</tt>). Отже, не рекомендується використовувати в коді необроблені типи.</p>

    <p>Добре, тепер зрозуміло, що необроблені типи використовувати не треба. Але виникає питання, чому сам компілятор не викликає помилок при таких оголошеннях типів? Відповідь це <em>зворотня сумісність</em>. Узагальнення Java були представлені в Java 1.5. Java супроводжує необроблені типи для забезпечення сумісності коду з використанням узагальнень та успадкованого коду. Однак, настійно рекомендується не використовувати в коді необроблені типи.</p>

    <p>Чому? Що трапиться при використанні необроблених типів з узагальненями? Давайте використаємо обидва типи в <a href="#c04l05">Лістингу 4-5</a> та подивимось на ефект.</p>

    <pre id="c04l05" class="prettyprint lang-java">
    // Лістинг 4-5. RawTest1.java
    import java.util.List;
    import java.util.LinkedList;
    import java.util.Iterator;

    class RawTest1 {
        public static void main(String []args) {
            List list = new LinkedList();
            list.add("Перший");
            list.add("Другий");
            List&lt;String&gt; strList = list; //#1
            for(Iterator&lt;String&gt; itemItr = strList.iterator(); itemItr.hasNext();)
                System.out.println("Елемент: " + itemItr.next());

            List&lt;String&gt; strList2 = new LinkedList&lt;&gt;();
            strList2.add("Перший");
            strList2.add("Другий");
            List list2 = strList2; //#2
            for(Iterator&lt;String&gt; itemItr = list2.iterator(); itemItr.hasNext();)
                System.out.println("Елемент: " + itemItr.next());
        }
    }
    </pre>

    <p>Ця програма компілюється (з попередженнями) та виконується без проблем. Вона друкує наступне:</p>

    <pre>
    Елемент: Перший
    Елемент: Другий
    Елемент: Перший
    Елемент: Другий
    </pre>

    <p><a href="#c04l06">Лістинг 4-6</a> вводить деякі зміни; дивимось на вивід.</p>

    <pre id="c04l06" class="prettyprint lang-java">
    // Лістинг 4-6. RawTest2.java
    import java.util.List;
    import java.util.LinkedList;
    import java.util.Iterator;

    class RawTest2 {
        public static void main(String []args) {
            List list = new LinkedList();
            list.add("Перший");
            list.add("Другий");
            List&lt;String&gt; strList = list;
            strList.add(10); // #1: Помилка компілятора
            for(Iterator&lt;String&gt; itemItr = strList.iterator(); itemItr.hasNext();)
                System.out.println("Елемент : " + itemItr.next());

            List&lt;String&gt; strList2 = new LinkedList&lt;&gt;();
            strList2.add("Перший");
            strList2.add("Другий");
            List list2 = strList2;
            list2.add(10); // #2: Помилка часу виконання
            for(Iterator&lt;String&gt; itemItr = list2.iterator(); itemItr.hasNext();)
                System.out.println("Елемент : " + itemItr.next());
        }
    }
    </pre>

    <p>В цьому прикладі ми додали два оператори. Перший:</p>

    <pre class="prettyprint lang-java">
    	strList.add(10);	// #1: Помилка компілятора
    </pre>

    <p>Виконується спроба додати цілий елемент до списку <tt class="prettyprint lang-java">List&lt;String&gt;</tt>, тож компілятор сповіщаєє про помилку <tt class="prettyprint lang-java">"no suitable method found for add(int)"</tt>. Як говорилося раніше, такий тип перевірки на рівні компілятора корисний, бо інакше виникала б помилка при виконанні. Другий доданий оператор:</p>

    <pre class="prettyprint lang-java">
    	list2.add(10);	// #2: Помилка часу виконання
    </pre>

    <p>Тут пов'язаний список <tt class="prettyprint lang-java">list2</tt> (необроблений тип) ініціалізується узагальненим типом <tt class="prettyprint lang-java">List&lt;String&gt;</tt>. Після ініціалізації до списку необробленого типу додається ціле. Це припустимо, оскільки <tt class="prettyprint lang-java">list2</tt> є необробленим типом. Однак це призводить до <tt class="prettyprint lang-java">ClassCastException</tt>.</p>

    <p>Цей приклад вчить уникати змішення необроблених типів та узагальнених типів в програмах, оскільки це може призвести до помилкової поведінки під час виконання. Якщо все ж таки в програмі потрібні обидва типи, впевніться в тому, що до контейнерів додаються та отримуються з них елементи одного типу.</p>

    <hr/>
    <p>Уникайте змішення необроблених типів з узагальненими типами.</p>
    <hr/>

    <h3><a name="D0.A3.D0.B7.D0.B0.D0.B3.D0.B0.D0.BB.D1.8C.D0.BD.D0.B5.D0.BD.D1.96_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.B8">Узагальнені методи</a></h3>

    <p>На рівні з узагальненими класами можна створювати узагальнені методи &ndash; тобто методи, які приймають параметри узагальнених типів. Узагальнені методи корисні при написанні методів, які можна застосовувати до широкого діапазону типів при збереженні функціональності. Наприклад, в класі <tt class="prettyprint lang-java">java.util.Collections</tt> існує багато узагальнених методів.</p>

    <p>Реалізуємо простий метод <tt class="prettyprint lang-java">fill()</tt>. Приймаючи контейнер, метод <tt class="prettyprint lang-java">fill()</tt> встановлює всі його елементи в значення <tt class="prettyprint lang-java">val</tt>. <a href="#c04l07">Лістинг 4-7</a> містить реалізацію методу <tt class="prettyprint lang-java">fill()</tt> в класі <tt class="prettyprint lang-java">Utilities</tt>.</p>

    <pre id="c04l07" class="prettyprint lang-java">
    // Лістинг 4-7. UtilitiesTest.java
    import java.util.List;
    import java.util.ArrayList;

    class Utilities {
        public static &lt;T&gt; void fill(List&lt;T&gt; list, T val) {
            for(int i = 0; i &lt; list.size(); i++)
                list.set(i, val);
        }
    }

    class UtilitiesTest {
        public static void main(String []args) {
            List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
            intList.add(10);
            intList.add(20);
            System.out.println("Початковий список: " + intList);
            Utilities.fill(intList, 100);
            System.out.println("Список після виклику Utilities.fill(): " + intList);
        }
    }
    </pre>

    <p>Друкує наступне:</p>

    <pre>
    	Початковий список: [10, 20]
    	Список після виклику Utilities.fill(): [100, 100]
    </pre>

    <p>Детальніше розглянемо цей код:</p>

    <p>1. Метод <tt class="prettyprint lang-java">fill()</tt> в класі <tt class="prettyprint lang-java">Utilities</tt> створюється з наступним оголошенням:</p>

    <pre id="c04s022" class="prettyprint lang-java">
    public static &lt;T&gt; void fill(List&lt;T&gt; list, T val)
    </pre>

    <p>В цьому методі оголошується параметр узагальненого типу <tt class="prettyprint lang-java">T</tt>. Після кваліфікаторів <tt class="prettyprint lang-java">public</tt> та <tt class="prettyprint lang-java">static</tt> вказується <tt class="prettyprint lang-java">&lt;T&gt;</tt>, потім тип, що повертається, ім'я методу та його параметри. Це оголошення відрізняється від узагальнених класів &ndash; в них параметри узагальнених типів надаються після імені класу.</p>

    <p>2. В тілі код такий, як і в звичайному методі.</p>

    <pre id="c04s023" class="prettyprint lang-java">
    for(int i = 0; i &lt; list.size(); i++)
        list.set(i, val);
    </pre>

    <p>Цикл по списку від 0 до його розміру, встановлення кожного з елементів в значення <tt class="prettyprint lang-java">val</tt> в кожній ітерації. Можна використовувати метод <tt class="prettyprint lang-java">set()</tt> в <tt class="prettyprint lang-java">List</tt>, який приймає індекс позиції в контейнері як перший аргумент та значення, яке треба призначити, як другий аргумент.</p>

    <p>3. В методі <tt class="prettyprint lang-java">main()</tt> класа <tt class="prettyprint lang-java">UtilitiesTest</tt> викликається метод <tt class="prettyprint lang-java">fill()</tt>:</p>

    <pre class="prettyprint lang-java">
    Utilities.fill(intList, 100);
    </pre>

    <p>Зауважте, що значення параметра узагальненого типу не надається явно. Оскільки <tt class="prettyprint lang-java">intList</tt> це тип <tt class="prettyprint lang-java">Integer</tt> та <tt class="prettyprint lang-java">100</tt> пакується до типу <tt class="prettyprint lang-java">Integer</tt>, компілятор визначає, що тип <tt class="prettyprint lang-java">T</tt> в методі <tt class="prettyprint lang-java">fill()</tt> є типом <tt class="prettyprint lang-java">Integer</tt>.</p>

    <h3><a name="D0.A3.D0.B7.D0.B0.D0.B3.D0.B0.D0.BB.D1.8C.D0.BD.D0.B5.D0.BD.D0.BD.D1.8F_.D1.82.D0.B0_.D0.BF.D1.80.D0.B8.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.BD.D1.8F_.D0.BF.D1.96.D0.B4-.D1.82.D0.B8.D0.BF.D1.96.D0.B2">Узагальнення та приведення під-типів</a></h3>

    <p>Об'єкт породженого типу можна призначити посиланню на його базовий тип; це відомо як <em>приведення під-типів</em>. Однак для узагальнень параметри типів мають точно співпадати, інакше виникне помилка компіляції. Іншими словами, <em>приведення під-типів не працює для узагальнених параметрів</em>. Це правило складно запам'ятати, тож детально розглянемо, чому для параметрів узагальнених типів не працює приведення під-типів.</p>

    <hr/>
    <p>Приведення під-типів працює для типів класів: можна призначити об'єкт породженого типу посиланню на його базовий клас. Однак, приведення під-типів не працює для параметрів узагальнених типів: не можна призначити параметр породженого узагальненого типу параметру базового типу.</p>
    <hr/>

    <p>Подивимось, що піде не так, якщо припустити можливість приведення під-типів для параметрів узагальненого типу.</p>

    <pre id="c04s024" class="prettyprint lang-java">
    // неприпустимий код &ndash; вважатимемо, що наступна ініціалізація припустима
    List&lt;Number&gt; intList = new ArrayList&lt;Integer&gt;();
    intList.add(new Integer(10)); // все добре
    intList.add(new Float(10.0f)); // щось не так
    </pre>

    <p><tt class="prettyprint lang-java">intList</tt> типу <tt class="prettyprint lang-java">List&lt;Number&gt;</tt> призначений для збереження об'єкту <tt class="prettyprint lang-java">ArrayList&lt;Number&gt;</tt>. Проте, зберігається <tt class="prettyprint lang-java">ArrayList&lt;Integer&gt;</tt>. Це нібито має сенс оскільки <tt class="prettyprint lang-java">List</tt> розширює <tt class="prettyprint lang-java">ArrayList</tt>, а <tt class="prettyprint lang-java">Integer</tt> розширює <tt class="prettyprint lang-java">Number</tt>. Однак, закінчується додаванням значення <tt class="prettyprint lang-java">Float</tt> до <tt class="prettyprint lang-java">intList</tt>! Пригадайте, що динамічний тип для <tt class="prettyprint lang-java">intList</tt> це тип <tt class="prettyprint lang-java">ArrayList&lt;Integer&gt;</tt> &ndash; тобто тут порушується безпечність типів (тож матимо помилку компіляції стосовно несумісності типів). Оскільки узагальнення спроектовані для запобігання подібних помилок безпеки типів, не можна призначати параметр породженого узагальненого типу параметру базового типу.</p>

    <p>Як видно, приведення під-типів для узагальнених типів параметрів неприпустиме з-за його небезпечності &ndash; але це не робить це обмеження більш зручним. На щастя, Java підтримує маскові типи параметра, для яких припустиме приведення під-типів. Розлянемо цю можливість.</p>

    <hr/>
    <p>Параметри типу для узагальнень мають обмеження: загальні типи параметру мають точно відповідати призначенням. Для вирішення цієї проблеми приведення під-типів можна використовувати маскові (підстановочні) типи.</p>
    <hr/>

    <h3><a name="D0.9F.D1.96.D0.B4.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BE.D1.87.D0.BD.D1.96_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8">Підстановочні параметри</a></h3>

    <p>В попередньому розділі було продемонстровано, що приведення під-типів не працює для параметрів загального типу. Тож,</p>

    <pre id="c04s025" class="prettyprint lang-java">
    List&lt;Number&gt; intList = new ArrayList&lt;Integer&gt;();
    </pre>

    <p>викличе помилку компіляції</p>

    <pre id="c04s026">
    WildCardUse.java:6: incompatible types
    found   : java.util.ArrayList&lt;java.lang.Integer&gt;
    required: java.util.List&lt;java.lang.Number&gt;
                    List&lt;Number&gt; numList = new ArrayList&lt;Integer&gt;();
    </pre>

    <p>Після маленької зміни оператора для використання підстановочного параметру він скомпілюється</p>

    <pre id="c04s027" class="prettyprint lang-java">
    List&lt;?&gt; wildCardList = new ArrayList&lt;Integer&gt;();
    </pre>

    <p>Що означає <em>підстановочний</em>? Підстановка може підійти для будь-якого типу. В прикладі з <tt class="prettyprint lang-java">List&lt;?&gt;</tt>, можна вважати, що це <tt class="prettyprint lang-java">List</tt> будь-якого типу &ndash; іншими словами, "список з невідомо чого".</p>

    <p>Але... коли потрібен тип у сенсі "будь-який тип", то використовується клас <tt class="prettyprint lang-java">Object</tt>, чи не так? Чи можна в наступному операторі використати параметр типу <tt class="prettyprint lang-java">Object</tt>?</p>

    <pre id="c04s028" class="prettyprint lang-java">
    List&lt;Object&gt; numList = new ArrayList&lt;Integer&gt;();
    </pre>

    <p>На жаль, ні &ndash; та сама помилка, що була при спробі використати <tt class="prettyprint lang-java">List&lt;Number&gt;</tt>!</p>

    <pre id="c04s029" class="prettyprint lang-java">
    WildCardUse.java:6: incompatible types
    found   : java.util.ArrayList&lt;java.lang.Integer&gt;
    required: java.util.List&lt;java.lang.Object&gt;
                    List&lt;Object&gt; numList = new ArrayList&lt;Integer&gt;();
    </pre>

    <p>Іншими словами, ми знов намагалися використовувати приведення під-типів для загальних параметрів &ndash; і це знов не спрацювало. Як можна бачити, <tt class="prettyprint lang-java">List&lt;Object&gt;</tt> не те саме, що <tt class="prettyprint lang-java">List&lt;?&gt;</tt>. Фактично, <tt class="prettyprint lang-java">List&lt;?&gt;</tt> це супер-тип будь-якого типу <tt class="prettyprint lang-java">List</tt>, що означає можливість передавати <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt>, чи <tt class="prettyprint lang-java">List&lt;String&gt;</tt> чи навіть <tt class="prettyprint lang-java">List&lt;Object&gt;</tt> там, де очікується <tt class="prettyprint lang-java">List&lt;?&gt;</tt>.</p>

    <p>Спробуємо підстановку на прикладі та подивимось, чи спрацює (див. <a href="#c04l08">Лістинг 4-8</a>).</p>

    <pre id="c04l08" class="prettyprint lang-java">
    // Лістинг 4-8. WildCardUse.java
    import java.util.List;
    import java.util.ArrayList;

    class WildCardUse {
        static void printList(List&lt;?&gt; list){
            for(Object element: list)
            System.out.println("[" + element + "]");
        }

        public static void main(String []args) {
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            list.add(10);
            list.add(100);
            printList(list);
            List&lt;String&gt; strList = new ArrayList&lt;&gt;();
            strList.add("10");
            strList.add("100");
            printList(strList);
        }
    }
    </pre>

    <p>Ця програма друкує наступне:</p>

    <pre>
    [10]
    [100]
    [10]
    [100]
    </pre>

    <p>Так, працює; та до списку з підстановкою можна передавати список цілих чи список рядків. Це відбувається оскільки тип параметра методу <tt class="prettyprint lang-java">printList()</tt> &ndash; <tt class="prettyprint lang-java">List&lt;?&gt;</tt>. Чудово!</p>

    <h4><a name="D0.9E.D0.B1.D0.BC.D0.B5.D0.B6.D0.B5.D0.BD.D0.BD.D1.8F_.D0.BF.D1.96.D0.B4.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BE.D0.BA">Обмеження підстановок</a></h4>

    <p>Розглянемо наступний фрагмент коду, в якому робиться спроба додати елемент та друк списка:</p>

    <pre id="c04s030" class="prettyprint lang-java">
    List&lt;?&gt; wildCardList = new ArrayList&lt;Integer&gt;();
    wildCardList.add(new Integer(10));
    System.out.println(wildCardList);
    </pre>

    <p>Отримуємо помилку компіляції:</p>

    <pre id="c04s031">
    WildCardUse.java:7: cannot find symbol
    symbol : method add(java.lang.Integer)
    location: interface java.util.List&lt;capture#145 of ? extends java.lang.Number&gt;
                    wildCardList.add(new Integer(10));
    </pre>

    <p>Чому? Ми впевнені в існуванні методу <tt class="prettyprint lang-java">add()</tt> в інтерфейсі <tt class="prettyprint lang-java">List</tt>. Чому компілятор не знаходить цей метод?</p>

    <p>Ця проблема потребує детального пояснення. При використання типу підстановки <tt class="prettyprint lang-java">&lt;?&gt;</tt> компілятору повідомляється про ігнорування інформації про тип, отже <tt class="prettyprint lang-java">&lt;?&gt;</tt> залишається невідомим типом. Кожен раз при спробі надати аргументи до загального типу компілятор java намагається вивести тип наданого аргументу як і типу узагальнення та забезпечити безпечність типів. Тепер ми намагаємось використовувати метод <tt class="prettyprint lang-java">add()</tt> для вставки елемента у список. Оскільки wildCardList не знає, об'єкти якого типу він містить, це ризикова операція. Можна же додати рядок &ndash; "привіт", наприклад &ndash; замість цілого значення. Для уникнення цієї проблеми (пам'ятайте, узагальнення представлені в мові для забезпечення безпечності типів!) компілятор не дозволяє викликати методи, які модифікують об'єкт. Оскільки метод <tt class="prettyprint lang-java">add</tt> модифікує об'єкт, ми отримуємо помилку! Повідомлення про помилку може виглядати заплутаним: <tt class="prettyprint lang-java">&lt;capture#145 of ? extends java.lang.Number&gt;</tt>.</p>

    <hr/>
    <p>Взагалі при використанні підстановочних параметрів не можна викликати методи, які модифікують об'єкт. При спробі виконати модифікацію компілятор надасть заплутане повідомлення про помилку. Однак, можна викликати методи, які отримують доступ до об'єкту.</p>
    <hr/>

    <h3><a name="D0.9F.D0.B0.D0.BC.27.D1.8F.D1.82.D0.BA.D0.B0">Пам'ятка</a></h3>

    <p>Декілька корисних пунктів, які слід пам'ятати:</p>

    <ul>
    	<li>Можливо визначати або оголошувати загальні методи в інтерфейсі або класі, навіть якщо інтерфейс або клас самі не є загальними.</li>

    	<li>Загальний клас, який використовується без аргументів типу, називається <em>необробленим типом</em>. Звичайно, необроблені типи не є безпечними відносно типів. Java підтримує необроблені типи, так що можливе використання загального типу в коді, який старіший за Java 5 (узагальнення представлені в Java 5). Компілятор генерує попередження при використанні необроблених типів. Можна використовувати <tt class="prettyprint lang-java">@SuppressWarnings({ "unchecked" })</tt> для подавлення попереджень, пов'язаних з необробленими типами.</li>

    	<li><tt class="prettyprint lang-java">List&lt;?&gt;</tt> це супер-тип будь-якого типу <tt class="prettyprint lang-java">List</tt>, і це означає, що можна передавати <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt>, чи <tt class="prettyprint lang-java">List&lt;String&gt;</tt>, або навіть <tt class="prettyprint lang-java">List&lt;Object&gt;</tt> туди, де очікується <tt class="prettyprint lang-java">List&lt;?&gt;</tt>.</li>

    	<li>За своєю природою реалізація узагальнень є статичною, це означає, що компілятор Java інтерпретує узагальнення, вказані в коді, та замінює їх на певні типи. Це називається <em>стиранням типу</em>. Після компіляції байт-код буде таким, якби розробник писав код одразу з певними типами. Використання узагальнень надає дві переваги: по-перше, абстракцію, яка дозволяє писати більш загальні реалізації; по-друге, дозволяє писати реалізацію узагальнення з безпекою (захистом) типів.</li>

    	<li>
    		Стирання типа накладає обмеження на узагальнені типи. Найбільш вагомі:
    		<ul>
    			<li>
    				Не можна створювати екземпляр узагальненого типу оператором <tt class="prettyprint lang-java">new</tt>. Наприклад, якщо <tt class="prettyprint lang-java">mem</tt> це поле, то наступний оператор викличе помилку компіляції:
    				<pre>
    T mem = new T();	// хибне використання - помилка компілятора
    				</pre>
    			</li>
    			<li>
    				Не можна створювати масив узагальненого типу. Наприклад, якщо <tt class="prettyprint lang-java">mem</tt> це поле, то наступний оператор призведе до помилки компіляції:
    				<pre>
    T[] amem = new T[100]; // хибне використання - помилка компілятора
    				</pre>
    			</li>
    			<li>
    				Можна оголошувати поля екземпляра типу <tt class="prettyprint lang-java">T</tt>, а статичні поля типу <tt class="prettyprint lang-java">T</tt> - ні. Наприклад,
    				<pre id="c04s032" class="prettyprint lang-java">
    class X&lt;T&gt; {
        T instanceMem;        // добре
        static T statMem;    // хибне використання - помилка компілятора
    }
    				</pre>
    			</li>
    		</ul>
    	</li>
    	<li>
    		Не можна мати узагальнені класи винятків; наступне не скомпілюється:
    		<pre id="c04s033" class="prettyprint lang-java">
    class GenericException&lt;T&gt; extends Throwable { } // хибне використання - помилка компілятора
    		</pre>
    	</li>
    	<li>Не можна створювати екземпляр узагальненого типу з примітивними типами &ndash; іншими словами, не можна створити екземпляр типу <tt class="prettyprint lang-java">List&lt;int&gt;</tt>. Однак, можна використовувати обгортки примітивних типів.	</li>
    </ul>

    <h2><a name="D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D1.82.D0.B0_.D0.B2.D0.B8.D0.BA.D0.BE.D1.80.D0.B8.D1.81.D1.82.D0.B0.D0.BD.D0.BD.D1.8F_.D0.BA.D0.BB.D0.B0.D1.81.D1.96.D0.B2_.D0.BA.D0.BE.D0.BB.D0.B5.D0.BA.D1.86.D1.96.D0.B9">Створення та використання класів колекцій</a></h2>

    <p>Цілі</p>

    <ul>
    	<li>Створювати та використовувати об'єкти класів <tt class="prettyprint lang-java">ArrayList</tt>, <tt class="prettyprint lang-java">TreeSet</tt>, <tt class="prettyprint lang-java">TreeMap</tt> та <tt class="prettyprint lang-java">ArrayDeque</tt></li>
    </ul>

    <p>Бібліотека Java має каркас (фреймворк) колекцій, в якому широко використовуються узагальнення та надається набір контейнерів та алгоритмів. В цьому розділі зосередимо увагу на використанні цього каркаса. Зокрема, обговоримо такі важливі класи колекцій як <tt class="prettyprint lang-java">ArrayList</tt>, <tt class="prettyprint lang-java">TreeSet</tt>, <tt class="prettyprint lang-java">TreeMap</tt> та <tt class="prettyprint lang-java">ArrayDeque</tt>.</p>

    <hr/>
    <p>Термін <em>колекція</em> є загальним, в той час як <tt class="prettyprint lang-java">Collection</tt> і <tt class="prettyprint lang-java">Collections</tt> це специфічні API пакета <tt class="prettyprint lang-java">java.util</tt>. <tt class="prettyprint lang-java">Collections</tt> &ndash; в <tt class="prettyprint lang-java">java.util.Collections</tt> &ndash; це службовий клас, який містить лише статичні методи. Загальний термін <em>колекція</em> посилається на такі контейнери як <tt class="prettyprint lang-java">map</tt>, <tt class="prettyprint lang-java">set</tt>, <tt class="prettyprint lang-java">stack</tt> чи <tt class="prettyprint lang-java">queue</tt>. Для посилання на ці <em>колекції</em> в цій главі для ясності будемо використовувати термін <em>контейнер</em>.</p>
    <hr/>

    <h3><a name="D0.90.D0.B1.D1.81.D1.82.D1.80.D0.B0.D0.BA.D1.82.D0.BD.D1.96_.D0.BA.D0.BB.D0.B0.D1.81.D0.B8_.D1.82.D0.B0_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B8">Абстрактні класи та інтерфейси</a></h3>

    <p>Ієрархія типів в бібліотеці <tt class="prettyprint lang-java">java.util</tt> містить багато абстрактних класів та інтерфейсів, які надають загальну функціональність. <a href="#c04t01">Таблиця 4-1</a> містить декілька вадливих типів з цієї ієрархії. Деякі з них обговорюватимуться детальніше в цьому розділі.</p>

    <table id="c04t01" border="1">
    	<caption>Таблиця 4-1. Важливі абстрактні класи та інтерфейси в каркасі колекцій</caption>
    	<tr><th>Абстрактний клас/Інтерфейс</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">Iterable</tt></td><td>Клас, який реалізує цей інтерфейс, може бути використаний для проходження оператором <tt class="prettyprint lang-java">foreach</tt>.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Collection</tt></td><td>Загальний базовий інтерфейс для класів в ієрархії колекцій. При необхідності написання дуже загальних методів можна передавати інтерфейс <tt class="prettyprint lang-java">Collection</tt>. Наприклад, метод <tt class="prettyprint lang-java">max()</tt> в <tt class="prettyprint lang-java">java.util.Collections</tt> приймає <tt class="prettyprint lang-java">Collection</tt> та повертає об'єкт.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">List</tt></td><td>Базовий інтерфейс для контейнерів, який зберігає послідовність елементів. Можна мати доступ до елементів з використанням індекса та отримати той самий елемент пізніше (так він підтримує порядок вставки). В <tt class="prettyprint lang-java">List</tt> можна зберігати дублюючі елементи.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Set, SortedSet, NavigableSet</tt></td><td>Інтерфейси для контейнерів, які не дозволяють дублюючі елементи. <tt class="prettyprint lang-java">SortedSet</tt> супроводжує набір елементів в порядку сортування. <tt class="prettyprint lang-java">NavigableSet</tt> дозволяє пошук по набору для найбільшого співпадіння.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Queue, Deque</tt></td><td><tt class="prettyprint lang-java">Queue</tt> це базовий інтерфейс для контейнерів з послідовністю елементів для обробки. Наприклад, класи, які реалізують <tt class="prettyprint lang-java">Queue</tt> можуть бути LIFO (останній зайшов, перший вийшов &ndash; як в структурі даних "стек") чи FIFO (перший зайшов, перший вийшов &ndash; як в структурі даних "черга"). В <tt class="prettyprint lang-java">Deque</tt> можна вставляти та видаляти елементи з обох кінців.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Map, SortedMap, NavigableMap</tt></td><td>Інтерфейси для контейнерів, які співставляють ключ та значення. В <tt class="prettyprint lang-java">SortedMap</tt> ключі впорядковані. <tt class="prettyprint lang-java">NavigableMap</tt> дозволяє шукати найближче співпадіння за наданим критерієм. Зауважте, що ієрархія <tt class="prettyprint lang-java">Map</tt> <em>НЕ</em> розширює інтерфейс <tt class="prettyprint lang-java">Collection</tt>.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Iterator, ListIterator</tt></td><td>Контейнер можна проходити в прямому напрямку, якщо клас реалізує інтерфейс <tt class="prettyprint lang-java">Iterator</tt>. Якщо клас реалізує інтерфейс implements the <tt class="prettyprint lang-java">ListIterator</tt>, можна проходити як в прямому, так і в зворотньому напрямках.</td></tr>
    </table>

    <p>Не треба переживати з-за доволі великої кількості таких базових типів. Подивимось на окремі певні класи та використання деяких з базових типів. Розглянемо спочатку лише інтерфейс <tt class="prettyprint lang-java">Collection</tt>, а потім - певні специфічні класи, які є частиною цієї ієрархії колекцій.</p>

    <h4><a name="D0.86.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81_">Інтерфейс </a><tt class="prettyprint lang-java">Collection</tt></h4>

    <p>Інтерфейс <tt class="prettyprint lang-java">Collection</tt> пропонує такі методи як <tt class="prettyprint lang-java">add()</tt> та <tt class="prettyprint lang-java">remove()</tt>, які є загальними для всіх контейнерів. <a href="#c04t02">Таблиця 4-2</a> перелічує найбільш важливі методи цього інтерфейса.</p>

    <table id="c04t02" border="1">
    	<caption>Таблиця 4-2. Важливі методи інтерфейса <tt class="prettyprint lang-java">Collection</tt></caption>
    	<tr><th>Метод</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean add(Element elem)</tt></td><td>Додає <tt class="prettyprint lang-java">elem</tt> в свій контейнер.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">void clear()</tt></td><td>Видаляє всі елементи контейнера.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean isEmpty()</tt></td><td>Перевіряє, чи є в контейнері хоча б один елемент.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Iterator&lt;Element&gt; iterator()</tt></td><td>Повертає об'єкт <tt class="prettyprint lang-java">Iterator&lt;Element&gt;</tt> для проходження по контейнеру.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean remove(Object obj)</tt></td><td>Видаляє елемент, якщо <tt class="prettyprint lang-java">obj</tt> міститься в контейнері.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">int size()</tt></td><td>Повертає кількість елементів в контейнері.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Object[] toArray()</tt></td><td>Повертає масив з елементів контейнера.</td></tr>
    </table>

    <p>Такі методи як <tt class="prettyprint lang-java">add()</tt> та <tt class="prettyprint lang-java">remove()</tt> можуть викликати помилку. Наприклад, якщо контейнер лише для читання, не можна буде додавати чи видаляти елементи. Також є багато методів в інтерфейсі <tt class="prettyprint lang-java">Collection</tt>, які застосовуються до багатьох елементів контейнера (<a href="#c04t03">Таблиця 4-3</a>).</p>

    <table id="c04t03" border="1">
    	<caption>Таблиця 4-3. Методи інтерфейса <tt class="prettyprint lang-java">Collection</tt>, які застосовуються до декількох елементів</caption>
    	<tr><th>Метод</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean addAll(Collection&lt;? extends Element&gt; coll)</tt></td><td>Додає елементи <tt class="prettyprint lang-java">coll</tt> до контейнера.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean containsAll(Collection&lt;?&gt; coll)</tt></td><td>Перевіряє, чи всі елементи <tt class="prettyprint lang-java">coll</tt> наявні в контейнері.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean removeAll(Collection&lt;?&gt; coll)</tt></td><td>Видаляє всі елементи <tt class="prettyprint lang-java">coll</tt> з контейнера.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean retainAll(Collection&lt;?&gt; coll)</tt></td><td>Залишає в контейнері елементи, які наявні в <tt class="prettyprint lang-java">coll</tt>; всі інші елементи видаляються.</td></tr>
    </table>

    <h3><a name="D0.9F.D0.B5.D0.B2.D0.BD.D1.96_.28.D0.BA.D0.BE.D0.BD.D0.BA.D1.80.D0.B5.D1.82.D0.BD.D1.96.2C_concrete.29_.D0.BA.D0.BB.D0.B0.D1.81.D0.B8">Певні (конкретні, concrete) класи</a></h3>

    <p>Багато інтерфейсів та абстрактних класів в ієрархії <tt class="prettyprint lang-java">Collection</tt> надають спільні методи, які реалізуються чи розширюються специфічними певними класами. Певний клас надає дійсну функціональність. <a href="#c04t04">Таблиця 4-4</a> підсумовує властивості класів.</p>

    <table id="c04t04" border="1">
    	<caption>Таблиця 4-4. Важливі певні класи в каркасі <tt class="prettyprint lang-java">Collection</tt></caption>
    	<tr><th>Певний клас</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">ArrayList</tt></td><td> Всередині реалізований як масив зі змінним розміром. Це один з найбільш використовуваних певних класів. Швидкий для пошуку, але повільний для вставки чи видалення. Дозволяє дублікати.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">LinkedList</tt></td><td>Всередині реалізує структуру даних "список з подвійним зв'язком". Швидкий для вставки чи видалення елементів, але повільний для пошуку. Також <tt class="prettyprint lang-java">LinkedList</tt> може бути використаний при потребі в структурах даних стек (LIFO) або черга (FIFO). Дозволяє дублікати.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">HashSet</tt></td><td>Всередині реалізований як структура даних "хеш-таблиця". Використовується для зберігання набору елементів &ndash; не дозволяє збереження дублікатів. Швидкий для пошуку та отримання еллементів. Не підтримує сортування елементів, що зберігаються.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">TreeSet</tt></td><td>Всередині реалізує структуру даних червоно-чорного дерева. Як <tt class="prettyprint lang-java">HashSet</tt>, <tt class="prettyprint lang-java">TreeSet</tt> не дозволяє збереження дублікатів. На відміну від <tt class="prettyprint lang-java">HashSet</tt>, зберігає елементи в порядку сортування. Використовує структуру даних "дерево" для вирішення, де зберігати або шукати елементи, та позиція обирається порядком сортування.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">HashMap</tt></td><td>Всередині реалізованй як структура даних "хеш-таблиця". Зберігає пари ключ-значення. Використовує хешування для пошуку чи збереження пари. Пошук та вставка дуже швидкі. Елеенти зберігаються без будь-якого порядку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">TreeMap</tt></td><td>Всередині реалізує структуру даних червоно-чорного дерева. На відміну від <tt class="prettyprint lang-java">HashMap</tt>, <tt class="prettyprint lang-java">TreeMap</tt> зберігає елементи в порядку сортування. Використовує структуру даних "дерево" для вирішення, де зберігати або шукати елементи, та позиція обирається порядком сортування.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">PriorityQueue</tt></td><td>Всередині реалізований з використанням структури даних "куча" (heap). <tt class="prettyprint lang-java">PriorityQueue</tt> призначений для отримання елементів на основі пріоритету. Без зв'язку з порядком вставки при видаленні елементів першим буде отриманий елемент з найвищим пріоритетом.</td></tr>
    </table>

    <hr/>
    <p>Існує багато старих класів <tt class="prettyprint lang-java">java.util</tt>, які було замінено новими класами колекцій. Деякі з них (з оновленими типами в дужках): <tt class="prettyprint lang-java">Enumeration</tt> ( <tt class="prettyprint lang-java">Iterator</tt> ), <tt class="prettyprint lang-java">Vector</tt> ( <tt class="prettyprint lang-java">ArrayList</tt> ), <tt class="prettyprint lang-java">Dictionary</tt> ( <tt class="prettyprint lang-java">Map</tt> ) та <tt class="prettyprint lang-java">Hashtable</tt> ( <tt class="prettyprint lang-java">HashMap</tt> ). А класи <tt class="prettyprint lang-java">Stack</tt> та <tt class="prettyprint lang-java">Properties</tt> не мають прямих заміщень.</p>
    <hr/>

    <h4><a name="D0.9A.D0.BB.D0.B0.D1.81_">Клас </a><tt class="prettyprint lang-java">ArrayList</tt></h4>

    <p>Для збереження послідовності елементів використовуються різні <tt class="prettyprint lang-java">List</tt>-и. Можна вставляти елемент контейнера в певну позицію, використовуючи індекс, та отримувати той самий елемент пізніше. В списку можна зберігати дублюючі елементи. Є два певні класи, які треба знати: <tt class="prettyprint lang-java">ArrayList</tt> та <tt class="prettyprint lang-java">LinkedList</tt>.</p>

    <p><tt class="prettyprint lang-java">ArrayList</tt> реалізує масив із змінним розміром. При створенні простого масива (скажімо, <tt class="prettyprint lang-java">new String[10];</tt>), розмір масива в час створення відомий (фіксований). Однак, <tt class="prettyprint lang-java">ArrayList</tt> це <em>динамічний масив</em>: він при необхідності може зростати. Всередині <tt class="prettyprint lang-java">ArrayList</tt> виділяє блок пам'яті та зростає за потреби. Доступ до елементів масива <tt class="prettyprint lang-java">ArrayList</tt> дуже швидкий. Однак, при додаванні чи видаленні елементів всередині залишок елементів копіюється; отже додавання/видалення елементів - операція дорога.</p>

    <p>Простий приклад роботи з елементами <tt class="prettyprint lang-java">ArrayList</tt>. Маємо <tt class="prettyprint lang-java">ArrayList</tt> та використовуємо конструкцію <tt class="prettyprint lang-java">for-each</tt> для проходження по ньому:</p>

    <pre id="c04s034" class="prettyprint lang-java">
    ArrayList&lt;String&gt; languageList = new ArrayList&lt;&gt;();
    languageList.add("C");
    languageList.add("C++");
    languageList.add("Java");
    for(String language : languageList) {
        System.out.println(language);
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    C
    C++
    Java
    </pre>

    <p>Ця конструкція <tt class="prettyprint lang-java">for-each</tt> еквівалентна наступному коду, в якому явно використовується <tt class="prettyprint lang-java">Iterator</tt>:</p>

    <pre id="c04s035" class="prettyprint lang-java">
    for(Iterator&lt;String&gt; languageIter = languageList.iterator(); languageIter.hasNext();) {
        String language = languageIter.next();
        System.out.println(language);
    }
    </pre>

    <p>Цей фрагмент кода видає такий самий вивід, що й код цикла <tt class="prettyprint lang-java">for-each</tt>. Покроковий опис роботи цикла:</p>

    <ol>
    	<li>Для отримання ітератора для контейнера використовується метод <tt class="prettyprint lang-java">iterator()</tt>. Оскільки <tt class="prettyprint lang-java">languageList</tt> в <tt class="prettyprint lang-java">ArrayList</tt> типу <tt class="prettyprint lang-java">&lt;String&gt;</tt>, треба створити <tt class="prettyprint lang-java">Iterator</tt> з <tt class="prettyprint lang-java">String</tt>. З іменем <tt class="prettyprint lang-java">languageIter</tt>.</li>
    	<li>Перед входженням до циклу перевіряється, чи існує хоча б один елемент. Для цього викликається метод <tt class="prettyprint lang-java">hasNext()</tt>. Якщо він повертає <tt class="prettyprint lang-java">true</tt>, елемент існує; якщо повертається <tt class="prettyprint lang-java">false</tt>, ітерацію завершено та виконується вихід з циклу.</li>
    	<li>При входженні в тіло циклу спочатку викликається <tt class="prettyprint lang-java">next()</tt> та ітератор переміщується. Метод <tt class="prettyprint lang-java">next()</tt> повертає нове значення. Його можна отримати в змінну <tt class="prettyprint lang-java">language</tt>.</li>
    	<li>Друкується значення <tt class="prettyprint lang-java">language</tt> та цикл продовжується.</li>
    </ol>

    <p>Ідіома ітерування &ndash; спосіб виклику методів <tt class="prettyprint lang-java">iterator()</tt>, <tt class="prettyprint lang-java">hasNext()</tt> та <tt class="prettyprint lang-java">next()</tt> &ndash; дуже важлива; ця ідіома або цикл for-each будуть широко виокристовуватися в подальших прикладах.</p>

    <p>Зверніть увагу на те, що створюються <tt class="prettyprint lang-java">ArrayList&lt;String&gt;</tt> і <tt class="prettyprint lang-java">Iterator&lt;String&gt;</tt>, а не <tt class="prettyprint lang-java">ArrayList</tt> та <tt class="prettyprint lang-java">Iterator</tt> (тобто разом з класами надається інформація про типи). Класи <tt class="prettyprint lang-java">Collection</tt> це узагальнені класи; отже для користування ними треба вказувати типи параметрів. Оскільки тут маємо справи із списком рядків, то потрібно використовувати <tt class="prettyprint lang-java">&lt;String&gt;</tt>.</p>

    <p>При проходженні контейнера з використанням ітераторів можна видаляти елементи. Створимо об'єкт типу <tt class="prettyprint lang-java">ArrayList&lt;Integer&gt;</tt> з десятьма елементами. Потім пройдемося по елементах та видалемо всі (замість використання метода <tt class="prettyprint lang-java">removeAll()</tt> в <tt class="prettyprint lang-java">ArrayList</tt>). <a href="#c04l09">Лістинг 4-9</a> містить код. Чи він працбватиме?</p>

    <pre id="c04l09" class="prettyprint lang-java">
    // Лістинг 4-9. TestIterator.java
    import java.util.ArrayList;
    import java.util.Iterator;

    class TestIterator {
        public static void main(String []args) {
            ArrayList&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();
            for(int i = 1; i &lt; 10; i++)
            	nums.add(i);
            System.out.println("Початковий список " + nums);
            Iterator&lt;Integer&gt; numsIter = nums.iterator();
            while(numsIter.hasNext()) {
                numsIter.remove();
            }
            System.out.println("Список після видалення всіх елементів " + nums);
        }
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Початковий список [1, 2, 3, 4, 5, 6, 7, 8, 9]
    Exception in thread "main" java.lang.IllegalStateException
    		at java.util.AbstractList$Itr.remove(AbstractList.java:356)
    		at TestIterator.main(Main.java:12)
    </pre>

    <p>Що трапилося? Проблема полягає в тому, що перед викликом <tt class="prettyprint lang-java">remove()</tt> не був викликаний <tt class="prettyprint lang-java">next()</tt>. Перевірка <tt class="prettyprint lang-java">hasNext()</tt> в умові цикла <tt class="prettyprint lang-java">while</tt>, переміщення на елемент за допомогою <tt class="prettyprint lang-java">next()</tt>, виклик <tt class="prettyprint lang-java">remove()</tt> це правильний шлях для видалення елемента. Якщо не робити це правильно, можна отримати проблеми (наприклад, <tt class="prettyprint lang-java">IllegalStateException</tt>). Аналогічно, при виклику <tt class="prettyprint lang-java">remove()</tt> двічі без посереднього <tt class="prettyprint lang-java">next()</tt> також виникне цей виняток.</p>

    <p>Виправимо проблему шляхом виклика <tt class="prettyprint lang-java">next()</tt> перед викликом <tt class="prettyprint lang-java">remove()</tt>. Відповідна частина кода:</p>

    <pre id="c04s036" class="prettyprint lang-java">
    Iterator&lt;Integer&gt; numsIter = nums.iterator();
    while(numsIter.hasNext()) {
        numsIter.next();
        numsIter.remove();
    }
    System.out.println("Список після видалення всіх елементів " + nums);
    </pre>

    <p>Він друкує список без елементів, як і очікувалося:</p>

    <pre>
    Список після видалення всіх елементів []
    </pre>

    <hr/>
    <p>Слід пам'ятати, що треба викликати <tt class="prettyprint lang-java">next()</tt> перед викликом <tt class="prettyprint lang-java">remove()</tt> в <tt class="prettyprint lang-java">Iterator</tt>; інакше виникне <tt class="prettyprint lang-java">IllegalStateException</tt>. Аналогічно, виклик <tt class="prettyprint lang-java">remove()</tt> в послідовних операторах без виклика <tt class="prettyprint lang-java">next()</tt> між цими операторами також прихведе до цього винятку. Коротше, будь-яка модифікація контейнера при його проходженні ітератором призведе до цього винятку.</p>
    <hr/>

    <h4><a name="D0.92.D0.B8.D0.BA.D0.BE.D1.80.D0.B8.D1.81.D1.82.D0.B0.D0.BD.D0.BD.D1.8F_">Використання </a><tt class="prettyprint lang-java">Arrays.asList()</tt></h4>

    <p>Клас <tt class="prettyprint lang-java">java.util.Arrays</tt> має корисний метод <tt class="prettyprint lang-java">asList()</tt>, який повертає список фіксованої довжини. Цікавий аспект щодо об'єкта <tt class="prettyprint lang-java">List</tt>, який повертається: не можна додавати чи видаляти елементи, але можна змінити об'єкт, який повертається методом  <tt class="prettyprint lang-java">asList()</tt>! Також, модифікації, зроблені через <tt class="prettyprint lang-java">List</tt>, відображаються в оригінальному масиві (дивись <a href="#c04l10">Лістинг 4-10</a>).</p>

    <pre id="c04l10" class="prettyprint lang-java">
    // Лістинг 4-10. ArrayAsList.java
    import java.util.List;
    import java.util.Arrays;

    class ArrayAsList {
        public static void main(String []args) {
            Double [] temperatureArray = {31.1, 30.0, 32.5, 34.9, 33.7, 27.8};
            System.out.println("Початковий масив: " +
                Arrays.toString(temperatureArray));
            List&lt;Double&gt; temperatureList = Arrays.asList(temperatureArray);

            temperatureList.set(0, 35.2);
            System.out.println("Початковий масив: " +
                Arrays.toString(temperatureArray));
        }
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Початковий масив: [31.1, 30.0, 32.5, 34.9, 33.7, 27.8]
    Початковий масив: [35.2, 30.0, 32.5, 34.9, 33.7, 27.8]
    </pre>

    <p>Клас <tt class="prettyprint lang-java">Arrays</tt> надає лише обмежену функціональність, методи класа <tt class="prettyprint lang-java">Collections</tt> дуже популярні. Для їх використання можна використовувати метод <tt class="prettyprint lang-java">Arrays.asList()</tt>.</p>

    <h4><a name="D0.9A.D0.BB.D0.B0.D1.81__1">Клас </a><tt class="prettyprint lang-java">TreeSet</tt></h4>

    <p>Набір, як ми знаємо зі школи, не містить дублікатів. На відміну від <tt class="prettyprint lang-java">List</tt>,  <tt class="prettyprint lang-java">Set</tt> не запам'ятовує позицію, в яку був вставлений елемент.</p>

    <p>Для <tt class="prettyprint lang-java">Set</tt> існує два важливих певних класи: <tt class="prettyprint lang-java">HashSet</tt> та <tt class="prettyprint lang-java">TreeSet</tt>. <tt class="prettyprint lang-java">HashSet</tt> використовується для швидких вставки та отримання елементів; він не супроводжує сортування елементів. <tt class="prettyprint lang-java">TreeSet</tt> зберігає елементи в певному порядку (та реалізує інтерфейс <tt class="prettyprint lang-java">SortedSet</tt>).</p>

    <p>Як відсортувати за алфавітом літери, з яких складається надане речення? <tt class="prettyprint lang-java">TreeSet</tt> складає значення в порядку сортування, тож, для вирішення цієї проблеми можна використати контейнер <tt class="prettyprint lang-java">TreeSet</tt> (дивись <a href="#c04l11">Лістинг 4-11</a>).</p>

    <pre id="c04l11" class="prettyprint lang-java">
    // Лістинг 4-11. TreeSetTest.java
    import java.util.Set;
    import java.util.TreeSet;

    class TreeSetTest {
        public static void main(String []args) {
            String pangram = "Єхидна, ґава, їжак ще й шиплячі плазуни бігцем форсують Янцзи";
            Set&lt;Character&gt; aToZee = new TreeSet&lt;Character&gt;();
            for(char gram : pangram.toCharArray())
                aToZee.add(gram);
            System.out.println("Панграма: " + pangram);
            System.out.println("Відсортовані символи панграми: " + aToZee);
        }
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Панграма: Єхидна, ґава, їжак ще й шиплячі плазуни бігцем форсують Янцзи
    Відсортовані символи панграми: [ , ,, Є, Я, а, б, в, г, д, е, ж, з, и, й, к, л, м, н, о, п, р, с, т, у, ф, х, ц, ч, ш, щ, ь, ю, я, і, ї, ґ]
    </pre>

    <p><em>Панграма</em> це речення, яке використовує всі символи алфавіту хоча б один раз. Треба зберегти літери панграми в наборі. Оскільки для контейнера треба використати посилальні типи, то треба створити <tt class="prettyprint lang-java">TreeSet</tt> для <tt class="prettyprint lang-java">Characters</tt>.</p>

    <p>Тепер, як отримати символи зі <tt class="prettyprint lang-java">String</tt>? Індексування масива не працює для <tt class="prettyprint lang-java">String</tt>-ів. Наприклад, спроба отримати перший символ "t" за допомогою <tt class="prettyprint lang-java">pangram[0]</tt> викличе помилку компіляції. На щастя, <tt class="prettyprint lang-java">String</tt> має метод <tt class="prettyprint lang-java">toCharArray()</tt>, який повертає <tt class="prettyprint lang-java">char[]</tt>. Отже, можна використати цей метод для проходження по рядку та отримати всі символи. Якщо додати символи в <tt class="prettyprint lang-java">TreeSet</tt>, то вони зберігатимуться в порядку. Таким чином можна отримати всі літери для друку набору.</p>

    <p>Помітили кому на вочатку виводу? Рядок з панграмою має багато пробільних символів. Один пробіл також зберігається в наборі, отже й він друкується!</p>

    <h3><a name="D0.86.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81__1">Інтерфейс </a><tt class="prettyprint lang-java">Map</tt></h3>

    <p><tt class="prettyprint lang-java">Map</tt> зберігає пари ключ-значення. Інтерфейс <tt class="prettyprint lang-java">Map</tt> <em>НЕ</em> розширює інтерфейс <tt class="prettyprint lang-java">Collection</tt>. Однак, є методи в інтерфейсі <tt class="prettyprint lang-java">Map</tt>, які можна використовувати для отримання об'єктних класів, які реалізують інтерфейс<tt class="prettyprint lang-java">Collection</tt> для вирішення цієї проблеми. Також, назви методів в <tt class="prettyprint lang-java">Map</tt> дуже схожі на назви методів в <tt class="prettyprint lang-java">Collection</tt>, тож легко зрозуміти і використовувати <tt class="prettyprint lang-java">Map</tt>. Є два певні (конкретні) класи <tt class="prettyprint lang-java">Map</tt>: <tt class="prettyprint lang-java">HashMap</tt> та <tt class="prettyprint lang-java">TreeMap</tt>.</p>

    <ul>
    	<li><tt class="prettyprint lang-java">HashMap</tt> всередині використовує хеш-таблицю. В <tt class="prettyprint lang-java">HashMap</tt> пошук (чи вибірка) елемента дуже швидкий. Однак, <tt class="prettyprint lang-java">HashMap</tt> не запам'ятовує порядок, в якому елементи були вставлені, та не зберігає їх у будь-якому порядку.</li>
    	<li><tt class="prettyprint lang-java">TreeMap</tt> всередині використовує червоно-чорне дерево. На відміну від <tt class="prettyprint lang-java">HashMap</tt>, <tt class="prettyprint lang-java">TreeMap</tt> зберігає елементи в порядку (а саме, за ключем). Отже, пошук або вставка трохи повільніші у порівнянні з <tt class="prettyprint lang-java">HashMap</tt>.</li>
    	<li></li>
    </ul>

    <h4><a name="D0.86.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81__2">Інтерфейс </a><tt class="prettyprint lang-java">NavigableMap</tt> та клас <tt class="prettyprint lang-java">TreeMap</tt></h4>

    <p>Інтерфейс <tt class="prettyprint lang-java">NavigableMap</tt> розширює інтерфейс <tt class="prettyprint lang-java">SortedMap</tt>. Клас <tt class="prettyprint lang-java">TreeMap</tt> широко використовується, він реалізує <tt class="prettyprint lang-java">NavigableMap</tt>. Як видно з назви, з <tt class="prettyprint lang-java">NavigableMap</tt> можна легко орієнтуватися в <tt class="prettyprint lang-java">Map</tt>. Він має багато методів, які спрощують навігацію по <tt class="prettyprint lang-java">Map</tt>. Можна отримати найближче значення, яке найближче співпадає з наданим ключем, всі значення, менші за наданий ключ, чи більші нього, і таке інше. Подивимость на приклад: Софія, Ірина, Ельвіра та Ольга склали екзамен з максимальною оцінкою 100 та достатньою 40. Якщо треба знайти такі деталі, як хто пройшов екзамен, відсортувати оцінки за сзростанням чи спадінням, то <tt class="prettyprint lang-java">NavigableMap</tt> (та <tt class="prettyprint lang-java">TreeMap</tt>) дуже зручні (дивись <a href="#c04l12">Лістинг 4-12</a>).</p>

    <pre id="c04l12" class="prettyprint lang-java">
    // Лістинг 4-12. NavigableMapTest.java
    import java.util.NavigableMap;
    import java.util.TreeMap;

    public class NavigableMapTest {
        public static void main(String []args) {
            NavigableMap&lt;Integer, String&gt; examScores = new TreeMap&lt;Integer, String&gt;();

            examScores.put(90, "Софія");
            examScores.put(20, "Ірина");
            examScores.put(10, "Ельвіра");
            examScores.put(50, "Ольга");

            System.out.println("Дані в мапі: " + examScores);
            System.out.println("Порядок за спадінням: " + examScores.descendingMap());
            System.out.println("Склали іспит: " + examScores.tailMap(40));
            System.out.println("Найнижча оцінка: " + examScores.firstEntry());
        }
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Дані в мапі: {10=Ельвіра, 20=Ірина, 50=Ольга, 90=Софія}
    Порядок за спадінням: {90=Софія, 50=Ольга, 20=Ірина, 10=Ельвіра}
    Склали іспит: {50=Ольга, 90=Софія}
    Найнижча оцінка: 10=Ельвіра
    </pre>

    <p>В цій програмі маємо <tt class="prettyprint lang-java">NavigableMap&lt;Integer, String&gt;</tt>, який співставляє екзаменаційну оцінку та ім'я людини. Для збереження оцінок створюється <tt class="prettyprint lang-java">TreeMap&lt;Integer, String&gt;</tt>. По замовчанню, <tt class="prettyprint lang-java">TreeMap</tt> зберігає дані в порядку зростання. Якщо треба змінити порядок на спадіння, треба використати метод <tt class="prettyprint lang-java">descendingMap()</tt> (або <tt class="prettyprint lang-java">descendingKeySet()</tt> якщо потрібні лише ключі).</p>

    <p>При тому, що достатньою оцінкою є 40, треба отримати мапу з даними про тих, хто завалив іспит. Для цього можна використати метод <tt class="prettyprint lang-java">headMap()</tt> із значенням ключа 40 (оскільки дані в порядку зростання, треба використати частину мапи "з голови" до наданої позиції). Аналогічно, для отримання даних про тих, хто пройшов іспит, можна використати метод <tt class="prettyprint lang-java">tailMap()</tt>.</p>

    <p>Якщо треба знайти безпосередніх сусідів даного ключа зверху та знизу, можна використати методи <tt class="prettyprint lang-java">higherEntry()</tt> та <tt class="prettyprint lang-java">lowerEntry()</tt> відповідно. Методи <tt class="prettyprint lang-java">firstEntry()</tt> та <tt class="prettyprint lang-java">lastEntry()</tt> повертають елементи з найнижчим та найвищим ключами. Тож, при використанні метода <tt class="prettyprint lang-java">firstEntry()</tt> з <tt class="prettyprint lang-java">examScores</tt>, отримаємо Ельвіра з 10 балами. При використанні <tt class="prettyprint lang-java">lastEntry()</tt> отримаємо Софія з 90.</p>

    <h3><a name="D0.86.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81__3">Інтерфейс </a><tt class="prettyprint lang-java">Deque</tt> та клас <tt class="prettyprint lang-java">ArrayDeque</tt></h3>

    <p><tt class="prettyprint lang-java">Deque</tt> (черга з двома кінцями) це структура даних, яка дозволяє вставку та видалення елементів з обох кінців. Інтерфейс <tt class="prettyprint lang-java">Deque</tt> був представлений з Java 6 в пакеті <tt class="prettyprint lang-java">java.util.collection</tt>. Інтерфейс <tt class="prettyprint lang-java">Deque</tt> розширює інтерфейс <tt class="prettyprint lang-java">Queue</tt>. Отже, всі методи, оголошені в <tt class="prettyprint lang-java">Queue</tt>, також доступні в інтерфейсі <tt class="prettyprint lang-java">Deque</tt>.</p>

    <p>Існує три певні (конкретні) реалізації інтерфейса <tt class="prettyprint lang-java">Deque</tt>: <tt class="prettyprint lang-java">LinkedList</tt>, <tt class="prettyprint lang-java">ArrayDeque</tt> та <tt class="prettyprint lang-java">LinkedBlockingDeque</tt>. Використаємо <tt class="prettyprint lang-java">ArrayDeque</tt> для демонстрації властивостей інтерфейса <tt class="prettyprint lang-java">Deque</tt>.</p>

    <p>Розглянемо реалізацію специфічної черги (скажімо, для сплати по рахункам за комунальні послуги), в яку клієнта можна додати лише в кінець черги, а видалити як з кінця (коли клієнт покинув чергу) так і з початку (коли клієнт оплатив рахунок). <a href="#c04l13">Лістинг 4-13</a> показує це.</p>

    <pre id="c04l13" class="prettyprint lang-java">
    // Лістинг 4-13. SplQueueTest.java
    import java.util.ArrayDeque;
    import java.util.Deque;

    class SplQueue {
        private Deque&lt;String&gt; splQ = new ArrayDeque&lt;&gt;();
        void addInQueue(String customer){
            splQ.addLast(customer);
        }

        void removeFront(){
            splQ.removeFirst();
        }

        void removeBack(){
            splQ.removeLast();
        }

        void printQueue(){
            System.out.println("Спеціальна черга містить: " + splQ);
        }
    }

    class SplQueueTest {
        public static void main(String []args) {
            SplQueue splQ = new SplQueue();
            splQ.addInQueue("Harrison");
            splQ.addInQueue("McCartney");
            splQ.addInQueue("Starr");
            splQ.addInQueue("Lennon");

            splQ.printQueue();
            splQ.removeFront();
            splQ.removeBack();
            splQ.printQueue();
        }
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Спеціальна черга містить: [Harrison, McCartney, Starr, Lennon]
    Спеціальна черга містить: [McCartney, Starr]
    </pre>

    <p>Спочатку визначається клас &ndash; <tt class="prettyprint lang-java">SplQueue</tt> &ndash; він визначає контейнер <tt class="prettyprint lang-java">splQ</tt> типу <tt class="prettyprint lang-java">ArrayDeque</tt> з чотирма базовими операціями. Метод <tt class="prettyprint lang-java">addInQueue()</tt> додає клієнта в кінець черги, метод <tt class="prettyprint lang-java">removeBack()</tt> видаляє клієнта з кінця черги, метод <tt class="prettyprint lang-java">removeFront()</tt> видаляє клієнта з початку черги, а метод <tt class="prettyprint lang-java">printQueue()</tt> просто друкує всі елементи черги. Ми просто використовуємо методи <tt class="prettyprint lang-java">addLast()</tt>, <tt class="prettyprint lang-java">removeFirst()</tt> та <tt class="prettyprint lang-java">removeLast()</tt> інтерфейса <tt class="prettyprint lang-java">Deque</tt>для реалізації методів класа <tt class="prettyprint lang-java">SplQueue</tt>. В нашому методі <tt class="prettyprint lang-java">main()</tt> створюється екземпляр <tt class="prettyprint lang-java">SplQueue</tt> та викликається метод <tt class="prettyprint lang-java">addInQueue()</tt> класа <tt class="prettyprint lang-java">SplQueue</tt>. Потім один клієнт видаляється з початку черги, а інший - з кінця, та зміст черги друкується перед цими видаленнями та після них. Все працює в очікуваний спосіб.</p>

    <hr/>
    <p>Різниця між <tt class="prettyprint lang-java">ArrayList</tt> та <tt class="prettyprint lang-java">ArrayDeque</tt> полягає в тому, що можна додавати елемент будь-куди в масив, використовуючи індекс; однак, в масив deque можна додавати елемент тільки в початок чи в кінець. Це робить вставку в масив deque більш ефективним, ніж в масив list; однак, навігація в масиві deque стає більш дорогою, ніж в масиві list.</p>
    <hr/>

    <h2><a name="D0.86.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B8_">Інтерфейси </a><tt class="prettyprint lang-java">Comparable</tt> та <tt class="prettyprint lang-java">Comparator</tt></h2>

    <p>Цілі</p>

    <ul>
    	<li>Використовувати інтерфейси <tt class="prettyprint lang-java">java.util.Comparator</tt> та <tt class="prettyprint lang-java">java.lang.Comparable</tt></li>
    </ul>

    <p>Як підказує назва, інтерфейси <tt class="prettyprint lang-java">Comparable</tt> та <tt class="prettyprint lang-java">Comparator</tt> використовуються для порівняння схожих об'єктів (наприклад, при виконанні пошуку чи сортування). Припустимо, що є контейнер зі списком об'єктів <tt class="prettyprint lang-java">Person</tt>. Як порівняти два об'єкти <tt class="prettyprint lang-java">Person</tt>? Є багато атрибутів, за якими їх можна порівняти, такі як ІПН, ім'я, вік, тощо. Два об'єкти можна порівняти по ІПН чи по імені - це залежить від контексту. Отже, критерій для порівняння об'єктів <tt class="prettyprint lang-java">Person</tt> не може бути завданий в коді; розробник не має визначати цей критерій. Java визначає інтерфейси <tt class="prettyprint lang-java">Comparable</tt> та <tt class="prettyprint lang-java">Comparator</tt> для такої мети.</p>

    <p>Інтерфейс <tt class="prettyprint lang-java">Comparable</tt> має лише один метод <tt class="prettyprint lang-java">compareTo()</tt>, який оголошений так:</p>

    <pre class="prettyprint lang-java">
    int compareTo(Element that)
    </pre>

    <p>При реалізації метода <tt class="prettyprint lang-java">compareTo()</tt> в класі є посилальна змінна <tt class="prettyprint lang-java">this</tt>. Можна порівняти поточний елемент з наданим як аргумент <tt class="prettyprint lang-java">Element</tt> та повернути значення <tt class="prettyprint lang-java">int</tt>. Яким має бути значення <tt class="prettyprint lang-java">int</tt>? Ось правило, за яким треба повертати ціле значення:</p>

    <pre>
    повернути 1 якщо поточний об'єкт &gt; наданого об'єкта
    повернути 0 якщо поточний об'єкт == наданому об'єкту
    поернути -1 якщо поточний об'єкт &lt; наданого об'єкта
    </pre>

    <p>Тепер важливе питання: що означає <tt class="prettyprint lang-java">&gt;</tt>, <tt class="prettyprint lang-java">&lt;</tt> чи <tt class="prettyprint lang-java">==</tt> для об'єкта <tt class="prettyprint lang-java">Element</tt>? Це - ваша справа, як порівнювати об'єкти! Але значення порівняння має бути природнім; іншими словами, порівняння має означати <em>природній порядок</em>. Наприклад, відомо як порівнюються два <tt class="prettyprint lang-java">Integer</tt>, на основі числового порядка, що є природнім порядком для типів <tt class="prettyprint lang-java">Integer</tt>. Аналогічно, два <tt class="prettyprint lang-java">String</tt>-и порівнюються лексикографічно, що є природнім порядком для <tt class="prettyprint lang-java">String</tt>-ів. Для класів, визначених користувачем треба знайти такий природній порядок, за яким порівнювати об'єкти. Наприклад, для класа <tt class="prettyprint lang-java">Student</tt>, для порівняння двох об'єктів <tt class="prettyprint lang-java">Student</tt> природнім порядком може бути <tt class="prettyprint lang-java">StudentId</tt>. <a href="#c04l14">Лістинг 4-14</a> реалізує простий клас <tt class="prettyprint lang-java">Student</tt>.</p>

    <pre id="c04l14" class="prettyprint lang-java">
    // Лістинг 4-14. ComparatorTest1.java
    import java.util.Arrays;

    class Student implements Comparable&lt;Student&gt; {
        String id;
        String name;
        Double cgpa;

        public Student(String studentId, String studentName, double studentCGPA) {
            id = studentId;
            name = studentName;
            cgpa = studentCGPA;
        }

        public String toString() {
            return " \n " + id + " \t" + name + " \t" + cgpa;
        }

        public int compareTo(Student that) {
            return this.id.compareTo(that.id);
        }
    }

    class ComparatorTest1 {
        public static void main(String []args) {
            Student []students = { new Student("cs011", "Ковпак", 3.1),
                            new Student("cs021", "Федоров", 3.4),
                            new Student("cs012", "Тимошенко", 2.7),
                            new Student("cs022", "Маліновський", 3.7) };

            System.out.println("Перед сортуванням по ID студента");
            System.out.println("Student-ID \t Name \t CGPA (for 4.0) ");
            System.out.println(Arrays.toString(students));

            Arrays.sort(students);

            System.out.println("Після сортування по ID студента");
            System.out.println("Student-ID \t Name \t CGPA (for 4.0) ");
            System.out.println(Arrays.toString(students));
        }
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Перед сортуванням по ID студента
    Student-ID 	 Name 	 CGPA (for 4.0) 
    [ 
     cs011 	Ковпак 	3.1,  
     cs021 	Федоров 	3.4,  
     cs012 	Тимошенко 	2.7,  
     cs022 	Маліновський 	3.7]
    Після сортування по ID студента
    Student-ID 	 Name 	 CGPA (for 4.0) 
    [ 
     cs011 	Ковпак 	3.1,  
     cs012 	Тимошенко 	2.7,  
     cs021 	Федоров 	3.4,  
     cs022 	Маліновський 	3.7]
    </pre>

    <p>Реалізований інтерфейс <tt class="prettyprint lang-java">Comparable&lt;Student&gt;</tt>. При виклику меирда <tt class="prettyprint lang-java">sort()</tt>, викликається метод <tt class="prettyprint lang-java">compareTo()</tt> для порівняння об'єктів <tt class="prettyprint lang-java">Student</tt> по їх <tt class="prettyprint lang-java">ID</tt>. Оскільки в <tt class="prettyprint lang-java">Student</tt> поле <tt class="prettyprint lang-java">ID</tt>унікальне, це є натуральний порядок сортування, який добре працює.</p>

    <p>Тепер може знаобитися сортувати студентів на основі значень їх оцінок (CGPA). Навіть може знадобитися порівнювати <tt class="prettyprint lang-java">Student</tt>-ів по їх іменах. Якщо треба реалізувати два чи більше альтернативних способи порівнювати два схожих об'єкти, можна реалізувати інтерфейс <tt class="prettyprint lang-java">Comparator</tt>. <a href="#c04l15">Лістинг 4-15</a> це реалізація (немає змін в класі <tt class="prettyprint lang-java">Student</tt>, тож він не наведений тут).</p>

    <pre id="c04l15" class="prettyprint lang-java">
    // Лістинг 4-15. ComparatorTest2.java
    import java.util.Arrays;
    import java.util.Comparator;

    class CGPAComparator implements Comparator&lt;Student&gt; {
        public int compare(Student s1, Student s2) {
            return (s1.cgpa.compareTo(s2.cgpa));
        }
    }

    class ComparatorTest2 {
        public static void main(String []args) {
            Student []students = { new Student("cs011", "Ковпак", 3.1),
                            new Student("cs021", "Федоров", 3.4),
                            new Student("cs012", "Тимошенко", 2.7),
                            new Student("cs022", "Маліновський", 3.7) };

            System.out.println("Перед сортуванням по CGPA ");
            System.out.println("Student-ID \t Name \t CGPA (for 4.0) ");
            System.out.println(Arrays.toString(students));

            Arrays.sort(students, new CGPAComparator());

            System.out.println("Після сортування CGPA");
            System.out.println("Student-ID \t Name \t CGPA (for 4.0) ");
            System.out.println(Arrays.toString(students));
    	}
    }
    </pre>

    <p>Друкує наступне::</p>

    <pre>
    Перед сортуванням по CGPA 
    Student-ID 	 Name 	 CGPA (for 4.0) 
    [ 
     cs011 	Ковпак 	3.1,  
     cs021 	Федоров 	3.4,  
     cs012 	Тимошенко 	2.7,  
     cs022 	Маліновський 	3.7]
    Після сортування CGPA
    Student-ID 	 Name 	 CGPA (for 4.0) 
    [ 
     cs012 	Тимошенко 	2.7,  
     cs011 	Ковпак 	3.1,  
     cs021 	Федоров 	3.4,  
     cs022 	Маліновський 	3.7]
    </pre>

    <p>Програма друкує дані <tt class="prettyprint lang-java">Student</tt> в порядку зростання їх CGPA. Клас <tt class="prettyprint lang-java">Student</tt> не був змінений; клас досі реалізує інтерфейс <tt class="prettyprint lang-java">Comparable&lt;String&gt;</tt> та визначає метод <tt class="prettyprint lang-java">compareTo()</tt>, але метод <tt class="prettyprint lang-java">compareTo()</tt> не використовується в програмі. Створюється окремий клас <tt class="prettyprint lang-java">CGPAComparator</tt> та реалізується інтерфейс <tt class="prettyprint lang-java">Comparator&lt;Student&gt;</tt>. Визначається метод <tt class="prettyprint lang-java">compare()</tt>, який приймає два об'єкти <tt class="prettyprint lang-java">Student</tt> в якості аргументів. Порівнюються CGPA аргументів <tt class="prettyprint lang-java">s1</tt> та <tt class="prettyprint lang-java">s2</tt> шляхом (повторного) використання метода <tt class="prettyprint lang-java">compareTo()</tt> класа <tt class="prettyprint lang-java">Double</tt>. В методі <tt class="prettyprint lang-java">main()</tt> нічого не змінюється за винятком способа виклику метода <tt class="prettyprint lang-java">sort()</tt>. Створюється новий об'єкт <tt class="prettyprint lang-java">CGPAComparator()</tt>, який надається в якості другого аргумента методу <tt class="prettyprint lang-java">sort()</tt>. По замовчанню, <tt class="prettyprint lang-java">sort()</tt> використовує метод <tt class="prettyprint lang-java">compareTo()</tt>; оскільки передається явно об'єкт <tt class="prettyprint lang-java">Comparator</tt>, то він тепер використовує метод <tt class="prettyprint lang-java">compare()</tt>, визначений в <tt class="prettyprint lang-java">CGPAComparator</tt>. Тож, тепер об'єкти <tt class="prettyprint lang-java">Student</tt> порівнюються та сортуються на основі їх CGPA.</p>

    <hr/>
    <p>Більшість класів має природній порядок для порівняння об'єктів, тож в таких випадках слід використовувати інтерфейс <tt class="prettyprint lang-java">Comparable</tt>. Якщо треба порівнювати об'єкти у спосіб, відмінний від природнього порядку, чи якщо природнього порядку не імную для класа, слід використовувати інтерфейс <tt class="prettyprint lang-java">Comparator</tt>.</p>
    <hr/>

    <h2><a name="D0.9F.D0.BE.D1.82.D0.BE.D0.BA.D0.B8_.D1.82.D0.B0_.D1.84.D1.96.D0.BB.D1.8C.D1.82.D1.80.D0.B8_.D0.BA.D0.BE.D0.BB.D0.B5.D0.BA.D1.86.D1.96.D0.B9">Потоки та фільтри колекцій</a></h2>

    <p>Цілі</p>

    <ul>
    	<li>Потоки та фільтри колекцій</li>
    </ul>

    <p>Новий потоковий API був запропонований в пакеті <tt class="prettyprint lang-java">java.util.stream</tt> в Java 8. Основний тип в цьому пакеті це інтерфейс <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>, який є потоком об'єктних посилань. <tt class="prettyprint lang-java">IntStream</tt>, <tt class="prettyprint lang-java">LongStream</tt> та <tt class="prettyprint lang-java">DoubleStream</tt> це потоки для примітивних типів <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> відповідно.</p>

    <p>Було додано інтерфейс <tt class="prettyprint lang-java">Collection</tt> з методами <tt class="prettyprint lang-java">stream()</tt> та <tt class="prettyprint lang-java">parallelStream()</tt>. Потік це послідовність елементів. При отриманні потоку через метод <tt class="prettyprint lang-java">stream()</tt> можна виконувати послідовні операції, а через метод <tt class="prettyprint lang-java">parallelStream()</tt> - паралельні. (Паралельні потоки обговорюються в Главі 11.) Оскільки такі інтерфейси, як <tt class="prettyprint lang-java">List</tt>, <tt class="prettyprint lang-java">Set</tt>, <tt class="prettyprint lang-java">Deque</tt> та <tt class="prettyprint lang-java">Queue</tt> розширюють інтерфейс <tt class="prettyprint lang-java">Collection</tt>, можна отримати потік або паралельний потік від класів колекцій, які реалізують ці інтерфейси. Наприклад, можна отримати потік з об'єкта <tt class="prettyprint lang-java">ArrayList</tt>.</p>

    <p>Потоки надають можливість створення конвейєрів (pipelining) &ndash; можна фільтрувати, співставляти (map) та шукати дані. Іншими словами, потокові операції можуть бути пов'язані разом для формування конвейєру. Пізніше в цьому розділі будуть представлені потокові конвейєри, а детально вони обговорюватимуться в Главі 6 (Java Stream API).</p>

    <p>Найбільш загальні джерела потоків це об'єкти таких колекцій як набори, карти та списки. Однак, потоковий API може використовуватися незалежно від колекцій. В решті матеріалу цієї глави обговорюється використання колекцій з потоками.</p>

    <h2><a name="D0.86.D1.82.D0.B5.D1.80.D1.83.D0.B2.D0.B0.D0.BD.D0.BD.D1.8F_.D0.B7_">Ітерування з </a><tt class="prettyprint lang-java">forEach</tt></h2>

    <p>Цілі</p>

    <ul>
    	<li>Ітерування з використанням методів <tt class="prettyprint lang-java">forEach</tt> <tt class="prettyprint lang-java">Streams</tt> та <tt class="prettyprint lang-java">List</tt></li>
    </ul>

    <p>Як програмісти Java, ми виконуємо зовнішнє ітерування по колекціям. Візьмемо список рядків для прикладу:</p>

    <pre id="c04s037" class="prettyprint lang-java">
    List&lt;String&gt; strings = Arrays.asList("еніки", "беніки", "їли", "вареники");
    </pre>

    <p>При проходженні такої колекції з використанням циклу <tt class="prettyprint lang-java">for</tt>, використовується зовнішнє ітерування:</p>

    <pre class="prettyprint lang-java">
    for(String string : strings) {
    	System.out.println(string);
    }
    </pre>

    <p>Внутрішнє ітерування лишає ітерування бібліотечному коду. Той самий код можна перетворити на наступний еквівалентний код з використанням лямбда виразів (<a href="#c04l16">Лістинг 4-16</a>):</p>

    <pre id="c04l16" class="prettyprint lang-java">
    // Лістинг 4-16. InternalIteration.java
    import java.util.Arrays;
    import java.util.List;

    public class InternalIteration {
        public static void main(String []args) {
            List&lt;String&gt; strings = Arrays.asList("еніки", "беніки", "їли", "вареники");
            strings.forEach(string -&gt; System.out.println(string));
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre>
    еніки
    беніки
    їли
    вареники
    </pre>

    <p>Зауважте на те, що інтерфейс <tt class="prettyprint lang-java">List</tt> розширює інтерфейс <tt class="prettyprint lang-java">Iterable</tt>, який має метод по замовчанню <tt class="prettyprint lang-java">forEach</tt> (доданий в Java 8). Отже, можна виконати внутрішнє ітерування, викликавши метод <tt class="prettyprint lang-java">forEach</tt> об'єкта <tt class="prettyprint lang-java">String</tt> та надавши йому лямбда вираз в якості аргумента.</p>

    <p>Хоча цей приклад простий, він ілюструє важливі зміни в підході Java 8: використання внутрішнього ітерування замість зовнішнього. Фактично, на концепції внутрішнього ітерування базується Stream API (Глава 6).</p>

    <p>Перед обговоренням інтерфейса <tt class="prettyprint lang-java">Stream</tt> та поточного конвейєра, поговоримо про важливу тему, пов'язану з лямбда функціями, яку ми використаємо при обговоренні потоків: посилання на методи.</p>

    <h2><a name="D0.9F.D0.BE.D1.81.D0.B8.D0.BB.D0.B0.D0.BD.D0.BD.D1.8F_.D0.BD.D0.B0_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.B8_.D1.82.D0.B0_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B8">Посилання на методи та потоки</a></h2>

    <p>Цілі</p>

    <ul>
    	<li>Використовувати посилання на методи з потоками</li>
    </ul>

    <p>В <a href="#c04l16">Лістингу 4-16</a> використовується лямбда вираз:</p>

    <pre id="c04s038" class="prettyprint lang-java">
    strings.forEach(string -&gt; System.out.println(string));
    </pre>

    <p>Цей код виглядає багатослівним, оскільки ми приймаємо строковий аргумент та просто передаємо його в <tt class="prettyprint lang-java">System.out.println</tt>. Нащастя, в Java 8 представлено властивість, відома як "посилання на методи". Посилання на метод використовує оператор "<tt class="prettyprint lang-java">::</tt>". Спрощений вираз з використанням посилань на методи:</p>

    <pre class="prettyprint lang-java">
    strings.forEach(System.out::println);
    </pre>

    <p><em>Посилання на методи маршрутизують отримані аргументи</em>. В даному випадку, <tt class="prettyprint lang-java">System.out::println</tt> еквівалентний використанню лямбда вираза <tt class="prettyprint lang-java">string -&gt; System.out.println(string)</tt>.</p>

    <p>Як спростити наступний оператор, використовуючи посилання на методи?</p>

    <pre class="prettyprint lang-java">
    strings.forEach(string -&gt; System.out.println(string.toUpperCase()));
    </pre>

    <p>Лямбда вираз в цьому коді викликає метод <tt class="prettyprint lang-java">toUpperCase()</tt> об'єкта <tt class="prettyprint lang-java">String</tt>. Оскільки посилання на методи лише маршрутизують аргументи, то їх не можна використовувати безпосередньо для спрощення цього лямбда виразу. Альтернатива полягає в тому, щоб покласти цей код всередину метода та використати посилання на цей метод (<a href="#c04l17">Лістинг 4-17</a>).</p>

    <pre id="c04l17" class="prettyprint lang-java">
    // Лістинг 4-17. MethodReference.java
    import java.util.Arrays;
    import java.util.List;

    class MethodReference {
        public static void printUpperCaseString(String string) {
            System.out.println(string.toUpperCase());
        }

        public static void main(String []args) {
            List&lt;String&gt; strings = Arrays.asList("еніки", "беніки", "їли", "вареники");
            strings.forEach(MethodReference::printUpperCaseString);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre>
    ЕНІКИ
    БЕНІКИ
    ЇЛИ
    ВАРЕНИКИ
    </pre>

    <p>В цьому варіанті ми ввели статичний метод всередині класа <tt class="prettyprint lang-java">MethodReference</tt>. <tt class="prettyprint lang-java">printUpperCaseString</tt> викликає метод <tt class="prettyprint lang-java">toUpperCase()</tt> наданого як аргумент об'єкта <tt class="prettyprint lang-java">String</tt> та друкує отрманий рядок.</p>

    <p>Підсумковуючи, є дві ключові переваги посилань на методи:</p>

    <ul>
    	<li>Посилання на методи слугують як спосіб маршрутизації аргументів, а тому часто вони більш зручні (призводять до більш стислого кода) у використанні, чим еквівалентні лямбда вирази. Наприклад, <tt class="prettyprint lang-java">System.out::println</tt> може бути використане як еквівалент <tt class="prettyprint lang-java">arg -&gt; System.out.println(arg)</tt> з <a href="#c04l16">Лістингу 4-16</a>.</li>

    	<li>Синтаксис посилань на методи спрощує використання метода в якості лямбда виразу (як в <a href="#c04l17">Лістингу 4-17</a>).</li>
    </ul>

    <h2><a name="D0.A0.D0.BE.D0.B7.D1.83.D0.BC.D1.96.D0.BD.D0.BD.D1.8F_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B0_">Розуміння інтерфейса </a><tt class="prettyprint lang-java">Stream</tt></h2>

    <p>Цілі</p>

    <ul>
    	<li>Описати інтерфейс <tt class="prettyprint lang-java">Stream</tt> та конвейєр <tt class="prettyprint lang-java">Stream</tt></li>
    </ul>

    <p>Інтерфейс <tt class="prettyprint lang-java">Stream</tt> є найважливішим з інтерфейсів, запроваджених в пакеті <tt class="prettyprint lang-java">java.util.stream</tt>. Класи <tt class="prettyprint lang-java">IntStream</tt>, <tt class="prettyprint lang-java">LongStream</tt> та <tt class="prettyprint lang-java">DoubleStream</tt> це <tt class="prettyprint lang-java">Stream</tt>-ові спеціалізації для <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> відповідно. <a href="#c04f01">Рисунок 4-1</a> показує спадкову ієрархію цих потоків.</p>

    <h3><a name="D0.9A.D0.BE.D0.BD.D0.B2.D0.B5.D0.B9.D1.94.D1.80_">Конвейєр </a><tt class="prettyprint lang-java">Stream</tt></h3>

    <p>Операції над потоком можуть бути поєднані для формування потокового конвейєра. В потоковому конвейєрі є три частини (дивись <a href="c04f02">Рисунок 4-2</a>):</p>

    <ul>
    	<li><em>Джерело</em>: Створює потік (з колекції або масива чи з використанням таких методів <tt class="prettyprint lang-java">Stream</tt>, як <tt class="prettyprint lang-java">of()</tt> та <tt class="prettyprint lang-java">generate()</tt>).</li>

    	<li><em>Проміжні операції</em>: Необов'язкові операції, які можуть поєднуватися (такі як методи <tt class="prettyprint lang-java">map()</tt>, <tt class="prettyprint lang-java">filter()</tt>, <tt class="prettyprint lang-java">distinct()</tt> та <tt class="prettyprint lang-java">sorted()</tt>в інтерфейсі <tt class="prettyprint lang-java">Stream</tt>).</li>

    	<li><em>Заключні операції</em>: Формують результат (такі методи як <tt class="prettyprint lang-java">sum()</tt>, <tt class="prettyprint lang-java">collect()</tt>, <tt class="prettyprint lang-java">forEach()</tt> та <tt class="prettyprint lang-java">reduce()</tt> в інтерфейсі <tt class="prettyprint lang-java">Stream</tt>).</li>
    </ul>

    <p>Приклад потокового конвейєра (<a href="#c04l18">Лістинг 4-18</a>).</p>

    <pre id="c04l18" class="prettyprint lang-java">
    // Лістинг 4-18. StreamPipelineExample.java
    import java.util.Arrays;

    class StreamPipelineExample {
        public static void main(String []args) {
            Arrays.stream(Object.class.getMethods())     // джерельна
                    .map(method -&gt; method.getName())     // проміжна
                    .distinct()                         // проміжна
                    .forEach(System.out::println);         // заключна
        }
    }
    </pre>

    <p>Цей код друкує</p>

    <pre>
    wait
    equals
    toString
    hashCode
    getClass
    notify
    notifyAll
    </pre>

    <p><tt class="prettyprint lang-java">Object.class.getMethods()</tt> надає об'єкти класа <tt class="prettyprint lang-java">Method</tt> для методів класа <tt class="prettyprint lang-java">Object</tt>. Операція <tt class="prettyprint lang-java">map(method -&gt; method.getName())</tt> повертає назви методів як масив (як частину <tt class="prettyprint lang-java">Stream</tt>). Метод <tt class="prettyprint lang-java">wait()</tt> в класі <tt class="prettyprint lang-java">Object</tt>це перевантажений метод. Для отримання унікальних назв методів можна використовувати операцію <tt class="prettyprint lang-java">distinct()</tt> для видалення дублікатів в масиві. Наприкінець, заключна операція <tt class="prettyprint lang-java">forEach()</tt> друкує назви методів.</p>

    <p>Один спосіб зрозуміти потоковий конвейєр це розбити компоненти конвейєра на окремі оператори. <a href="#c04l18">Лістинг 4-19</a> розбиває частини на окремі компоненти та є кодом, еквівалентним <a href="#c04l19">Лістингу 4-18</a>.</p>

    <pre id="c04l19" class="prettyprint lang-java">
    // Лістинг 4-19. StreamPipelineComponents.java
    import java.util.Arrays;
    import java.util.stream.Stream;
    import java.lang.reflect.Method;

    class StreamPipelineComponents {
        public static void main(String []args) {
            Method[] objectMethods = Object.class.getMethods();
            Stream&lt;Method&gt; objectMethodStream = Arrays.stream(objectMethods);
            Stream&lt;String&gt; objectMethodNames = objectMethodStream.map(method -&gt; method.getName());
            Stream&lt;String&gt; uniqueObjectMethodNames = objectMethodNames.distinct();
            uniqueObjectMethodNames.forEach(System.out::println);
        }
    }
    </pre>

    <p>Тут ми отримуємо потік шляхом виклику метода <tt class="prettyprint lang-java">Arrays.stream()</tt> з результатом виконання <tt class="prettyprint lang-java">Object.class.getMethod()</tt> &ndash; це джерело потока. Методи <tt class="prettyprint lang-java">map()</tt> та <tt class="prettyprint lang-java">distinct()</tt> приймають потік на вхід на повертають (модифікований) потік в якості результата. Наприкінці, метод <tt class="prettyprint lang-java">forEach()</tt> над потоком це заключна операція на конвейєрі.</p>

    <hr/>
    <p>Не треба плутати <tt class="prettyprint lang-java">map</tt> в потоках з інтерфейсом <tt class="prettyprint lang-java">java.util.Map</tt>. Метод <tt class="prettyprint lang-java">map()</tt> це проміжна операція, яка приймає елементі із вхідного потока, застосовує операцію та генерує потік з елементів як результат; інтерфейс <tt class="prettyprint lang-java">Map</tt> містить пари ключ-значення.</p>
    <hr/>

    <h3><a name="D0.94.D0.B6.D0.B5.D1.80.D0.B5.D0.BB.D0.B0_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D1.96.D0.B2">Джерела потоків</a></h3>

    <p>Існує багато джерел для потока, включаючи методи генератора в потокових інтерфейсах, колекціях та масивах. Приймемо просту задачу з надання потока цілих від 1 до 5.</p>

    <p>1. Можна використовувати фабричні методи <tt class="prettyprint lang-java">range</tt> чи <tt class="prettyprint lang-java">iterate</tt> інтерфейса <tt class="prettyprint lang-java">IntStream</tt>.</p>

    <pre class="prettyprint lang-java">
    	IntStream.range(1, 6)
    </pre>

    <p>Метод <tt class="prettyprint lang-java">range()</tt> приймає два аргументи: він починає з початкового значення (наданого як перший аргумент) та продовчжує додавати 1 до результату до досягнення кінцевого значення (наданого як другий аргумент та не включаючи його значення). В прикладі надаються значення 1 та 6, отже метод <tt class="prettyprint lang-java">reduce()</tt> генерує потік цілих значень від 1, додає по 1, формуючи 2, 3, 4 та 5, та зупиняється по досягненні 6.</p>

    <pre class="prettyprint lang-java">
    	IntStream.iterate(1, i -&gt; i + 1).limit(5)
    </pre>

    <p>Метод <tt class="prettyprint lang-java">iterate()</tt> приймає два аргументи: початкове значення (як перший аргумент) та ітераційно викликає надану функцію (як другий аргумент), починаючи з початкового значення. Тут перший аргумент це 1, виконується ітераційний виклик <tt class="prettyprint lang-java">i + 1</tt>, який генерує цілі значення 2, 3, 4, 5, ... Це <em>нескінченний потік</em>. Потік обмежується до перших п'яти значень через виклик <tt class="prettyprint lang-java">limit(5)</tt> на цьому нескінченному потоці цілих значень.</p>

    <p>2. Можна використовувати метод <tt class="prettyprint lang-java">stream()</tt> в класі <tt class="prettyprint lang-java">java.util.Arrays</tt> для створення потока з даного масиву:</p>

    <pre class="prettyprint lang-java">
    	Arrays.stream(new int[] {1, 2, 3, 4, 5})
    	Arrays.stream(new Integer[] {1, 2, 3, 4, 5})
    </pre>

    <p>Метод <tt class="prettyprint lang-java">stream()</tt> був доданий до класа <tt class="prettyprint lang-java">Arrays</tt> в Java 8:</p>

    <pre class="prettyprint lang-java">
    // в класі Arrays
    public static IntStream stream(int[] array) { /* повертає потік цілих */ }
    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) { /* повертає потік об'єктів класу T */ }
    </pre>

    <p>Перевантажені версії метода <tt class="prettyprint lang-java">stream()</tt> приймають <tt class="prettyprint lang-java">long[]</tt>, <tt class="prettyprint lang-java">double[]</tt> та <tt class="prettyprint lang-java">T[]</tt>. Оскільки передаються <tt class="prettyprint lang-java">int[]</tt> та <tt class="prettyprint lang-java">Integer[]</tt>, виклики метода <tt class="prettyprint lang-java">stream()</tt>визначаються в <tt class="prettyprint lang-java">stream(int [])</tt> та <tt class="prettyprint lang-java">stream(T[])</tt> відповідно та повертається потік цілих.</p>

    <p>3. Також можна створювати потоки, використовуючи фабрики (factories) та білдери (builders). Метод <tt class="prettyprint lang-java">of()</tt> це фабричний метод інтерфейса <tt class="prettyprint lang-java">Stream</tt>:</p>

    <pre class="prettyprint lang-java">
    	Stream.of(1, 2, 3, 4, 5)
    	Stream.of(new Integer[]{1, 2, 3, 4, 5})
    </pre>

    <p>Перевантажений метод <tt class="prettyprint lang-java">of()</tt> інтерфейса <tt class="prettyprint lang-java">Stream</tt> приймає змінний список аргументів або елементів типу <tt class="prettyprint lang-java">T</tt>. Також, можна використати метод <tt class="prettyprint lang-java">builder()</tt> та побудувати об'єкт <tt class="prettyprint lang-java">Stream</tt>, додаючи один елемент за одним:</p>

    <pre class="prettyprint lang-java">
    	Stream.builder().add(1).add(2).add(3).add(4).add(5).build()
    </pre>

    <p>Цей список варіантів створення потока цілих не вичерпний &ndash; лише для ілюстрації наявності багатьох шляхів отримання потока. Інтерфейс <tt class="prettyprint lang-java">Collection</tt> був доданий з методами <tt class="prettyprint lang-java">stream()</tt> та <tt class="prettyprint lang-java">parallelStream()</tt>. Отже, будь-який об'єкт <tt class="prettyprint lang-java">Collection</tt> є джерелом потока &ndash; треба лише викликати на ньому метод <tt class="prettyprint lang-java">stream()</tt> або <tt class="prettyprint lang-java">parallelStream()</tt>. Наприклад:</p>

    <pre class="prettyprint lang-java">
    	List&lt;String&gt; strings = Arrays.asList("еніки", "беніки", "їли", "вареники");
    	strings.stream().forEach(string -&gt; System.out.println(string));
    </pre>

    <p>В нашому випадку, ми отримуємо потік з об'єкта <tt class="prettyprint lang-java">List&lt;String&gt;</tt> шляхом виклику метода <tt class="prettyprint lang-java">stream()</tt>. В білбіотеці Java є багато інших типів, які повертають потік, наприклад:</p>

    <ul>
    	<li>Метод <tt class="prettyprint lang-java">lines()</tt> в класі <tt class="prettyprint lang-java">java.nio.file.Files</tt></li>
    	<li>Метод <tt class="prettyprint lang-java">splitAsStream()</tt> в класі <tt class="prettyprint lang-java">java.util.regex.Pattern</tt></li>
    	<li>Метод <tt class="prettyprint lang-java">ints()</tt> в класі <tt class="prettyprint lang-java">java.util.Random</tt></li>
    	<li>Метод <tt class="prettyprint lang-java">chars()</tt> в класі <tt class="prettyprint lang-java">java.lang.String</tt></li>
    </ul>

    <p>Декілька підказок по їх використанню.</p>

    <ol>
    	<li>
    		Клас <tt class="prettyprint lang-java">java.nio.file.Files</tt> має метод <tt class="prettyprint lang-java">lines()</tt>, який повертає <tt class="prettyprint lang-java">Stream&lt;String&gt;</tt>. Цей код друкує вміст файла "<tt class="prettyprint lang-java">FileRead.java</tt>" з поточного каталога:

    		<pre class="prettyprint lang-java">
    Files.lines(Paths.get("./FileRead.java")).forEach(System.out::println);
    		</pre>
    	</li>
    	<li>
    		Клас <tt class="prettyprint lang-java">java.util.Pattern</tt> має метод <tt class="prettyprint lang-java">splitAsStream()</tt>, який повертає <tt class="prettyprint lang-java">Stream&lt;String&gt;</tt>. Код нижче розділяє вхідний рядок "java 8 streams" по пробілах та друкує в консолі рядки "java", "8" та "streams".
        
    		<pre class="prettyprint lang-java">
    Pattern.compile(" ").splitAsStream("java 8 streams").forEach(System.out::println);
    		</pre>
    	</li>
    	<li>
    		Клас <tt class="prettyprint lang-java">java.util.Random</tt> має метод <tt class="prettyprint lang-java">ints()</tt>, який повертає <tt class="prettyprint lang-java">IntStream</tt>. Він генерує нескінченний потік випадкових цілих; для обмеження кількості цілих до 5 на цьому потоці викликається <tt class="prettyprint lang-java">limit(5)</tt>.
    		<pre class="prettyprint lang-java">
    new Random().ints().limit(5).forEach(System.out::println);
    		</pre>
    	</li>
    	<li>
    		Клас <tt class="prettyprint lang-java">String</tt> має метод <tt class="prettyprint lang-java">chars()</tt> (вперше представлений в Java 8 в <tt class="prettyprint lang-java">CharSequence</tt> &ndash; інтерфейсі, який реалізує клас <tt class="prettyprint lang-java">String</tt>). Цей метод повертає <tt class="prettyprint lang-java">IntStream</tt> (чому <tt class="prettyprint lang-java">IntStream</tt>? Згадайте, що еквівалентної символьної спеціалізації для <tt class="prettyprint lang-java">Streams</tt> не існує). Код нижче викликає метод <tt class="prettyprint lang-java">sorted()</tt> на цьому потоці, тож елементи потоку сортуються по зростанню. Оскільки це потік цілих, цей код використовує "<tt class="prettyprint lang-java">%c</tt>" для явної конвертації з <tt class="prettyprint lang-java">int</tt> до <tt class="prettyprint lang-java">char</tt>.
    		<pre class="prettyprint lang-java">
    "привіт".chars().sorted().forEach(ch -&gt; System.out.printf("%c ", ch));
    // друкує в и п р т і
    		</pre>
    	</li>
    </ol>

    <p>В цих прикладах такі проміжні операції як <tt class="prettyprint lang-java">limit()</tt> та <tt class="prettyprint lang-java">sorted()</tt> нам вже знайомі. Поговоримо про такі проміжні операції детальніше.</p>

    <h4><a name="D0.9F.D1.80.D0.BE.D0.BC.D1.96.D0.B6.D0.BD.D1.96_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D1.96.D1.97">Проміжні операції</a></h4>

    <p>Проміжні операції перетворюють елементи потока. <a href="#c04t05">Таблиця 4-5</a> перелічує деякі важливі проміжні операції в <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>. Інші проміжні операції, такі як <tt class="prettyprint lang-java">flatMap()</tt> та її варіанти, обговоримо в Главі 6, присвяченій Streams API.</p>

    <table id="c04t05" border="1">
    	<caption>Таблиця 4-5. Важливі проміжні операції в інтерфейсі Stream</caption>
    	<tr><th>Метод</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; check)</tt></td><td>Видаляє елементи, для яких предикат перевірки повертає <tt class="prettyprint lang-java">false</tt>.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; transform)</tt></td><td>Застосовує функцію <tt class="prettyprint lang-java">transform()</tt> до кожного елемента потоку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Stream&lt;T&gt; distinct()</tt></td><td>Видаляє з потока дублюючі елементи; викликає метод <tt class="prettyprint lang-java">equals()</tt> для визначення, чи елемент повторюється в потоці.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Stream&lt;T&gt; sorted()<br/>
    		Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; compare)</tt></td><td>Сортує елементи в природньому порядку. Перевантажена версія приймає <tt class="prettyprint lang-java">Comparator</tt> &ndash; можна передати лямбда функцію.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; consume)</tt></td><td>Повертає ті самі елементи потока, але також виконує наданий як <tt class="prettyprint lang-java">consume</tt> лямбда вираз над елементами.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Stream&lt;T&gt; limit(long size)</tt></td><td>Видаляє елементи потоку, якщо їх більше наданої кількості.</td></tr>
    </table>

    <p>Всі проміжні операції в цій таблиці повертають <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt> в якості результата.</p>

    <p>Проміжні операції не обов'язкові; немає необхідності використовувати їх в потоковому конвейєрі. Простий приклад:</p>

    <pre class="prettyprint lang-java">
    Stream.of(1, 2, 3, 4, 5).count();
    </pre>

    <p>Цей код повертає значення <tt class="prettyprint lang-java">5</tt>. Метод <tt class="prettyprint lang-java">Stream.of()</tt> є джерелом потока, а метод <tt class="prettyprint lang-java">count()</tt> є кінцевою операцією. Метод <tt class="prettyprint lang-java">count()</tt> повертає кількість елементів потока.</p>

    <p>Представимо приміжну операцію в цьому потоковому конвейєрі:</p>

    <pre class="prettyprint lang-java">
    Stream.of(1, 2, 3, 4, 5).map(i -&gt; i * i).count();
    </pre>

    <p>Операція <tt class="prettyprint lang-java">map()</tt> застосовує до елементів потока надану як аргумент функцію. В даному випадку, вона отримує квадрат елементів потока. Цей код також повертає значення <tt class="prettyprint lang-java">5</tt>. Як можна перевірити правильність зстосування метода <tt class="prettyprint lang-java">map()</tt> в цьому коді? Для цього можна використати метод <tt class="prettyprint lang-java">peek()</tt>:</p>

    <pre class="prettyprint lang-java">
    Stream.of(1, 2, 3, 4, 5).map(i -&gt; i * i).peek(i -&gt; System.out.printf("%d ", i)).count();
    </pre>

    <p>Цей код друкує</p>

    <pre>1 4 9 16 25</pre>

    <p>Цей приклад також ілюструє, як проміжні операції можуть поєднуватися. Це можливе тому що проміжні операції повертають потоки.</p>

    <p>Тепер додамо метод <tt class="prettyprint lang-java">peek()</tt> перед викликом метода <tt class="prettyprint lang-java">map()</tt> для розуміння роботи:</p>

    <pre id="c04s039" class="prettyprint lang-java">
    Stream.of(1, 2, 3, 4, 5)
                    .peek(i -&gt; System.out.printf("%d ", i))
                    .map(i -&gt; i * i)
                    .peek(i -&gt; System.out.printf("%d ", i))
                    .count();
    </pre>

    <p>Цей код друкує</p>

    <pre>1 1 2 4 3 9 4 16 5 25</pre>

    <p>З цього вивода видно, що конвейєр обробляє елементи один за одним. Кожен елемент відображаєся в значення свого квадрата. Метод <tt class="prettyprint lang-java">peek()</tt> допомагає зрозуміти опрацювання елементів потока.</p>

    <hr/>
    <p>Метод <tt class="prettyprint lang-java">peek()</tt> призначений в основному для цілей вібладки. Він допомагає зрозуміти, як елементи перетворюються в конвейєрі. <em>НЕ</em> варто використовувати його в промисловому коді.</p>
    <hr/>

    <h2><a name="D0.A4.D1.96.D0.BB.D1.8C.D1.82.D1.80.D1.83.D0.B2.D0.B0.D0.BD.D0.BD.D1.8F_.D0.BA.D0.BE.D0.BB.D0.B5.D0.BA.D1.86.D1.96.D1.97">Фільтрування колекції</a></h2>

    <p>Цілі</p>

    <ul><li>Фільтрувати колекцію з використанням лямбда виразів</li></ul>

    <p>Метод <tt class="prettyprint lang-java">filter()</tt> в інтерфейсі <tt class="prettyprint lang-java">Stream</tt> використовується для видалення елементів, які не відповідають наданій умові. Нижче приклад використання метода <tt class="prettyprint lang-java">filter()</tt> інтерфейса <tt class="prettyprint lang-java">Stream</tt> для видалення непарних цілих (<a href="#c04l20">Лістинг 4-20</a>).</p>

    <pre id="c04l20" class="prettyprint lang-java">
    // Лістинг 4-20. EvenNumbers.java
    import java.util.stream.IntStream;

    class EvenNumbers {
        public static void main(String []args) {
            IntStream.rangeClosed(0, 10)
                    .filter(i -&gt; (i % 2) == 0)
                    .forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує</p>

    <pre>
    0
    2
    4
    6
    8
    10
    </pre>

    <p>В цьому прикладі використовується клас <tt class="prettyprint lang-java">IntStream</tt> &ndash; одна із спеціалізацій <tt class="prettyprint lang-java">Stream</tt> для <tt class="prettyprint lang-java">int</tt>-ів. Метод <tt class="prettyprint lang-java">rangeClosed(startValue, endValueInclusiveOfEnd)</tt> генерує послідовність цілих, починаючи з <tt class="prettyprint lang-java">startValue</tt> до (включаючи) <tt class="prettyprint lang-java">endValueInclusiveOfEnd</tt>. Тут <tt class="prettyprint lang-java">rangeClosed(0, 10)</tt> повертає цілі значення <tt class="prettyprint lang-java">0, 1, 2, ... , 9, 10</tt> (зверніть увагу на <tt class="prettyprint lang-java">10</tt>). Існує схожий метод <tt class="prettyprint lang-java">range(startValue, endValueExclusiveOfEnd)</tt>, який генерує послідовність цілих, починаючи з <tt class="prettyprint lang-java">startValue</tt> до (виключно) <tt class="prettyprint lang-java">endValueExclusiveOfEnd</tt>.</p>

    <p>До результата метода <tt class="prettyprint lang-java">rangeClosed()</tt> застосовується метод <tt class="prettyprint lang-java">filter()</tt>. Сигнатура цього метода <tt class="prettyprint lang-java">filter()</tt>:</p>

    <pre class="prettyprint lang-java">IntStream filter(IntPredicate predicate)</pre>

    <p>Метод <tt class="prettyprint lang-java">filter()</tt> застосовує наданий предикат для визначення, чи має елемент бути включеним в результуючий потік, або отфільтрованим. Функціональний інтерфейс <tt class="prettyprint lang-java">java.util.function.IntPredicate</tt> має функцію з наступною сигнатурою:</p>

    <pre class="prettyprint lang-java">boolean test(int value);</pre>

    <p>В прикладі передається лямбда функція <tt class="prettyprint lang-java">i -> (i % 2) == 0</tt> для відповідності функціональному інтерфейсу <tt class="prettyprint lang-java">IntPredicate</tt>, який повертає булеве значення. Якщо обробка поточного елемента повертає <tt class="prettyprint lang-java">true</tt> (в даному випадку, для парного), то він стає частиною потока.</p>

    <p>Також можна визначити функцію з типом функціонального інтерфейса <tt class="prettyprint lang-java">IntPredicate</tt> та передати її до фільтра.</p>

    <pre class="prettyprint lang-java">
    // можна визначити цю статичну функцію всередині класу EvenNumbers
    public static boolean isEven(int i) {
    	return (i % 2) == 0;
    }
    </pre>

    <p>Тепер, замість наання лямбда функції в метод <tt class="prettyprint lang-java">filter()</tt>, можна передати посилання на метод: <tt class="prettyprint lang-java">filter(EvenNumbers::isEven)</tt>.</p>

    <p>Часто методи <tt class="prettyprint lang-java">map()</tt> та <tt class="prettyprint lang-java">filter()</tt>використовуються разом. Наприклад, наступна програма друкує квадрати парних чисел (<a href="#c04l21">Лістинг 4-21</a>).</p>

    <pre id="c04l21" class="prettyprint lang-java">
    // Лістинг 4-21. EvenSquares.java
    import java.util.stream.IntStream;

    class EvenSquares {
        public static void main(String []args) {
            IntStream.rangeClosed(0, 10)
                    .map(i -&gt; i * i)
                    .filter(i -&gt; (i % 2) == 0)
                    .forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує</p>

    <pre>
    0
    4
    16
    36
    64
    100
    </pre>

    <p>Однак, цей код виконує зайві обчислення квадратів для непарних чисел (квадрати непарних завжди непарні). Отже, можна змінити порядок операцій <tt class="prettyprint lang-java">map</tt> та <tt class="prettyprint lang-java">filter</tt>:</p>

    <pre class="prettyprint lang-java">
    IntStream.rangeClosed(0, 10)
    		.filter(i -> (i % 2) == 0)
    		.map(i -> i * i) // виклик map ПІСЛЯ виклику filter
    		.forEach(System.out::println);
    </pre>

    <p>Вивід той самий. Цей простий приклад показує, що інколи можна міняти порядок проміжних операцій без зміні поведінки.</p>

    <h3><a name="D0.97.D0.B0.D0.BA.D0.BB.D1.8E.D1.87.D0.BD.D1.96_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D1.96.D1.97">Заключні операції</a></h3>

    <p>В кінці конвейєра траба надавати заключну операцію. Така заключна операція зазвичай надає результат, як в разі методів <tt class="prettyprint lang-java">sum()</tt>, <tt class="prettyprint lang-java">min()</tt>, <tt class="prettyprint lang-java">max()</tt> чи <tt class="prettyprint lang-java">average()</tt> в <tt class="prettyprint lang-java">IntStream</tt>. Заключна операція також може виконувати інші дії, наприклад, акумуляція елементів методами <tt class="prettyprint lang-java">reduce()</tt> чи <tt class="prettyprint lang-java">collect()</tt>, або просто виконувати дію, як у виклику метода <tt class="prettyprint lang-java">forEach()</tt>. <a href="#c04t06">Таблиця 4-6</a> перелічує деякі важливі заключні операції в <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>.</p>

    <table id="c04t06" border="1">
    	<caption>Таблиця 4-6. Важливі заключні операції в інтерфейсі Stream</caption>
    	<tr><th>Метод</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">void forEach(Consumer&lt;? super T&gt; action)</tt></td><td>Викликає <tt class="prettyprint lang-java">action</tt> для кожного елемента потока.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Object[] toArray()</tt></td><td>Повертає масив <tt class="prettyprint lang-java">Object</tt> з елементами потока.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Optional&lt;T&gt; min(Comparator&lt;? super T&gt; compare)</tt></td><td>Повертає мінімальне значення в потоці (порівняння об'єктів з використанням наданої функції <tt class="prettyprint lang-java">compare</tt>).</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Optional&lt;T&gt; max(Comparator&lt;? super T&gt; compare)</tt></td><td>Повертає максимальне значення в потоці (порівняння об'єктів з використанням наданої функції <tt class="prettyprint lang-java">compare</tt>).</td></tr>
    	<tr><td><tt class="prettyprint lang-java">long count()</tt></td><td>Повертає кількість елементів в потоці.</td></tr>
    </table>

    <p>Існує багато заключних операцій, таких як методи <tt class="prettyprint lang-java">reduce()</tt>, <tt class="prettyprint lang-java">collect()</tt>, <tt class="prettyprint lang-java">findFirst()</tt>, <tt class="prettyprint lang-java">findAny()</tt>, <tt class="prettyprint lang-java">anyMatch()</tt>, <tt class="prettyprint lang-java">allMatch()</tt> та <tt class="prettyprint lang-java">noneMatch()</tt>. Обговоримо ці методи (а також згаданий в таблиці <tt class="prettyprint lang-java">Optional&lt;&gt;</tt>) пізніше, в Главі 6 про Stream API. Далі, <tt class="prettyprint lang-java">IntStream</tt>, <tt class="prettyprint lang-java">LongStream</tt> та <tt class="prettyprint lang-java">DoubleStream</tt> мають такі методи як <tt class="prettyprint lang-java">sum()</tt>, <tt class="prettyprint lang-java">min()</tt>, <tt class="prettyprint lang-java">max()</tt> та <tt class="prettyprint lang-java">average()</tt>, які оперують потоками <tt class="prettyprint lang-java">int</tt>-ів, <tt class="prettyprint lang-java">long</tt>-ів та <tt class="prettyprint lang-java">double</tt>-ів відповідно.</p>

    <p>Нижче приклад використання метода <tt class="prettyprint lang-java">toArray()</tt> в інтерфейсі <tt class="prettyprint lang-java">Stream</tt>:</p>

    <pre class="prettyprint lang-java">
    Object [] words = Pattern.compile(" ").splitAsStream("1 2 3 4 5").toArray();
    System.out.println(Arrays.stream(words).mapToInt(str -&gt; Integer.valueOf((String)str)).sum());
    </pre>

    <p>Ця програма друкує:</p>

    <pre>15</pre>

    <p>В цій програмі є рядок <tt class="prettyprint lang-java">"1 2 3 4 5"</tt>, а <tt class="prettyprint lang-java">splitAsStream()</tt> повертає потік <tt class="prettyprint lang-java">Strings</tt>-ів. Цей потік <tt class="prettyprint lang-java">String</tt>-ів перетворюється на масив <tt class="prettyprint lang-java">Object</tt>-ів під назвою <tt class="prettyprint lang-java">words</tt>; потім масив перетворюється назад в потік через виклик <tt class="prettyprint lang-java">Arrays.stream(words)</tt> (лише для ілюстрації можливостей). Потім кожен <tt class="prettyprint lang-java">Object</tt> пвідображається на <tt class="prettyprint lang-java">String</tt>, а втім на ціле значення. Наприкінці викликається заключна операція <tt class="prettyprint lang-java">sum()</tt> для отримання суми цілих 15.</p>

    <p>По завершенню заключної операції потік вважається "спожитим". При спробі "використати" потік знов виникне виняток <tt class="prettyprint lang-java">IllegalStateException</tt> (<a href="#c04l22">Лістинг 4-22</a>).</p>

    <pre id="c04l22" class="prettyprint lang-java">
    // Лістинг 4-22. StreamReuse.java
    import java.util.stream.IntStream;

    public class StreamReuse {
        public static void main(String []args) {
            IntStream chars = "біоінженерія".chars();
            System.out.println(chars.count());
            chars.distinct().sorted().forEach(ch -&gt; System.out.printf("%c ", ch));
        }
    }
    </pre>

    <p>Змінна <tt class="prettyprint lang-java">chars</tt> вказує на потік, створений з рядка <tt class="prettyprint lang-java">"біоінженерія"</tt>. Після виконання <tt class="prettyprint lang-java">chars.count()</tt> потік стає "спожитим". Чому? Оскільки метод <tt class="prettyprint lang-java">count()</tt> є термінальною операцією. А оскільки в наступному операторі виконується спроба знов задіяти потік, програма завершується з помилкою <tt class="prettyprint lang-java">IllegalStateException</tt>.</p>

    <h2><a name="D0.9F.D1.96.D0.B4.D1.81.D1.83.D0.BC.D0.BA.D0.B8">Підсумки</a></h2>

    <p>Ключові моменти про узагальнення та колекції.</p>

    <b>Створювати та використовувати загальнений клас</b>

    <ul>
    	<li>Узагальнення забезпечують відстеження компілятором спроби додати елементи типів, відмінних від тих, що вказані. Отже, узагальнення пропонують загальну реалізацію з безпекою типів.</li>

    	<li>В Java 7 введено <em>діамантовий</em> синтаксис, в якому параметри типів (після оператора <tt class="prettyprint lang-java">new</tt> та назви класа) можна опустити. Компілятор використає типи з декларативної частини.</li>

    	<li>Узагальнення не коваріантні. Тобто, з ними не працює підтипування: не можна призначати похідний узагальнений типовий параметр параметру базового типа.</li>

    	<li>Уникайте змішування необроблених та узагальнених типів. Або треба забезпечувати безпеку типів вручну.</li>

    	<li>Знак питання &lt;?&gt; вказує невідомий тип в узагальненнях та відомий як підстановочний символ. Наприклад, <tt class="prettyprint lang-java">List&lt;?&gt;</tt> посилається на список невідомих.</li>
    </ul>

    <b>Створювати та використовувати об'єкти ArrayList, TreeSet, TreeMap та ArrayDeque</b>

    <ul>
    	<li>Терміни Collection, Collections та колекція різні. <tt class="prettyprint lang-java">Collection</tt> &ndash; <tt class="prettyprint lang-java">java.util.Collection&lt;E&gt;</tt> &ndash; це кореневий інтерфейс в ієрархії колекцій. <tt class="prettyprint lang-java">Collections</tt>  &ndash; <tt class="prettyprint lang-java">java.util.Collections</tt> &ndash; службовий клас, який містить лише статичні методи. Загальний термін <em>колекція</em> стосується контейнерів на кшталт карти, стека чи черги.</li>

    	<li>Не можна додавати чи видаляти елементи списка, який повертається методом <tt class="prettyprint lang-java">Arrays.asList()</tt>. Але можна змінювати елементи в <tt class="prettyprint lang-java">List</tt>, який повертається, та ці зміни відображаються на масиві.</li>

    	<li><tt class="prettyprint lang-java">HashSet</tt> призначений для швидкої вставки та отримання елементів; він не підтримує порядок сортування елементів. <tt class="prettyprint lang-java">TreeSet</tt> зберігає елементи в порядку сортування (та він реалізує інтерфейс <tt class="prettyprint lang-java">SortedSet</tt>).</li>

    	<li><tt class="prettyprint lang-java">HashMap</tt> всередині використовує хеш-таблицю. В <tt class="prettyprint lang-java">HashMap</tt> пошук (чи вибірка елемента) швидка операція. Однак, <tt class="prettyprint lang-java">HashMap</tt> не запам'ятовує порядок вставки елементів, не зберігає їх в порядку сортування. На відміну від <tt class="prettyprint lang-java">HashMap</tt>, <tt class="prettyprint lang-java">TreeMap</tt> зберігає елементи в порядку сортування (а саме, відсортованими за ключами). Тож, пошук чи вставка трохи повільніші в порівнянні з <tt class="prettyprint lang-java">HashMap</tt>.</li>

    	<li><tt class="prettyprint lang-java">Deque</tt> (черга з двома кінцями) це структура даних, яка дозволяє вставку та видалення елементів з обох кінців. Є три певні (конкретні) реалізації інтерфейса <tt class="prettyprint lang-java">Deque</tt>: <tt class="prettyprint lang-java">LinkedList</tt>, <tt class="prettyprint lang-java">ArrayDeque</tt> та <tt class="prettyprint lang-java">LinkedBlockingDeque</tt>.</li>

    	<li>Різниця між <tt class="prettyprint lang-java">ArrayList</tt> та <tt class="prettyprint lang-java">ArrayDeque</tt> полягає в тому, що в список-масив можна додавати елемент в будь-яку позицію з використанням індекса; а в масив-чергу - тільки в початок чи в кінець.</li>
    </ul>

    <b>Використовувати інтерфейси java.util.Comparator та java.lang.Comparable</b>

    <ul>
    	<li>Реалізуйте інтерфейс <tt class="prettyprint lang-java">Comparable</tt> для класів, де можливий природній порядок. При потребі в порівнянні двох об'єктів в інший, чим природній порядок, спосіб, але якщо для класа не існує природнього порядка, треба створити окремий клас, які реалізують інтерфейс <tt class="prettyprint lang-java">Comparator</tt>. Також цей інтерфейс стане у нагоді, якщо є декілька шляхів визначення порядка.</li>
    </ul>

    <b>Потоки та фільтри колекцій</b>

    <ul>
    	<li>Потоковий API надано в пакеті <tt class="prettyprint lang-java">java.util.stream</tt>. Основний тип і цьому пакеті це інтерфейс <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>, який є потоком об'єктних посилань. <tt class="prettyprint lang-java">IntStream</tt>, <tt class="prettyprint lang-java">LongStream</tt> та <tt class="prettyprint lang-java">DoubleStream</tt> це потоки для примітивних типів <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> відповідно.</li>

    	<li>Потік це послідовність елементів. В Java 8 інтерфейс <tt class="prettyprint lang-java">Collection</tt> має два методи <tt class="prettyprint lang-java">stream()</tt> та <tt class="prettyprint lang-java">parallelStream()</tt>, з яких можна отримати віповідно послідновниі або паралельні потоки.</li>
    </ul>

    <b>Ітерування з використанням методів forEach Streams та List</b>

    <ul>
    	<li>В Java 8 відбувається зміщення від зовнішнього до внутрішнього ітерування. Це <em>головна</em> зміна Java 8 в підході до функціонального програмування.</li>

    	<li>Інтерфейси <tt class="prettyprint lang-java">Stream</tt> та <tt class="prettyprint lang-java">Iterable</tt> визначають метод <tt class="prettyprint lang-java">forEach()</tt>. Метод <tt class="prettyprint lang-java">forEach()</tt> підтримує внутрішнє ітерування.</li>
    </ul>

    <b>Описувати інтерфейс Stream та потоковий конвейєр</b>

    <ul>
    	<li>Потокові операції моуть бути поєднані в "потоковий конвейєр".</li>

    	<li>Потоковий конвейєр має початок, середину та кінець: <em>джерело</em> (формує потік), <em>проміжні операції</em> (необов'язкові поєднані операції) та <em>кінцеву операцію</em> (формує результат).</li>

    	<li>Кінцева операція може формувати результат, накопичувати елементи потока або просто виконати дію.</li>

    	<li>Потік може бути використаний лише один раз. Спроба повторного використання (наприклад, через виклик проміжної або кінцевої операцій) призведе до <tt class="prettyprint lang-java">IllegalStateException</tt>.</li>
    </ul>

    <b>Фільтрація колекції з використанням лямбда виразів</b>

    <ul>
    	<li>Метод <tt class="prettyprint lang-java">filter()</tt> в інтерфейсі <tt class="prettyprint lang-java">Stream</tt> використовується для видалення елементів, які не відповідають наданій умові.</li>
    </ul>

    <b>Використовувати посилання на методи з потоками</b>

    <ul>
    	<li>Оскільки лямбда вирази лише маршрутизують надані аргументи, замість них можна використовувати посилання на методи.</li>

    	<li>Оскільки посилання на методи слугують як спосіб маршрутизації аргументів, часто зручно (для більш стислого кода) використовувати їх замість еквівалентних лямбда виразів.</li>
    </ul>


    <h1>Лекція 5</h1>
    <h1>Вбудовані функціональні лямбда інтерфейси</h1>
    
    <p>Цілі</p>
    
    <ul>
        <li>Використання таких вбудованих інтерфейсів пакету java.util.function як Predicate, Consumer, Function та Supplier</li>
        <li>Розробка коду, який використовує примітивні версії функціональних інтерфейсів</li>
        <li>Розробка коду, який використовує бінарні версії функціональних інтерфейсів</li>
        <li>Розробка коду, який використовує інтерфейс UnaryOperator</li>
    </ul>
    
    <p>Пакет <tt class="prettyprint lang-java">java.util.function</tt> містить багато вбудованих інтерфейсів. Вони використовються іншими вакетами бібліотеки Java library (особливо <tt class="prettyprint lang-java">java.util.stream</tt>). Для екзамену OCPJP 8 потрібно добре знатися на використанні ключових інтерфейсів цього пакету.</p>
    
    <p>Як обговорювалося раніше (в Главі 3), функціональний інтерфейс оголошує єдиний абстрактний метод (але до цього він може мати скільки завгодно статичних методів або методів по замовчуванню).Функціональні інтерфейси корисні для створення лямбда виразів. Пакет <tt class="prettyprint lang-java">java.util.function</tt> цілком складається з функціональних інтерфейсів.</p>
    
    <hr/>
    <p>Перед визначенням власного функціонального інтерфейсу зверніть увагу на вже доступні функціональні інтерфейси, визначені в пакеті <tt class="prettyprint lang-java">java.util.function</tt>. Лише якщо сигнатура потрібної лямбда функції відсутня в будь-якому з наданих бібліотекою функціональних інтерфейсів, можна визначати власні функціональні інтерфейси.</p>
    <hr/>
    
    <h1>Використання вбудованих функціональних інтерфейсів</h1>
    
    <p>В цьому розділі обговоримо основні вбудовані інтерфейси, які включено до пакету <tt class="prettyprint lang-java">java.util.function</tt>: <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt>. В <a href="#c05t01">таблиці 5-1</a> та на <a href="#c05i01">рисунку 5-1</a> надано огляд цих функціональних інтерфейсів.</p>
    
    <table id="c05t01" border="1">
        <caption>Таблиця 5-1. Ключові функціональні інтерфейси пакету java.util.function</caption>
        <tr><th>Функціональний інтерфейс</th><th>Опис</th><th>Загальне використання</th></tr>
        <tr><td><tt class="prettyprint lang-java">Predicate&lt;T&gt;</tt></td><td>Перевіряє умову та повертає булеве значення</td><td>В методі <tt class="prettyprint lang-java">filter()</tt> класу <tt class="prettyprint lang-java">java.util.stream.Stream</tt>, який використовується для видалення елементів, які не відповідають наданій як аргумент умові (чи предикату).</td></tr>
        <tr><td><tt class="prettyprint lang-java">Consumer&lt;T&gt;</tt></td><td>Операція, яка приймає аргумент, яле нічого не повертає</td><td>В методі <tt class="prettyprint lang-java">forEach()</tt> в колекціях та класі <tt class="prettyprint lang-java">java.util.stream.Stream</tt>; цей метод використовується для проходження по всіх елементах колекції чи потоку.</td></tr>
        <tr><td><tt class="prettyprint lang-java">Function&lt;T, R&gt;</tt></td><td>Функції, які приймають аргумент та повертають результат</td><td>В методі <tt class="prettyprint lang-java">map()</tt> класу <tt class="prettyprint lang-java">java.util.stream.Stream</tt> для перетворення чи обробки наданого значення та повернення результату.</td></tr>
        <tr><td><tt class="prettyprint lang-java">Supplier&lt;T&gt;</tt></td><td>Операція, яка повертає значення за викликом (значення, що повертається, може бути тим самим чи відрізнятися)</td><td>В методі <tt class="prettyprint lang-java">generate()</tt> класу <tt class="prettyprint lang-java">java.util.stream.Stream</tt> для створення бескінченного потоку елементів.</td></tr>
    </table>
    
    <p><img id="c05i01" src="img/c05i01.png"/><br/>
    Рисунок 5-1. Оголошення абстрактних методів в ключових функціональних інтерфейсах пакету <tt class="prettyprint lang-java">java.util.function</tt></p>
    
    <h2>Інтерфейс Predicate</h2>
    
    <p>В коді часто потрібні функції, які перевіряють якусь умову та повертають булеве значення. Розглянемо фрагмент коду:</p>
    
    <pre class="prettyprint lang-java">
    Stream.of("Всім", "привіт")
        .filter(str -&gt; str.startsWith("п"))
        .forEach(System.out::println);
    </pre>
    
    <p>Цей фрагмент коду друкує на консоль лише "привіт". Метод <tt class="prettyprint lang-java">filter()</tt> повертає <tt class="prettyprint lang-java">true</tt> лише якщо надана стрічка починається з "<tt class="prettyprint lang-java">п</tt>", отже він відкидає стрічку "<tt class="prettyprint lang-java">Всім</tt>" з потоку з-за того, що вона не починається з "<tt class="prettyprint lang-java">п</tt>". В цьому коді метод <tt class="prettyprint lang-java">filter()</tt> приймає аргумент <tt class="prettyprint lang-java">Predicate</tt>. Функціональний інтерфейс <tt class="prettyprint lang-java">Predicate</tt>:</p>
    
    <pre class="prettyprint lang-java">
    @FunctionalInterface
    public interface Predicate&lt;T&gt; {
        boolean test(T t);
        // інші методи
    }
    </pre>
    
    <p>Абстрактний метод <tt class="prettyprint lang-java">test()</tt>, який приймає аргумент та повертає <tt class="prettyprint lang-java">true</tt> або <tt class="prettyprint lang-java">false</tt> (<a href="#c05i02">Рисунок 5-2</a>).</p>
    
    <p><img id ="c05i02" src="img/c05i02.png"/><br/>
    Рисунок 5-2. Predicate&lt;T&gt; приймає аргумент типу <tt class="prettyprint lang-java">T</tt> та повертає булеве значення</p>
    
    <hr/>
    <p><tt class="prettyprint lang-java">Predicate&lt;T&gt;</tt> "підтверджує" щось як <tt class="prettyprint lang-java">true</tt> або <tt class="prettyprint lang-java">false</tt>: він приймає аргумент типу <tt class="prettyprint lang-java">T</tt> та повертає булеве значення. Можна викликати метод <tt class="prettyprint lang-java">test()</tt> об'єкту <tt class="prettyprint lang-java">Predicate</tt>.</p>
    <hr/>
    
    <p>Цей функціональний інтерфейс також визначає методи <tt class="prettyprint lang-java">and()</tt> та <tt class="prettyprint lang-java">or()</tt>, які приймають <tt class="prettyprint lang-java">Predicate</tt> та повертають <tt class="prettyprint lang-java">Predicate</tt>. Ці методи поводяться схоже на оператори <tt class="prettyprint lang-java">&amp;&amp;</tt> та <tt class="prettyprint lang-java">||</tt>. Метод <tt class="prettyprint lang-java">negate()</tt> повертає <tt class="prettyprint lang-java">Predicate</tt>, а поводиться ві схоже на оператор <tt class="prettyprint lang-java">!</tt>. Навіщо вони? Нижче наведено програму, яка ілюструє використання методу <tt class="prettyprint lang-java">and()</tt> інтерфейсу <tt class="prettyprint lang-java">Predicate</tt>: (<a href="#Listing0501">Лістинг 5-1</a>).</p>
    
    <pre id="Listing0501" class="prettyprint lang-java">
    // Лістинг 5-1. PredicateTest.java
    import java.util.function.Predicate;
    
    public class PredicateTest {
        public static void main(String []args) {
            Predicate&lt;String&gt; nullCheck = arg -&gt; arg != null;
            Predicate&lt;String&gt; emptyCheck = arg -&gt; arg.length() &gt; 0;
            Predicate&lt;String&gt; nullAndEmptyCheck = nullCheck.and(emptyCheck);
            String helloStr = "привіт";
            System.out.println(nullAndEmptyCheck.test(helloStr));
    
            String nullStr = null;
            System.out.println(nullAndEmptyCheck.test(nullStr));
        }
    }
    </pre>
    
    <p>Ця програма друкує:</p>
    
    <pre class="prettyprint lang-java">
    true
    false
    </pre>
    
    <p>В цій програмі об'єкт <tt class="prettyprint lang-java">nullCheck</tt> є <tt class="prettyprint lang-java">Predicate</tt>, який повертає <tt class="prettyprint lang-java">true</tt>, якщо наданий аргумент  <tt class="prettyprint lang-java">String</tt> не <tt class="prettyprint lang-java">null</tt>. Предикат <tt class="prettyprint lang-java">emptyCheck</tt> повертає <tt class="prettyprint lang-java">true</tt>, якщо надана стрічка не порожня. Предикат <tt class="prettyprint lang-java">nullAndEmptyCheck</tt> комбінує предикати <tt class="prettyprint lang-java">nullCheck</tt> та <tt class="prettyprint lang-java">emptyCheck</tt> з використанням методу по замовчуванню <tt class="prettyprint lang-java">and()</tt>, який надається в <tt class="prettyprint lang-java">Predicate</tt>. Оскільки <tt class="prettyprint lang-java">helloStr</tt> <b>вказує</b> на стрічку "<tt class="prettyprint lang-java">привіт</tt>" в першому виклику <tt class="prettyprint lang-java">nullAndEmptyCheck.test(helloStr)</tt>та ця стрічка не порожня, він повертає <tt class="prettyprint lang-java">true</tt>. Однак, в наступному виклику <tt class="prettyprint lang-java">nullStr</tt> є <tt class="prettyprint lang-java">null</tt>, отже виклик <tt class="prettyprint lang-java">nullAndEmptyCheck.test(nullStr)</tt> повертає <tt class="prettyprint lang-java">false</tt>.</p>
    
    <p>Наступний фрагмент коду є іншим прикладом використання <tt class="prettyprint lang-java">Predicate</tt>-ів з вживанням методу <tt class="prettyprint lang-java">removeIf()</tt>, який було додано в інтерфейс <tt class="prettyprint lang-java">Collection</tt> в Java 8 (<a href="#Listing0502">Лістинг 5-2</a>).</p>
    
    <pre id="Listing0502" class="prettyprint lang-java">
    // Лістинг 5-2. RemoveIfMethod.java
    import java.util.List;
    import java.util.ArrayList;
    
    public class RemoveIfMethod {
        public static void main(String []args) {
            List&lt;String&gt; greeting = new ArrayList&lt;&gt;();
            greeting.add("привіт");
            greeting.add("всім");
            
            greeting.removeIf(str -&gt; !str.startsWith("п"));
            greeting.forEach(System.out::println);
        }
    }
    </pre>
    
    
    <p>Він друкує на консоль "привіт". Метод по замовчуванню <tt class="prettyprint lang-java">removeIf()</tt> визначений в інтерфейсі <tt class="prettyprint lang-java">Collection</tt>  (супер-інтерфейс для <tt class="prettyprint lang-java">ArrayList</tt>) приймає аргумент <tt class="prettyprint lang-java">Predicate</tt>:</p>
    
    <pre class="prettyprint lang-java">
    default boolean removeIf(Predicate&lt;? super E&gt; filter)
    </pre>
    
    <p>У виклику методу <tt class="prettyprint lang-java">removeIf()</tt> передається лямбда вираз, який відповідає абстрактному методу <tt class="prettyprint lang-java">boolean test(T t)</tt>, оголошеному в інтерфейсі <tt class="prettyprint lang-java">Predicate</tt>:</p>
    
    <pre class="prettyprint lang-java">
    greeting.removeIf(str -&gt; !str.startsWith("п"));
    </pre>
    
    <p>В результаті стрічка "<tt class="prettyprint lang-java">всім</tt>" видаляється з об'єкту <tt class="prettyprint lang-java">ArrayList</tt> та друкується на консолі лише "<tt class="prettyprint lang-java">привіт</tt>". В цьому коді використовується оператор <tt class="prettyprint lang-java">!</tt> operator. Замість цього можливе використання еквівалентного методу <tt class="prettyprint lang-java">negate()</tt>, визначеного в <tt class="prettyprint lang-java">Predicate</tt>:</p>
    
    <pre class="prettyprint lang-java">
    greeting.removeIf(((Predicate&lt;String&gt;) str -&gt; str.startsWith("п")).negate());
    </pre>
    
    <p>При виконанні програми з <a href="#Listing0502">Лістингу 5.2</a> з такими змінами вона надрукує "<tt class="prettyprint lang-java">привіт</tt>". Зауважте, що в цьому виразі виконано явне приведення типів (explicit typecast) (до <tt class="prettyprint lang-java">Predicate&lt;String&gt;</tt>). Без цього явного приведення типів &ndash; як в <tt class="prettyprint lang-java">((str -&gt; str.startsWith("п")).negate())</tt> &ndash; компілятор не зможе вивести тип для визначення відповідного функціонального інтерфейсу та сповістить про помилку.</p>
    
    <h2>Інтерфейс Consumer</h2>
    
    <p>Існує багато методів, які приймають один аргумент, виконують деякі операції з його використанням, але нічого не повертають &ndash; вони називаються методами споживання (consumer methods).</p>
    
    <pre class="prettyprint lang-java">
    Stream.of("привіт", "всім")
        .forEach(System.out::println);
    </pre>
    
    <p>Цей фрагмент коду друкує слова "<tt class="prettyprint lang-java">привіт</tt>" та "<tt class="prettyprint lang-java">всім</tt>", які є частиною потоку; робить він це з використанням методу <tt class="prettyprint lang-java">forEach()</tt>, який визначено в інтерфейсі <tt class="prettyprint lang-java">Stream</tt>. Цей метод оголошено в інтерфейсі <tt class="prettyprint lang-java">java.util.stream.Stream</tt> так:</p>
    
    <pre class="prettyprint lang-java">
    void forEach(Consumer&lt;? super T&gt; action);
    </pre>
    
    <p><tt class="prettyprint lang-java">forEach()</tt> приймає як аргумент екземпляр <tt class="prettyprint lang-java">Consumer</tt>. Функціональний інтерфейс <tt class="prettyprint lang-java">Consumer</tt> оголошує абстрактний метод <tt class="prettyprint lang-java">accept()</tt> (<a href="#c05i03">Рисунок 5-3</a>):</p>
    
    <pre class="prettyprint lang-java">
    @FunctionalInterface
    public interface Consumer&lt;T&gt; {
        void accept(T t);
            // метод по замовчуванню andThen опущено
    }
    </pre>
    
    <p><img id="c05i03" src="img/c05i03.jpg"/><br/>
    Рисунок 5-3. <tt class="prettyprint lang-java">Consumer&lt;T&gt;</tt> приймає аргумент типу <tt class="prettyprint lang-java">T</tt> та нічого не повертає</p>
    
    <p>Метод <tt class="prettyprint lang-java">accept()</tt> "споживає" об'єкт та нічого не повертає (<tt class="prettyprint lang-java">void</tt>).</p>
    
    <hr/>
    <p><tt class="prettyprint lang-java">Consumer&lt;T&gt;</tt> щось "споживає": він приймає аргумент (узагальненого типу <tt class="prettyprint lang-java">T</tt>) та нічого не повертає (<tt class="prettyprint lang-java">void</tt>). Можна викликати матод <tt class="prettyprint lang-java">accept()</tt> об'єкту <tt class="prettyprint lang-java">Consumer</tt>.</p>
    <hr/>
    
    <p>Приклад використання інтерфейсу <tt class="prettyprint lang-java">Consumer</tt>:</p>
    
    <pre class="prettyprint lang-java">
    Consumer&lt;String&gt; printUpperCase = str -&gt; System.out.println(str.toUpperCase());
    printUpperCase.accept("привіт");
    // prints: ПРИВІТ
    </pre>
    
    <p>В цьому коді вираз лямбда приймає надану стрічку, переводить її до верхнього регістру та друкує на консолі. До методу <tt class="prettyprint lang-java">accept()</tt> передається дійсний аргумент "<tt class="prettyprint lang-java">привіт</tt>".</p>
    
    <p>Повернемося до обговорення <tt class="prettyprint lang-java">forEach()</tt>: як працює виклик <tt class="prettyprint lang-java">forEach(System.out::println)</tt>?</p>
    
    <p>Клас <tt class="prettyprint lang-java">System</tt> має статичну змінну <tt class="prettyprint lang-java">out</tt> типу <tt class="prettyprint lang-java">PrintStream</tt>. Клас <tt class="prettyprint lang-java">PrintStream</tt> визначає перевантажені методи <tt class="prettyprint lang-java">println</tt>; один з перевантажених методів має сигнатуру <tt class="prettyprint lang-java">void println(String)</tt>. У виклику <tt class="prettyprint lang-java">forEach(System.out::println)</tt> передається посилання на метод <tt class="prettyprint lang-java">println</tt>, саме <tt class="prettyprint lang-java">System.out::println</tt>. Це посилання на метод співпадає із сигнатурою абстрактного методу інтерфейсу <tt class="prettyprint lang-java">Consumer</tt>, а саме <tt class="prettyprint lang-java">void accept(T)</tt>. Отже, посилання на метод <tt class="prettyprint lang-java">System.out::println</tt> використовується для <b>реалізації</b> функціонального інтерфейсу <tt class="prettyprint lang-java">Consumer</tt> та код друкує на консолі стрічки "<tt class="prettyprint lang-java">привіт</tt>" та "<tt class="prettyprint lang-java">всім</tt>". <a href="#Listing0503">Лістинг 5-3</a> розбиває код <tt class="prettyprint lang-java">Stream.of("привіт", "всім").forEach(System.out::println);</tt> на три різні оператори для того, щоб продемонструвати, як це все працює.</p>
    
    <pre id="Listing0503" class="prettyprint lang-java">
    // Лістинг 5-3. ConsumerUse.java
    import java.util.stream.Stream;
    import java.util.function.Consumer;
    
    class ConsumerUse {
        public static void main(String []args) {
            Stream&lt;String&gt; strings = Stream.of("привіт", "всім");
            Consumer&lt;String&gt; printString = System.out::println;
            strings.forEach(printString);
        }
    }
    </pre>
    
    <p>Ця програма друкує:</p>
    
    <pre class="prettyprint lang-java">
    hello
    world
    </pre>
    
    <p><tt class="prettyprint lang-java">Consumer</tt> також ає метод по замовчуванню <tt class="prettyprint lang-java">andThen()</tt>; він дозволяє з'єднувати виклики об'єктів <tt class="prettyprint lang-java">Consumer</tt>.</p>
    
    <h2>Інтерфейс Function</h2>
    
    <p>В наступному лістингу наведено приклад використання методу <tt class="prettyprint lang-java">map()</tt> інтерфейсу <tt class="prettyprint lang-java">java.util.stream.Stream</tt>: (<a href="#Listing0504">Лістинг 5-4</a>):</p>
    
    <pre id="Listing0504" class="prettyprint lang-java">
    // Лістинг 5-4. FunctionUse.java
    import java.util.Arrays;
    
    public class FunctionUse {
        public static void main(String []args) {
            Arrays.stream("4, -9, 16".split(", "))
                .map(Integer::parseInt)
                .map(i -&gt; (i &lt; 0) ? -i : i)
                .forEach(System.out::println);
        }
    }
    </pre>
    
    <p>Ця програма друкує:</p>
    
    <pre class="prettyprint lang-java">
    4
    9
    16
    </pre>
    
    <p>Ця програма створює потік <tt class="prettyprint lang-java">String</tt>-ів, розбиваючи стрічку "<tt class="prettyprint lang-java">4, -9, 16</tt>". Посилання на метод <tt class="prettyprint lang-java">Integer::parseInt</tt> передається в метод <tt class="prettyprint lang-java">map()</tt> &ndash; цей виклик повертає об'єкт <tt class="prettyprint lang-java">Integer</tt>для кожного елементу потоку. В другому виклику методу <tt class="prettyprint lang-java">map()</tt> в потоці використовується лямбда функція <tt class="prettyprint lang-java">(i -&gt; (i &lt; 0) ? -i : i)</tt> для створення списку не-від'ємних цілих (також можна було використати метод <tt class="prettyprint lang-java">Math::abs</tt>). Метод <tt class="prettyprint lang-java">map()</tt> приймає аргумент <tt class="prettyprint lang-java">Function</tt> (цей приклад демонструє, де корисний інтерфейс <tt class="prettyprint lang-java">Function</tt>). Наприкінці, з використанням методу <tt class="prettyprint lang-java">forEach()</tt> цілі друкуються.</p>
    
    <p>Інтерфейс <tt class="prettyprint lang-java">Function</tt> визначає один абстрактний мето <tt class="prettyprint lang-java">apply()</tt>, який приймає аргумент узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає об'єкт узагальненого типу <tt class="prettyprint lang-java">R</tt> (<a href="#c05i04">Рисунок 5-4</a>):</p>
    
    <pre class="prettyprint lang-java">
    @FunctionalInterface
    public interface Function&lt;T, R&gt; {
        R apply(T t);
        // інші методи
    }
    </pre>
    
    <p><img id="c05i04" src="img/c05i04.jpg"/><br/>
    Рисунок 5-4. <tt class="prettyprint lang-java">Function&lt;T, R&gt;</tt> приймає аргумент типу <tt class="prettyprint lang-java">T</tt> та повертає значення типу <tt class="prettyprint lang-java">R</tt></p>
    
    <p>Інтерфейс <tt class="prettyprint lang-java">Function</tt> має такі методи по замовчуванню як <tt class="prettyprint lang-java">compose()</tt>, <tt class="prettyprint lang-java">andThen()</tt> та <tt class="prettyprint lang-java">identity()</tt>.</p>
    
    <hr/>
    <p><tt class="prettyprint lang-java">Function&lt;T, R&gt;</tt> "оперує" над чимось та щось повертає: він приймає один аргумент (узагальненого типу <tt class="prettyprint lang-java">T</tt>) та повертає об'єкт (узагальненого типу <tt class="prettyprint lang-java">R</tt>). Можна викликати метод <tt class="prettyprint lang-java">apply()</tt>об'єкту <tt class="prettyprint lang-java">Function</tt>.</p>
    <hr/>
    
    <p>Простий приклад використання <tt class="prettyprint lang-java">Function</tt>:</p>
    
    <pre class="prettyprint lang-java">
    Function&lt;String, Integer&gt; strLength = str -&gt; str.length();
    System.out.println(strLength.apply("supercalifragilisticexpialidocious"));
    // друкує: 34
    </pre>
    
    <p>Цей код приймає стрічку та повертає її довжину. У виклику <tt class="prettyprint lang-java">strLength.apply</tt> передається "<tt class="prettyprint lang-java">supercalifragilisticexpialidocious</tt>". Як результат виклику <tt class="prettyprint lang-java">apply()</tt> отримується довина цієї стрічки: <tt class="prettyprint lang-java">34</tt>.</p>
    
    <p>Змінимо попередню програму в <a href="#Listing0504">Лістингу 5-4</a> для використання методу <tt class="prettyprint lang-java">andThen()</tt>: (<a href="#Listing0505">Лістинг 5-5</a>).</p>
    
    <pre id="Listing0505" class="prettyprint lang-java">
    // Лістинг 5-5. CombineFunctions.java
    import java.util.Arrays;
    import java.util.function.Function;
    
    public class CombineFunctions {
        public static void main(String []args) {
            Function&lt;String, Integer&gt; parseInt = Integer::parseInt;
            Function&lt;Integer, Integer&gt; absInt = Math::abs;
            Function&lt;String, Integer&gt; parseAndAbsInt = parseInt.andThen(absInt);
            
            Arrays.stream("4, -9, 16".split(", "))
                    .map(parseAndAbsInt)
                    .forEach(System.out::println);
        }
    }
    </pre>
    
    <p>Ця програма друкує <tt class="prettyprint lang-java">4</tt>, <tt class="prettyprint lang-java">9</tt> та <tt class="prettyprint lang-java">16</tt> на окремих рядках: тий самий вивід як в <a href="#Listing0504">Лістингу 5-4</a>, але через еєдиний виклик методу <tt class="prettyprint lang-java">map()</tt> в <tt class="prettyprint lang-java">Stream</tt>. Оскільки <tt class="prettyprint lang-java">Integer::parseInt()</tt> приймає <tt class="prettyprint lang-java">String</tt> як аргумент, розбирає його для повернення <tt class="prettyprint lang-java">Integer</tt>, то метод <tt class="prettyprint lang-java">parseInt()</tt> оголошується як <tt class="prettyprint lang-java">Function&lt;String, Integer&gt;</tt>. Метод <tt class="prettyprint lang-java">Math::abs</tt> приймає ціле та повертає ціле, тож він оголошується як <tt class="prettyprint lang-java">Function&lt;Integer, Integer&gt;</tt>. Оскільки <tt class="prettyprint lang-java">parseAndAbsInt</tt> приймає аргумент <tt class="prettyprint lang-java">String</tt> та повертає <tt class="prettyprint lang-java">Integer</tt>він оголошується як <tt class="prettyprint lang-java">Function&lt;String, Integer&gt;</tt>.</p>
    
    <p>Яка різниця між методами <tt class="prettyprint lang-java">andThen()</tt> та <tt class="prettyprint lang-java">compose()</tt> інтерфейсу <tt class="prettyprint lang-java">Function</tt>? Метод <tt class="prettyprint lang-java">andThen()</tt> застосовує наданий аргумент <b>після</b> виклику поточної <tt class="prettyprint lang-java">Function</tt> (як в прикладі). Метод <tt class="prettyprint lang-java">compose()</tt> викликає аргумент <b>перед</b> викликом поточної <tt class="prettyprint lang-java">Function</tt>:</p>
    
    <pre class="prettyprint lang-java">
    Function&lt;String, Integer&gt; parseAndAbsInt = absInt.compose(parseInt);
    </pre>
    
    <p>Функція <tt class="prettyprint lang-java">identity()</tt> в <tt class="prettyprint lang-java">Function</tt> просто повертає наданий аргумент. Навіщо вона? Інколи вона використовується для тестування &ndash; при написанні частки коду з <tt class="prettyprint lang-java">Function</tt> та бажінні перевірити, чи він працює, можна викликати <tt class="prettyprint lang-java">identity()</tt>, оскільки вона нічого не робить. Приклад:</p>
    
    <pre class="prettyprint lang-java">
    Arrays.stream("4, -9, 16".split(", "))
            .map(Function.identity())
            .forEach(System.out::println);
    </pre>
    
    <p>В цьому коді, <tt class="prettyprint lang-java">map(Function.identity())</tt> не робиьт нічого; вона лише переправляє елементи потоку до виклику <tt class="prettyprint lang-java">forEach(System.out::println)</tt>. Тож код друкує елементи на різних рядках такими, як вони є, а саме значення <tt class="prettyprint lang-java">4</tt>, <tt class="prettyprint lang-java">-9</tt> та <tt class="prettyprint lang-java">16</tt>.</p>
    
    <h2>Інтерфейс Supplier</h2>
    
    <p>Часто в програмах потрібні методи, які не приймають жодного аргументу та щось повертають. Код нижче генерує булеві значення: (<a href="#Listing0506">Лістинг 5-6</a>):</p>
    
    <pre id="Listing0506" class="prettyprint lang-java">
    // Лістинг 5-6. GenerateBooleans.java
    import java.util.stream.Stream;
    import java.util.Random;
    
    class GenerateBooleans {
        public static void main(String []args) {
            Random random = new Random();
            Stream.generate(random::nextBoolean)
                    .limit(2)
                    .forEach(System.out::println);
        }
    }
    </pre>
    
    <p>Ця програма друкує два випадкові булеві значення, наприклад, "<tt class="prettyprint lang-java">true</tt>" та "<tt class="prettyprint lang-java">false</tt>". Метод <tt class="prettyprint lang-java">generate()</tt> в інтерфейсі <tt class="prettyprint lang-java">Stream</tt> iє статичним членом, який приймає аргумент <tt class="prettyprint lang-java">Supplier</tt>:</p>
    
    <pre class="prettyprint lang-java">
    static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
    </pre>
    
    <p>Тут передається посилання на метод <tt class="prettyprint lang-java">nextBoolean</tt>, який визначений в класі <tt class="prettyprint lang-java">java.util.Random</tt>. Він повертає довільне значення <tt class="prettyprint lang-java">boolean</tt>:</p>
    
    <pre class="prettyprint lang-java">
    boolean 	nextBoolean()
    </pre>
    
    <p>Посилання на метод <tt class="prettyprint lang-java">nextBoolean</tt> можна передати до методу <tt class="prettyprint lang-java">generate()</tt> в <tt class="prettyprint lang-java">Stream</tt> оскільки він відповідає абстрактному методу в інтерфейсі <tt class="prettyprint lang-java">Supplier</tt>, а саме <tt class="prettyprint lang-java">T get()</tt> <a href="#c05i05">Рисунок 5-5</a>).</p>
    
    <p><img id="c05i05" src="img/c05i05.jpg"><br/>
    Рисунок 5-5. <tt class="prettyprint lang-java">Supplier&lt;T&gt;</tt> не приймає аргументів та повертає значення типу <tt class="prettyprint lang-java">T</tt></p>
    
    <hr/>
    <p><tt class="prettyprint lang-java">Supplier&lt;T&gt;</tt> "постачає": нічого не приймаючи повертає щось: він не має аргументів та повертає об'єкт (узагальненого типу <tt class="prettyprint lang-java">T</tt>). Можна викликати метод <tt class="prettyprint lang-java">get()</tt> об'єкту <tt class="prettyprint lang-java">Supplier</tt>.</p>
    
    <p>Простий приклад, який повертає значення без будь-якого аргументу:</p>
    
    <pre class="prettyprint lang-java">
    Supplier&lt;String&gt; currentDateTime = () -&gt; LocalDateTime.now().toString();
    System.out.println(currentDateTime.get());
    </pre>
    
    <p>Викликається метод <tt class="prettyprint lang-java">now()</tt> в <tt class="prettyprint lang-java">java.time.LocalDateTime</tt> (API дати та часу розглянуто в Главі 8). При його виконанні друкується: <tt class="prettyprint lang-java">2018-10-16T12:40:55.164</tt>. Звичайно, значення зміниться при наступному виконанні коду. Тут використовується <tt class="prettyprint lang-java">Supplier&lt;String&gt;</tt>. Лямбда вираз не робить виводу, але повертає поточну дату/час як <tt class="prettyprint lang-java">String</tt>. Лямбда викликаєтсья при виклику методу <tt class="prettyprint lang-java">get()</tt> в змінній <tt class="prettyprint lang-java">currentDateTime</tt>.</p>
    <hr/>
    
    <h3>Посилання на конструктор</h3>
    
    <p>Розглянемо код:</p>
    
    <pre class="prettyprint lang-java">
    Supplier&lt;String&gt; newString = String::new;
    System.out.println(newString.get());
    // друкує на консоль порожню стрічку (нічого) та символ нового рядку
    </pre>
    
    <p>Цей код використовує посилання на конструктор. Він тотожній цьому коду:</p>
    
    <pre class="prettyprint lang-java">
    Supplier&lt;String&gt; newString = () -&gt; new String();
    System.out.println(newString.get());
    </pre>
    
    <p>З використанням посилання на метод <tt class="prettyprint lang-java">::new</tt> лямбда вираз стає простішим: <tt class="prettyprint lang-java">String::new</tt>. Як використовувати конструктори, які приймають аргументи? Наприклад, <tt class="prettyprint lang-java">Integer(String)</tt>: цей конструктор <tt class="prettyprint lang-java">Integer</tt> приймає аргумент <tt class="prettyprint lang-java">String</tt> та створює об'єкт <tt class="prettyprint lang-java">Integer</tt> із значенням, наданим в стрічці. Як такий конструктор можна використовувати:</p>
    
    <pre class="prettyprint lang-java">
    Function&lt;String, Integer&gt; anotherInteger = Integer::new;
    System.out.println(anotherInteger.apply("100"));
    // цей код друкує: 100
    </pre>
    
    <p>Тут не можна використовувати <tt class="prettyprint lang-java">Supplier</tt> оскільки <tt class="prettyprint lang-java">Supplier</tt> не приймає аргументів. <tt class="prettyprint lang-java">Functions</tt> приймає, та оскільки тип, який повертається це <tt class="prettyprint lang-java">Integer</tt>, то можна використовувати <tt class="prettyprint lang-java">Function&lt;String, Integer&gt;</tt>.</p>
    
    <h1>Примітивні версії функціональних інтерфейсів</h1>
    
    <p>Вбудовані інтерфейси <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt> оперують об'єктами посилальних типів (таких об'єктів, на які в оперативній пам'яті існують посилання, на відміну від саме значень). Для наступних примітивних типів є спеціалізації цих функціональних інтерфейсів: <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt>. Розглянемо <tt class="prettyprint lang-java">Predicate</tt>, який оперує об'єктами типу <tt class="prettyprint lang-java">T</tt>, тобто <tt class="prettyprint lang-java">Predicate&lt;T&gt;</tt>. Спеціалізації <tt class="prettyprint lang-java">Predicate</tt> для <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> це: <tt class="prettyprint lang-java">IntPredicate</tt>, <tt class="prettyprint lang-java">LongPredicate</tt> та <tt class="prettyprint lang-java">DoublePredicate</tt> відповідно.</p>
    
    <p>Внаслідок обмежень, властивих узагальненям (Глава 4), значення примітивних типів не можуть використовуватися з функціональними інтерфейсами <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt>. Але з цими функціональними інтерфейсами можливе використання таких типів-обгорток (wrapper types) як <tt class="prettyprint lang-java">Integer</tt> та <tt class="prettyprint lang-java">Double</tt>. При використанні примітивних типів з цими функціональними інтерфейсами виконується неявне згортання та розгортання, для прикладу: значення <tt class="prettyprint lang-java">int</tt> перетворюється в об'єкт <tt class="prettyprint lang-java">Integer</tt> та навпаки. Фактично, з цими функціональними інтерфейсами використання типів-обгорток може пройти поза свідомістю. Однак, їх використання може вплинути на продуктивність: уявіть згортання-розгортання мільйонів цілих в потоці. Для запобігання проблеми продуктивности слід використовувати відповідні примітивні версії цих функціональних інтерфейсів.</p>
    
    <h2>Примітивні версії інтерфейсу Predicate</h2>
    
    <p>Приклад:</p>
    
    <pre class="prettyprint lang-java">
    IntStream.range(1, 10).filter(i -&gt; (i % 2) == 0).forEach(System.out::println);
    </pre>
    
    <p>Метод <tt class="prettyprint lang-java">filter()</tt> приймає аргумент <tt class="prettyprint lang-java">IntPredicate</tt> оскільки базовий потік &ndash; це <tt class="prettyprint lang-java">IntStream</tt>. Тотожній код, який використовує <tt class="prettyprint lang-java">IntPredicate</tt> явно:</p>
    
    <pre class="prettyprint lang-java">
    IntPredicate evenNums = i -&gt; (i % 2) == 0;
    IntStream.range(1, 10).filter(evenNums).forEach(System.out::println);
    </pre>
    
    <p><a href="#c05t02">Таблиця 5-2</a> перелічує примітивні версії інтерфейсу <tt class="prettyprint lang-java">Predicate</tt> в пакеті <tt class="prettyprint lang-java">java.util.function</tt>.</p>
    
    <table id="c05t02" border="1">
        <caption>Таблиця 5-2. Примітивні версії інтерфейсу Predicate</caption>
        <tr><th>Функціональний інтерфейс</th><th>Абстрактний метод</th><th>Опис</th></tr>
        <tr><td><tt class="prettyprint lang-java">IntPredicate</tt></td><td><tt class="prettyprint lang-java">boolean test(int value)</tt></td><td>Обчислює надану умову як <tt class="prettyprint lang-java">int</tt> та повертає значення <tt class="prettyprint lang-java">boolean</tt></td></tr>
        <tr><td><tt class="prettyprint lang-java">LongPredicate</tt></td><td><tt class="prettyprint lang-java">boolean test(long value)</tt></td><td>EОбчислює надану умову як <tt class="prettyprint lang-java">long</tt> та повертає значення <tt class="prettyprint lang-java">boolean</tt></td></tr>
        <tr><td><tt class="prettyprint lang-java">DoublePredicate</tt></td><td><tt class="prettyprint lang-java">boolean test(double value)</tt></td><td>Обчислює надану умову як <tt class="prettyprint lang-java">double</tt> та повертає значення <tt class="prettyprint lang-java">boolean</tt></td></tr>
    </table>
    
    <h2>Примітивні версії інтерфейсу Function</h2>
    
    <p>Приклад використання <tt class="prettyprint lang-java">Stream</tt> з цілими примітивного типу:</p>
    
    <pre class="prettyprint lang-java">
    AtomicInteger ints = new AtomicInteger(0);
    Stream.generate(ints::incrementAndGet).limit(10).forEach(System.out::println);
    // друкує на консоль цілі від 1 до 10
    </pre>
    
    <p>Цей код викликає метод <tt class="prettyprint lang-java">int incrementAndGet()</tt>, визначений в класі <tt class="prettyprint lang-java">java.util.concurrent.atomic.AtomicInteger</tt>. Зауважте, що цей метод повертає <tt class="prettyprint lang-java">int</tt>, а не <tt class="prettyprint lang-java">Integer</tt>. Проте його можна використовувати з <tt class="prettyprint lang-java">Stream</tt> за рахунок неявного пакування та розпакування <tt class="prettyprint lang-java">int</tt> в/з тип-обгортку <tt class="prettyprint lang-java">Integer</tt>. Але це пакування та розпакування зайве. Натомість треба використовувати інтерфейс <tt class="prettyprint lang-java">IntStream</tt>: його метод <tt class="prettyprint lang-java">generator()</tt> приймає аргумент типу <tt class="prettyprint lang-java">IntSupplier</tt>. З такими змінами тотожній код:</p>
    
    <pre class="prettyprint lang-java">
    AtomicInteger ints = new AtomicInteger(0);
    IntStream.generate(ints::incrementAndGet).limit(10).forEach(System.out::println);
    // друкує на консоль цілі від 1 до 10
    </pre>
    
    <p>Оскільки цей код використовує <tt class="prettyprint lang-java">IntStream</tt>, та метод <tt class="prettyprint lang-java">generate()</tt> приймає <tt class="prettyprint lang-java">IntSupplier</tt>, неявного пакування та розпакування не відбувається; отже цей код працює швидше, оскільки він не генерує непотрібних тимчасових об'єктів <tt class="prettyprint lang-java">Integer</tt>.</p>
    
    <p>Інший приклад. Фрагмент коду, який раніше використовува метод <tt class="prettyprint lang-java">Math.abs()</tt>:</p>
    
    <pre class="prettyprint lang-java">
    Function&lt;Integer, Integer&gt; absInt = Math::abs;
    </pre>
    
    <p>Його можна замінити еквівалентом з використанням спеціалізації <tt class="prettyprint lang-java">Function</tt>, відомої як <tt class="prettyprint lang-java">IntFunction</tt>:</p>
    
    <p>В залежності від типу аргументів та значень, що повертаються, доступні багато версій примітивних типів для інтерфейсу <tt class="prettyprint lang-java">Function</tt>:<a href="#c05t03">Таблиця 5-3</a>.</p>
    
    <table id="c05t03" border="1">
        <caption>Таблиця 5-3. Примітивні версії інтерфейсу Function</caption>
        <tr><th>Функціональний інтерфейс</th><th>Абстрактний метод</th><th>Опис</th></tr>
        <tr>
            <td><tt class="prettyprint lang-java">IntFunction&lt;R&gt;</tt></td>
            <td><tt class="prettyprint lang-java">R apply(int value)</tt></td>
            <td>Оперує наданим аргументом <tt class="prettyprint lang-java">int</tt> та повертає значення узагальненого типу <tt class="prettyprint lang-java">R</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LongFunction&lt;R&gt;</tt></td>
            <td><tt class="prettyprint lang-java">R apply(long value)</tt></td>
            <td>Оперує наданим аргументом <tt class="prettyprint lang-java">long</tt> та повертає значення узагальненого типу <tt class="prettyprint lang-java">R</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">DoubleFunction&lt;R&gt;</tt></td>
            <td><tt class="prettyprint lang-java">R apply(double value)</tt></td>
            <td>Оперує наданим аргументом <tt class="prettyprint lang-java">double</tt> та повертає значення узагальненого типу <tt class="prettyprint lang-java">R</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ToIntFunction&lt;T&gt;</tt></td>
            <td><tt class="prettyprint lang-java">int applyAsInt(T value)</tt></td>
            <td>Оперує наданим аргументом узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає значення <tt class="prettyprint lang-java">int</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ToLongFunction&lt;T&gt;</tt></td>
            <td><tt class="prettyprint lang-java">long applyAsLong(T value)</tt></td>
            <td>Оперує наданим аргументом узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає значення <tt class="prettyprint lang-java">long</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ToDoubleFunction&lt;T&gt;</tt></td>
            <td><tt class="prettyprint lang-java">double applyAsDouble(T value)</tt></td>
            <td>Оперує наданим аргументом узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає значення <tt class="prettyprint lang-java">double</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">IntToLongFunction</tt></td>
            <td><tt class="prettyprint lang-java">long applyAsLong(int value)</tt></td>
            <td>Operates on the passed <tt class="prettyprint lang-java">int</tt> та повертає значення <tt class="prettyprint lang-java">long</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">IntToDoubleFunction</tt></td>
            <td><tt class="prettyprint lang-java">double applyAsDouble(int value)</tt></td>
            <td>Оперує наданим аргументом типу <tt class="prettyprint lang-java">int</tt>  та повертає значення <tt class="prettyprint lang-java">double</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LongToIntFunction</tt></td>
            <td><tt class="prettyprint lang-java">int applyAsInt(long value)</tt></td>
            <td>Оперує наданим аргументом типу <tt class="prettyprint lang-java">long</tt> та повертає значення <tt class="prettyprint lang-java">int</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LongToDoubleFunction</tt></td>
            <td><tt class="prettyprint lang-java">double applyAsLong(long value)</tt></td>
            <td>Оперує наданим аргументом типу <tt class="prettyprint lang-java">long</tt> та повертає значення <tt class="prettyprint lang-java">double</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">DoubleToIntFunction</tt></td>
            <td><tt class="prettyprint lang-java">int applyAsInt(double value)</tt></td>
            <td>Оперує наданим аргументом типу <tt class="prettyprint lang-java">double</tt> та повертає значення <tt class="prettyprint lang-java">int</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">DoubleToLongFunction</tt></td>
            <td><tt class="prettyprint lang-java">long applyAsLong(double value)</tt></td>
            <td>Оперує наданим аргументом типу <tt class="prettyprint lang-java">double</tt> та повертає значення <tt class="prettyprint lang-java">long</tt></td>
        </tr>
    </table>
    
    <h2>Примітивні версії інтерфейсу Consumer</h2>
    
    <p>В залежності від типу аргументів існує багато версій примітивних типів для інтерфейсу Consumer: <a href="#c05t04">Таблиця 5-4</a>.</p>
    
    <table id="c05t04" border="1">
        <caption>Таблиця 5-4. Примітивні версії інтерфейсу Consumer</caption>
        <tr>
            <th>Функціональний інтерфейс</th>
            <th>Абстрактний метод</th>
            <th>Опис</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">IntConsumer</tt></td>
            <td><tt class="prettyprint lang-java">void accept(int value)</tt></td>
            <td>Оперує наданим аргументом <tt class="prettyprint lang-java">int</tt> та нічого не повертає</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LongConsumer</tt></td>
            <td><tt class="prettyprint lang-java">void accept(long value)</tt></td>
            <td>Оперує наданим аргументом <tt class="prettyprint lang-java">long</tt> та нічого не повертає</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">DoubleConsumer</tt></td>
            <td><tt class="prettyprint lang-java">void accept(double value)</tt></td>
            <td>Оперує наданим аргументом <tt class="prettyprint lang-java">double</tt> та нічого не повертає</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ObjIntConsumer&lt;T&gt;</tt></td>
            <td><tt class="prettyprint lang-java">void accept(T t, int value)</tt></td>
            <td>Оперує наданими аргументами узагальненого типу <tt class="prettyprint lang-java">T</tt> та <tt class="prettyprint lang-java">int</tt> та нічого не повертає</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ObjLongConsumer&lt;T&gt;</tt></td>
            <td><tt class="prettyprint lang-java">void accept(T t, long value)</tt></td>
            <td>Оперує наданими аргументами узагальненого типу <tt class="prettyprint lang-java">T</tt> та <tt class="prettyprint lang-java">long</tt> та нічого не повертає</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ObjLongConsumer&lt;T&gt;</tt></td>
            <td><tt class="prettyprint lang-java">void accept(T t, double value)</tt></td>
            <td>Оперує наданими аргументами узагальненого типу <tt class="prettyprint lang-java">T</tt> та <tt class="prettyprint lang-java">double</tt> та нічого не повертає</td>
        </tr>
    </table>
    
    <h2>Примітивні версії інтерфейсу Supplier</h2>
    
    <p>Примітивні версії <tt class="prettyprint lang-java">Supplier</tt> це <tt class="prettyprint lang-java">BooleanSupplier</tt>, <tt class="prettyprint lang-java">IntSupplier</tt>, <tt class="prettyprint lang-java">LongSupplier</tt> та <tt class="prettyprint lang-java">DoubleSupplier</tt>, які повертають <tt class="prettyprint lang-java">boolean</tt>, <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> відповідно:<a href="#c05t05">Таблиця 5-5</a>.</p>
    
    <table id="c05t05" border="1">
        <caption>Таблиця 5-5. Примітивні версії інтерфейсу Supplier</caption>
        <tr>
            <tr>
                <th>Функціональний інтерфейс</th>
                <th>Абстрактний метод</th>
                <th>Опис</th>
            </tr>
            <tr>
                <td><tt class="prettyprint lang-java">BooleanSupplier</tt></td>
                <td><tt class="prettyprint lang-java">boolean getAsBoolean()</tt></td>
                <td>Не приймає аргументів та повертає значення <tt class="prettyprint lang-java">boolean</tt></td>
            </tr>
            <tr>
                <td><tt class="prettyprint lang-java">IntSupplier</tt></td>
                <td><tt class="prettyprint lang-java">int getAsInt()</tt></td>
                <td>Не приймає аргументів та повертає значення <tt class="prettyprint lang-java">int</tt></td>
            </tr>
            <tr>
                <td><tt class="prettyprint lang-java">LongSupplier</tt></td>
                <td><tt class="prettyprint lang-java">long getAsLong()</tt></td>
                <td>Не приймає аргументів та повертає значення <tt class="prettyprint lang-java">long</tt></td>
            </tr>
            <tr>
                <td><tt class="prettyprint lang-java">DoubleSupplier</tt></td>
                <td><tt class="prettyprint lang-java">double getAsDouble()</tt></td>
                <td>Не приймає аргументів та повертає значення <tt class="prettyprint lang-java">double</tt></td>
            </tr>
    </table>
    
    <hr/>
    <p>Примітивні версії функціональних інтерфейсів доступні лише для типів <tt class="prettyprint lang-java">int</tt> , <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> (також для <tt class="prettyprint lang-java">boolean</tt> у випадку <tt class="prettyprint lang-java">Supplier</tt>). Що робити, у випадку, коли функціональний інтерфейс приймає чи повертає інші примітивні типи <tt class="prettyprint lang-java">char</tt>, <tt class="prettyprint lang-java">byte</tt> чи <tt class="prettyprint lang-java">short</tt>? Потрібні неявні перетворення до спеціалізації <tt class="prettyprint lang-java">int</tt>. Схожим чином &ndash; ыз спеціалізацією <tt class="prettyprint lang-java">double</tt> при використанні <tt class="prettyprint lang-java">float</tt>.</p>
    <hr/>
    
    <h1>Бінарні версії функціональних інтерфейсів</h1>
    
    <p>Фунціональні інтерфейси <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt> та <tt class="prettyprint lang-java">Function</tt> мають абстрактні методи, які приймають один аргумент. Наприклад, інтерфейс <tt class="prettyprint lang-java">Function</tt>:</p>
    
    <pre class="prettyprint lang-java">
    @FunctionalInterface
    public interface Function&lt;T, R&gt; {
        R apply(T t);
        // інші методи
    }
    </pre>
    
    <p>Абстрактний метод <tt class="prettyprint lang-java">apply()</tt> приймає один аргумент (узагальнений тип <tt class="prettyprint lang-java">T</tt>). Бінарна версія інтерфейсу <tt class="prettyprint lang-java">Function</tt>:</p>
    
    <pre class="prettyprint lang-java">
    @FunctionalInterface
    public interface BiFunction&lt;T, U, R&gt; {
        R apply(T t, U u);
        // інші методи
    }
    </pre>
    
    <hr/>
    <p><tt class="prettyprint lang-java">BiFunction</tt> схожий на <tt class="prettyprint lang-java">Function</tt>, але приймає два аргументи: узагальнених типів <tt class="prettyprint lang-java">T</tt> та <tt class="prettyprint lang-java">U</tt> та повертає об'єкт узагальненого типу <tt class="prettyprint lang-java">R</tt>. Можна викликати метод <tt class="prettyprint lang-java">apply()</tt>об'єкту <tt class="prettyprint lang-java">BiFunction</tt>.</p>
    <hr/>
    
    <p>Префікс "Bi" вказує на те, що версія приймає два аргументи. Окрім <tt class="prettyprint lang-java">BiFunction</tt> для <tt class="prettyprint lang-java">Function</tt> існують <tt class="prettyprint lang-java">BiPredicate</tt> для <tt class="prettyprint lang-java">Predicate</tt> та <tt class="prettyprint lang-java">BiConsumer</tt> для <tt class="prettyprint lang-java">Consumer</tt>, які приймають два аргументи (див. <a href="#c05t06">Таблиця 5-6</a>). А що з <tt class="prettyprint lang-java">Supplier</tt>? Оскільки абстрактний метод в <tt class="prettyprint lang-java">Supplier</tt> не приймає жодного аргументу, еквіваленту <tt class="prettyprint lang-java">BiSupplier</tt> не існує.</p>
    
    <table id="c05t06" border="1">
        <caption>Table 5-6. Бінарні версії функціональних інтерфейсів</caption>
        <tr>
            <th>Функціональний інтерфейс</th>
            <th>Абстрактний метод</th>
            <th>Опис</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">BiPredicate<T, U></tt></td>
            <td><tt class="prettyprint lang-java">boolean test(T t, U u)</tt></td>
            <td>Перевіряє відповідність аргумента умові та повертає <tt class="prettyprint lang-java">boolean</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">BiConsumer<T, U></tt></td>
            <td><tt class="prettyprint lang-java">void accept(T t, U u)</tt></td>
            <td>Операція, яка споживає два аргументи та нічого не повертає</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">BiFunction<T, U, R></tt></td>
            <td><tt class="prettyprint lang-java">R apply(T t, U u)</tt></td>
            <td>Функція, яка приймає два аргументи та повертає результат</td>
        </tr>
    </table>
    
    <h2>Інтерфейс BiFunction</h2>
    
    <p>Приклад використання інтерфейсу <tt class="prettyprint lang-java">BiFunction</tt>:</p>
    
    <pre class="prettyprint lang-java">
    BiFunction&lt;String, String, String&gt; concatStr = (x, y) -&gt; x + y;
    System.out.println(concatStr.apply("привіт ", "всім"));
    // prints: привіт всім
    </pre>
    
    <p>В цьому прикладі аргументи та значення, що повертається, належать одому типу. Але вони можуть бути різними:</p>
    
    <pre class="prettyprint lang-java">
    BiFunction&lt;Double, Double, Integer&gt; compareDoubles = Double::compare;
    System.out.println(compareDoubles.apply(10.0, 10.0));
    // prints: 0
    </pre>
    
    <p>В цьому випадку типи аргументів <tt class="prettyprint lang-java">double</tt>, а тип, що повертається, <tt class="prettyprint lang-java">integer</tt>. Коли надані значення <tt class="prettyprint lang-java">double</tt> рівні, метод <tt class="prettyprint lang-java">compare</tt> класу <tt class="prettyprint lang-java">Double</tt> повертає <tt class="prettyprint lang-java">0</tt>, тож на виході маємо <tt class="prettyprint lang-java">0</tt>.</p>
    
    <p>Велика кількість функціональних інтерфейсів в <tt class="prettyprint lang-java">java.util.function</tt> може завадити пошуку придатного функціонального інтерфейсу. Наприклад, в одноу з попередніх прикладів використовувася <tt class="prettyprint lang-java">BiFunction&lt;Double, Double, Integer&gt;</tt>. Натомість можна було б використати функціональний інтерфейс <tt class="prettyprint lang-java">ToIntBiFunction</tt>, оскільки він повертає <tt class="prettyprint lang-java">int</tt>.</p>
    
    <h2>Інтерфейс BiPredicate</h2>
    
    <p>Розглянемо фрагмент коду:</p>
    
    <pre class="prettyprint lang-java">
    BiPredicate&lt;List&lt;Integer&gt;, Integer&gt; listContains = List::contains;
    List aList = Arrays.asList(10, 20, 30);
    System.out.println(listContains.test(aList, 20));
    // prints: true
    </pre>
    
    <p>Цей код демонструє, як використовувати <tt class="prettyprint lang-java">BiPredicate</tt>. Метод <tt class="prettyprint lang-java">contains()</tt> в <tt class="prettyprint lang-java">List</tt> приймає елемент як аргумент та перевіряє, чи базовий список містить цей елемент. Оскільки він приймає елемент та повертає <tt class="prettyprint lang-java">Integer</tt> можна використовувати <tt class="prettyprint lang-java">BiPredicate</tt>. А чому не <tt class="prettyprint lang-java">BiFunction&lt;T, U, Boolean&gt;</tt>? Так, код працюватиме, але кращий вибір це тотожній <tt class="prettyprint lang-java">BiPredicate&lt;T, U&gt;</tt>, оскільки <tt class="prettyprint lang-java">BiPredicate</tt> повертає <tt class="prettyprint lang-java">boolean</tt>.</p>
    
    <h2>Інтерфейс BiConsumer</h2>
    
    <p>Розглянемо фрагмент коду:</p>
    
    <pre class="prettyprint lang-java">
    BiConsumer&lt;List&lt;Integer&gt;, Integer&gt; listAddElement = List::add;
    List aList = new ArrayList();
    listAddElement.accept(aList, 10);
    System.out.println(aList);
    // prints: [10]
    </pre>
    
    <p>Цей фрагмент коду демонструє, як використовувати <tt class="prettyprint lang-java">BiConsumer</tt>.Як в попередньому прикладі для <tt class="prettyprint lang-java">BiPredicate</tt> використання посилання на метод <tt class="prettyprint lang-java">List::contains</tt>, цей приклад демонструє, як використовувати <tt class="prettyprint lang-java">BiConsumer</tt> для виклику методу <tt class="prettyprint lang-java">add()</tt> в <tt class="prettyprint lang-java">List</tt>, використовуючи цей інтерфейс.</p>
    
    <h1>Інтерфейс UnaryOperator</h1>
    
    <p>Розглянемо приклад.</p>
    
    <pre class="prettyprint lang-java">
    List&lt;Integer&gt; ell = Arrays.asList(-11, 22, 33, -44, 55);
    System.out.println("Перед: " + ell);
    ell.replaceAll(Math::abs);
    System.out.println("Після: " + ell);
    </pre>
    
    <p>Цей код надрукує:</p>
    
    <pre class="prettyprint lang-java">
    Перед: [-11, 22, 33, -44, 55]
    Після: [11, 22, 33, 44, 55]
    </pre>
    
    <p>Цей код використовує метод <tt class="prettyprint lang-java">replaceAll()</tt>, введений в Java 8, який замінює елементи в наданому <tt class="prettyprint lang-java">List</tt>. Метод <tt class="prettyprint lang-java">replaceAll()</tt> приймає один аргумент <tt class="prettyprint lang-java">UnaryOperator</tt>:</p>
    
    <pre class="prettyprint lang-java">void replaceAll(UnaryOperator<T> operator)</pre>
    
    <p>Метод <tt class="prettyprint lang-java">replaceAll()</tt> супроводжується наданим до нього методом <tt class="prettyprint lang-java">Math::abs</tt>.</p>
    
    <p><tt class="prettyprint lang-java">Math</tt> має чотири перевантажених методи для методу <tt class="prettyprint lang-java">abs()</tt>:</p>
    
    <pre class="prettyprint lang-java">abs(int)
    abs(long)
    abs(double)
    abs(float)</pre>
    
    <p>Оскільки тип є <tt class="prettyprint lang-java">Integer</tt>, при визначенні типу обирається перевантажений метод <tt class="prettyprint lang-java">abs(int)</tt>.</p>
    
    <p><tt class="prettyprint lang-java">UnaryOperator</tt> це функціональний інтерфейс, який розширює інтерфейс <tt class="prettyprint lang-java">Function</tt>, тож можна використовувати метод <tt class="prettyprint lang-java">apply()</tt>, оголошений в інтерфейсі <tt class="prettyprint lang-java">Function</tt>; більш за те, він наслідує функцію по замовчуванню <tt class="prettyprint lang-java">compose()</tt> та <tt class="prettyprint lang-java">andThen()</tt> від інтерфейсу <tt class="prettyprint lang-java">Function</tt>. Як і у випадку з <tt class="prettyprint lang-java">UnaryOperator</tt>, який розширює інтерфейс <tt class="prettyprint lang-java">Function</tt>, існує <tt class="prettyprint lang-java">BinaryOperator</tt>, який розширює інтерфейс <tt class="prettyprint lang-java">BiFunction</tt>.</p>
    
    <p>Версії інтерфейсу <tt class="prettyprint lang-java">UnaryOperator</tt> для примітивних типів <tt class="prettyprint lang-java">IntUnaryOperator</tt>, <tt class="prettyprint lang-java">LongUnaryOperator</tt> та <tt class="prettyprint lang-java">DoubleUnaryOperator</tt> також пропонуються як частина пакету <tt class="prettyprint lang-java">java.util.function</tt>.</p>
    
    <hr/>
    <p>Пакет <tt class="prettyprint lang-java">java.util.function</tt> містить лише функціональні інтерфейси. В ньому лише чотири корньові інтерфейси: <tt class="prettyprint lang-java">Predicate</tt> , <tt class="prettyprint lang-java">Consumer</tt> , <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt>. Решта інтерфейсів це примітивні версії, бінарні версії та породжені інтерфейси на кшталт <tt class="prettyprint lang-java">UnaryOperator</tt>. Вони відрізняються в основному сигнатурою та оголошеними абстрактими методами. Потрібно обирати придатний функціональний інтерфейс враховуючи контекст.</p>
    <hr/>
    
    <h1>Підсумок</h1>
    
    <p>Коротко оглянемо ключові моменти розглянутих в цій главі тем.</p>
    
    <b>Використання вбудованих інтерфейсів пакету <tt class="prettyprint lang-java">java.util.function</tt>: <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt></b>
    
    <ul>
        <li>Вбудовані інтерфейси <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt> в основному відрізняються сигнатурою оголоених абстрактних методів.</li>
        <li><tt class="prettyprint lang-java">Predicate</tt> перевір надану умову та повертає <tt class="prettyprint lang-java">true</tt> або <tt class="prettyprint lang-java">false</tt>; він має абстрактний метод "<tt class="prettyprint lang-java">test</tt>", який приймає парамметр узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає тип <tt class="prettyprint lang-java">boolean</tt>.</li>
        <li><tt class="prettyprint lang-java">Consumer</tt> "споживає" об'єкт та нічого не повертає; він має абстрактний метод "<tt class="prettyprint lang-java">accept</tt>", який приймає аргумент узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає тип <tt class="prettyprint lang-java">void</tt>.</li>
        <li><tt class="prettyprint lang-java">Function</tt> "оперує" аргументом та повертає результат; він має абстрактний метод "<tt class="prettyprint lang-java">apply</tt>", який приймає аргумент узагальненого типу <tt class="prettyprint lang-java">T</tt> та повертає узагальнений тип <tt class="prettyprint lang-java">R</tt>.</li>
        <li><tt class="prettyprint lang-java">Supplier</tt> "постачає": ниічого не приймає та щось повертає; він має абстрактний метод "<tt class="prettyprint lang-java">get</tt>", який не приймає аргументів та повертає узагальнений тип <tt class="prettyprint lang-java">T</tt>.</li>
        <li>Метод <tt class="prettyprint lang-java">forEach()</tt>, визначений в <tt class="prettyprint lang-java">Iterable</tt> (який реалізують класи колекцій), приймає <tt class="prettyprint lang-java">Consumer&lt;T&gt;</tt>.</li>
    </ul>
    
    <b>Розробка коду, який використовує примітивні версії функціональних інтерфейсів</b>
    
    <ul>
        <li>Вбудовані інтерфейси <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt> оперують об'єктами посилальних типів. Для примітивних типів існують спеціалізації цих функціональних інтерфейсів, доступні для типів <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt>.</li>
    
        <li>При використання інтерфейсу <tt class="prettyprint lang-java">Stream</tt> з примітивними типами виконується небажане пакуваання та розпакування примітивних типів до відповідних типів-обгорток. Внаслідок цього код стає повільнішим, а пам'ять витрачається на створення непотрібних об'єктів-обгорток. При можливості слід використовувати спеціалізації функціональних інтерфейсів <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt> для примітивних типів.</li>
    
        <li>Примітивні версії функціональних інтерфейсів <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt>, <tt class="prettyprint lang-java">Function</tt> та <tt class="prettyprint lang-java">Supplier</tt> доступні лише для типів <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> (також для типу <tt class="prettyprint lang-java">boolean</tt> для <tt class="prettyprint lang-java">Supplier</tt>). Слід використовувати неявне перетворення до відповідної версії <tt class="prettyprint lang-java">int</tt> при потребі у використанні типів <tt class="prettyprint lang-java">char</tt>, <tt class="prettyprint lang-java">byte</tt> або <tt class="prettyprint lang-java">short</tt>; також можна використовувати версію для типу <tt class="prettyprint lang-java">double</tt> при потребі у використанні <tt class="prettyprint lang-java">float</tt>.</li>
    </ul>
    
    <b>Розробка коду, який використовує бінарні версії функціональних інтерфейсів</b>
    
    <ul>
        <li>Функціональні інтерфейси <tt class="prettyprint lang-java">BiPredicate</tt>, <tt class="prettyprint lang-java">BiConsumer</tt> та <tt class="prettyprint lang-java">BiFunction</tt> є бінарними версіями <tt class="prettyprint lang-java">Predicate</tt>, <tt class="prettyprint lang-java">Consumer</tt> та <tt class="prettyprint lang-java">Function</tt> відповідно. Для <tt class="prettyprint lang-java">Supplier</tt> не існує бінарного еквіваленту оскільки він не приймає аргументів. Префікс "<tt class="prettyprint lang-java">Bi</tt>" вказує, що версія приймає два аргументи.</li>
    </ul>
    
    <b>Розробка коду, який використовує інтерфейс <tt class="prettyprint lang-java">UnaryOperator</tt></b>
    
    <ul>
        <li><tt class="prettyprint lang-java">UnaryOperator</tt> це функціональний інтерфейс, який розширює інтерфейс <tt class="prettyprint lang-java">Function</tt>.</li>
    
        <li>Спеціалізації інтерфейсу <tt class="prettyprint lang-java">UnaryOperator</tt> для примітивних типів це <tt class="prettyprint lang-java">IntUnaryOperator</tt>, <tt class="prettyprint lang-java">LongUnaryOperator</tt> та <tt class="prettyprint lang-java">DoubleUnaryOperator</tt> для типів <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">double</tt> відповідно.</li>
    </ul>

    <h1>Лекція 6</h1>
    <h1>Java Stream API</h1>

    <p>В цій главі розглядаються наступні питання:</p>

    <ul>
    	<li>Розробка коду для отримання даних з об'єкту з використанням методів <tt class="prettyprint lang-java">peek()</tt> та <tt class="prettyprint lang-java">map()</tt>, включаючи примітивні версії методу <tt class="prettyprint lang-java">map()</tt></li>
    	<li>Пошук даних за допомогою пошукових методів класів <tt class="prettyprint lang-java">Stream</tt>, включаючи <tt class="prettyprint lang-java">findFirst</tt>, <tt class="prettyprint lang-java">findAny</tt>, <tt class="prettyprint lang-java">anyMatch</tt>, <tt class="prettyprint lang-java">allMatch</tt>, <tt class="prettyprint lang-java">noneMatch</tt></li>
    	<li>Розробка коду, який використовує клас <tt class="prettyprint lang-java">Optional</tt></li>
    	<li>Розробка коду, який використовує методи даних та обчислень класів  <tt class="prettyprint lang-java">Stream</tt></li>
    	<li>Сортування колекції з використанням Stream API</li>
    	<li>Збереження результатів в колекцію з використанням методу <tt class="prettyprint lang-java">collect</tt> га групування/секціонування даних з використанням класу <tt class="prettyprint lang-java">Collectors</tt></li>
    	<li>Використання методів <tt class="prettyprint lang-java">flatMap()</tt> Stream API</li>
    </ul>

    <p>В цій главі ми обговоримо найбільш важливі доповнення до бібліотеки Java, зроблені в Java 8: потоковий API. Потоковий API є частиною пакету <tt class="prettyprint lang-java">java.util.stream</tt>. Ця глава зосереджена на ключовому інтерфейсі цього пакету: інтерфейсі <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt> (та його версііях для примітивних типів). Також в цій главі обговорюються такі класи як <tt class="prettyprint lang-java">Optional</tt> та <tt class="prettyprint lang-java">Collectors</tt>.</p>
    <p>Потоковий API вже був представлений в Главі 4 (Узагальнення та колекції). Потоковий API широко використовує вбудовані функціональні інтерфейси, які є частиною пакету <tt class="prettyprint lang-java">java.util.function</tt>, який обговорювався в попередній главі (Глава 5). Вважається, що перелічені глави вже прочитані.</p>

    <h2>Вибірка даних з потоку</h2>

    <p>Мета</p>

    <ul>
    	<li>Розробка коду для отримання даних з об'єкту з використанням методів peek() та map(), включаючи примітивні версії методу map()</li>
    </ul>

    <p>Почнемо з простого прикладу:</p>

    <pre class="prettyprint lang-java">
    long count = Stream.of(1, 2, 3, 4, 5).map(i -&gt; i * i).count();
    System.out.printf("В потоці %d елементів", count);
    </pre>

    <p>Цей фрагмент коду друкує:</p>

    <pre class="prettyprint lang-java">
    В потоці 5 елементів
    </pre>

    <p>Операція <tt class="prettyprint lang-java">map()</tt> в цьому потоці застосовує до його елементів надану як аргумент лямбда функцію. В даному випадку вона возводить в квадрат елементи потоку. Метод <tt class="prettyprint lang-java">count()</tt> повертає значення <tt class="prettyprint lang-java">5</tt> - воно зберігається в змінній та виводиться на консоль. Але як в цьому коді перевірити результат застосування проміжної операції <tt class="prettyprint lang-java">map()</tt>? Для цього можна використати метод <tt class="prettyprint lang-java">peek()</tt>:</p>

    <pre class="prettyprint lang-java">
    long count = Stream.of(1, 2, 3, 4, 5)
    		.map(i -&gt; i * i)
    		.peek(i -&gt; System.out.printf("%d ", i))
    		.count();
    System.out.printf("%nВ потоці %d елементів", count);
    </pre>

    <p>Цей код друкує</p>

    <pre class="prettyprint lang-java">
    1 4 9 16 25
    В потоці 5 елементів
    </pre>

    <p>Цей приклад також демонструє, як можна зв'язувати одну до одної проміжні операції. Це можливо оскільки проміжні операції повертають потоки.</p>

    <p>Тепер додамо ще один метод <tt class="prettyprint lang-java">peek()</tt> перед викликом методу <tt class="prettyprint lang-java">map()</tt> для розуміння, як він працює:</p>

    <pre class="prettyprint lang-java">
    Stream.of(1, 2, 3, 4, 5)
    		.peek(i -&gt; System.out.printf("%d ", i))
    		.map(i -&gt; i * i)
    		.peek(i -&gt; System.out.printf("%d ", i))
    		.count();
    </pre>

    <p>Цей код друкує</p>

    <pre class="prettyprint lang-java">
    1 1 2 4 3 9 4 16 5 25	
    </pre>

    <p>Як видно з виводу, потоковий конвейєр обробляє елементи один за одним. Кожен елемент співставляється зі своїм квадратом. Метод <tt class="prettyprint lang-java">peek()</tt> дозволяє зрозуміти, що обробляється в потоці без того, щоб його розбивати.</p>

    <p><hr/>
    	Метод <tt class="prettyprint lang-java">peek()</tt> в осномному прищначений для відладки. Він дозволяє зрозуміти, як трансформуються елементи на конвейєрі. Не використовуйте його про промисловому коді.
    	<hr/>
    </p>

    <p>Можна використовувати методи <tt class="prettyprint lang-java">map()</tt> та <tt class="prettyprint lang-java">peek()</tt> в примітивних версіях <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>; наприклад, наступний фрагмент використовує <tt class="prettyprint lang-java">DoubleStream</tt>:</p>

    <pre class="prettyprint lang-java">
    DoubleStream.of(1.0, 4.0, 9.0)
    		.map(Math::sqrt)
    		.peek(System.out::println)
    		.sum();
    </pre>

    <p>Цей код друкує <tt class="prettyprint lang-java">1.0</tt>, <tt class="prettyprint lang-java">2.0</tt> та <tt class="prettyprint lang-java">3.0</tt> на окремих рядках в консолі. <a href="#c06f01">Рисунок 6-1</a> візуалізує джерельну, проміжні та заключну операції потокового конвейєру.</p>

    <p><img id="c06f01" src="img/c06f01uk.jpg"><br/>
    Рисунок 6-1. Потоковий конвейєр з джерельною, проміжними та заключною операціями
    </p>

    <h2>Пошук даних в потоці</h2>

    <p>Мета</p>

    <ul>
    	<li>Пошук даних за допомогою пошукових методів класів Stream, включаючи findFirst, findAny, anyMatch, allMatch, noneMatch</li>
    </ul>

    <p>Методи із закінченням на "<tt class="prettyprint lang-java">Match</tt>" та методи з початком на "<tt class="prettyprint lang-java">find</tt>" в інтерфейсі <tt class="prettyprint lang-java">Stream</tt> корисні для пошуку даних в потоці (<a href="#c06t01">Таблиця 6-1</a>). Можна використовувати операції порівняння, такі як <tt class="prettyprint lang-java">anyMatch()</tt>, <tt class="prettyprint lang-java">allMatch()</tt> та <tt class="prettyprint lang-java">noneMatch()</tt> при пошуку елементів в потоці, які відповідають певній умові. Ці методи повертають значення <tt class="prettyprint lang-java">boolean</tt>. Для пошукових операцій <tt class="prettyprint lang-java">findFirst()</tt> та <tt class="prettyprint lang-java">findAny()</tt> відповідні елементи можуть бути відсутніми в <tt class="prettyprint lang-java">Stream</tt>, тож вони повертають <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt> (<tt class="prettyprint lang-java">Optional&lt;T&gt;</tt> розглядається в наступному розділі).</p>

    <table border="1">
    	<caption>Таблиця 6-1. Важливі методи відповідності та пошуку в інтерфейсіStream</caption>
    	<tr><th>Назва методу</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean anyMatch(Predicate<? super T> check)</tt></td><td>Повертає <tt class="prettyprint lang-java">true</tt> при наявноті в потоці будь-якого елементу, який відповідає наданому предикату. Повертає <tt class="prettyprint lang-java">false</tt>, якщо потік порожній, або в ньому немає відповідних елементів.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean allMatch(Predicate<? super T> check)</tt></td><td>Повертає <tt class="prettyprint lang-java">true</tt>, тільки якшо <em>всі</em> елементи потоку відповідають наданому предикату. Повертає <tt class="prettyprint lang-java">true</tt>, якщо потік порожній, без перевірки предикату!</td></tr>
    	<tr><td><tt class="prettyprint lang-java">boolean noneMatch(Predicate<? super T> check)</tt></td><td>Повертає <tt class="prettyprint lang-java">true</tt>, тілки якщо <em>жоден</em> з елементів потоку не відповідає наданому предикату. Повертає <tt class="prettyprint lang-java">true</tt>, якщо потік порожній, без перевірки предикату!</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Optional&lt;T&gt; findFirst()</tt></td><td>Повертає перший елемент потоку; якщо в потоці немає елементів, повертає порожній об'єкт <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">Optional&lt;T&gt; findAny()</tt></td><td>Повертає один з елементів потоку; якщо в потоці немає елементів, повертає порожній об'єкт <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>.</td></tr>
    </table>

    <p><hr/>На відміну від методу <tt class="prettyprint lang-java">anyMatch()</tt>, який повертає <tt class="prettyprint lang-java">false</tt> при порожньому потоку, методи <tt class="prettyprint lang-java">allMatch()</tt> та <tt class="prettyprint lang-java">noneMatch()</tt> повертають <tt class="prettyprint lang-java">true</tt>, якщо потік порожній!<hr/></p>

    <p>Нижче проста програма, яка демонструє, як використовувати методи <tt class="prettyprint lang-java">anyMatch()</tt>, <tt class="prettyprint lang-java">allMatch()</tt > та <tt class="prettyprint lang-java">noneMatch()</tt> (<a href="#Lisintg0601">Лістинг 6-1)</a>.</p>

    <pre class="prettyprint lang-java" id="c06l01">
    // Лістинг 6-1. MatchUse.java
    import java.util.stream.IntStream;

    public class MatchUse {
        public static void main(String []args) {
            // Середні температури на станції Конкордія в Антарктиці за тиждень в жовтні 2015
            boolean anyMatch
                    = IntStream.of(-56, -57, -55, -52, -48, -51, -49).anyMatch(temp -&gt; temp &gt; 0);
            System.out.println("anyMatch(temp -&gt; temp &gt; 0): " + anyMatch);

            boolean allMatch
                    = IntStream.of(-56, -57, -55, -52, -48, -51, -49).allMatch(temp -&gt; temp &gt; 0);
            System.out.println("allMatch(temp -&gt; temp &gt; 0): " + allMatch);

            boolean noneMatch
                    = IntStream.of(-56, -57, -55, -52, -48, -51, -49).noneMatch(temp -&gt; temp &gt; 0);
            System.out.println("noneMatch(temp -&gt; temp &gt; 0): " + noneMatch);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    anyMatch(temp -&gt; temp &gt; 0): false
    allMatch(temp -&gt; temp &gt; 0): false
    noneMatch(temp -&gt; temp &gt; 0): true
    </pre>

    <p>Оскільки всі надані значення температури від'ємні, методи <tt class="prettyprint lang-java">anyMatch()</tt> та <tt class="prettyprint lang-java">allMatch()</tt> повертають <tt class="prettyprint lang-java">false</tt>, в той час як <tt class="prettyprint lang-java">noneMatch()</tt> повертає <tt class="prettyprint lang-java">true</tt>.</p>

    <p>Методи <tt class="prettyprint lang-java">findFirst()</tt> та <tt class="prettyprint lang-java">findAny()</tt> корисні для пошуку елементів в потоці. Нижче програма, яка використовує метод <tt class="prettyprint lang-java">findFirst()</tt> (<a href="#c06l02">Лістинг 6-2</a>).</p>

    <pre class="prettyprint lang-java" id="c06l02">
    // Лістинг 6-2. FindFirstUse1.java
    import java.lang.reflect.Method;
    import java.util.Arrays;
    import java.util.Optional;
    import java.util.stream.Stream;

    public class FindFirstUse1 {
        public static void main(String []args) {
            Method[] methods = Stream.class.getMethods();
            Optional&lt;String&gt; methodName = Arrays.stream(methods)
                    .map(method -&gt; method.getName())
                    .filter(name -&gt; name.endsWith("Match"))
                    .sorted()
                    .findFirst();
            System.out.println("Result: " + methodName.orElse("No suitable method found"));
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    Result: allMatch
    </pre>

    <p>В цій програмі отримується список методів <tt class="prettyprint lang-java">Stream</tt> за допомогою рефлексії. Потім з використанням методу <tt class="prettyprint lang-java">map()</tt> отримується список методів, чиї імена закінчуються на "<tt class="prettyprint lang-java">Match</tt>", сортується та повертається перший знайдений метод. Якщо шукати метод, який закінчіується на "<tt class="prettyprint lang-java">Match</tt>", можна використати метод <tt class="prettyprint lang-java">findAny()</tt>.</p>

    <p><hr/>Навіщо в пакеті <tt class="prettyprint lang-java">java.util.function</tt> обидва методи <tt class="prettyprint lang-java">findFirst()</tt> та <tt class="prettyprint lang-java">findAny()</tt>? В паралельних потоках <tt class="prettyprint lang-java">findAny()</tt> швидший за <tt class="prettyprint lang-java">findFirst()</tt> (паралельні потоки розглядаютсья в Главі 11).<hr/></p>

    <p><a href="#c06l03">Лістинг 6-3</a> має потік з багатьма <tt class="prettyprint lang-java">double</tt> значеннями температури. Використовуючи <tt class="prettyprint lang-java">findFirst()</tt>, проводиться пошук будь-якої температури, більшої за <tt class="prettyprint lang-java">0</tt>. Що надрукує наступна програма?</p>

    <pre class="prettyprint lang-java" id="c06l03">
    // Лістинг 6-3. FindFirstUse2.java
    import java.util.OptionalDouble;
    import java.util.stream.DoubleStream;

    public class FindFirstUse2 {
        public static void main(String []args) {
            OptionalDouble temperature = DoubleStream.of(-10.1, -5.4, 6.0, -3.4, 8.9, 2.2)
                    .filter(temp -&gt; temp &gt; 0)
                    .findFirst();
            System.out.println("Перша температура &gt; 0 це " + temperature.getAsDouble());
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">Перша температура > 0 це 6.0
    </pre>

    <p>В цьому потоці значень <tt class="prettyprint lang-java">double</tt> метод <tt class="prettyprint lang-java">filter()</tt> відфільтровує елементи <tt class="prettyprint lang-java">-10.1</tt> та <tt class="prettyprint lang-java">-5.4</tt> оскільки умова <tt class="prettyprint lang-java">temp &gt; 0</tt> дорівнює <tt class="prettyprint lang-java">false</tt>. Для елемента <tt class="prettyprint lang-java">6.0</tt> метод <tt class="prettyprint lang-java">filter()</tt> обчислює умову в <tt class="prettyprint lang-java">true</tt> та <tt class="prettyprint lang-java">findFirst()</tt> повертає цей елемент. Зверніть увагу, що інші елементи ігноруються в цьому потоковому ковейєрі: елементи <tt class="prettyprint lang-java">8.9</tt> та <tt class="prettyprint lang-java">2.2</tt> також відповідають умові <tt class="prettyprint lang-java">temp &gt; 0</tt>, але потоковий конвейєр вже зачинений після того, як метод <tt class="prettyprint lang-java">findFirst()</tt> повернув значення <tt class="prettyprint lang-java">6.0</tt>. Іншими словами, такі пошукові методи як <tt class="prettyprint lang-java">findFirst()</tt> є швидкими. Одразу після отримання результату елементи, що залишилися в потоці, не обробляються.</p>

    <p><hr/>Методи "<tt class="prettyprint lang-java">match</tt>" та "<tt class="prettyprint lang-java">find</tt>" для пошуку елементів швидкі за природою. За рахунок чого? Обчислення припиняються одразу пілся знаходження результату (та залишок не обчислюється). Ви вже знайомі з швидкими операторами <tt class="prettyprint lang-java">&amp;&amp;</tt> та <tt class="prettyprint lang-java">||</tt>. Наприклад, у виразі <tt class="prettyprint lang-java">((s != null) &amp;&amp; (s.length() &gt; 0))</tt>, якщо <tt class="prettyprint lang-java">String</tt> <tt class="prettyprint lang-java">s</tt> є <tt class="prettyprint lang-java">null</tt>, то умова <tt class="prettyprint lang-java">(s != null)</tt> обчислюється в <tt class="prettyprint lang-java">false</tt>; отже, <tt class="prettyprint lang-java">false</tt> є результатом всього виразу. Залишок виразу <tt class="prettyprint lang-java">(s.length() &gt; 0)</tt> в цьому випадку не обчислюється.<hr/></p>

    <p>В Лістингах <a href="#c06l02">6-2</a> та <a href="#c06l03">6-3</a> використовуються класи <tt class="prettyprint lang-java">Optional</tt> та <tt class="prettyprint lang-java">OptionalDouble</tt>; обговоримо їх.</p>

    <h2>Клас Optional</h2>

    <p>Мета</p>

    <ul>
    	<li>Розробка коду, який використовує клас Optional</li>
    </ul>

    <p>Клас <tt class="prettyprint lang-java">java.util.Optional</tt> містить значення, яке може бути <tt class="prettyprint lang-java">null</tt>. В класах пакету <tt class="prettyprint lang-java">java.util.stream</tt> є багато методів, які повертають значення <tt class="prettyprint lang-java">Optional</tt>. Наведемо приклад.</p>

    <p>Розглянемо метод:</p>

    <pre class="prettyprint lang-java">
    public static void selectHighestTemperature(Stream&lt;Double&gt; temperatures) {
    	System.out.println(temperatures.max(Double::compareTo));
    }
    </pre>

    <p>Виклик цього методу:</p>

    <pre class="prettyprint lang-java">
    selectHighestTemperature(Stream.of(24.5, 23.6, 27.9, 21.1, 23.5, 25.5, 28.3));
    </pre>

    <p>Цей код друкує:</p>

    <pre class="prettyprint lang-java">Optional[28.3]</pre>

    <p>Метод <tt class="prettyprint lang-java">max()</tt> в <tt class="prettyprint lang-java">Stream</tt> приймає <tt class="prettyprint lang-java">Comparator</tt> як аргумент та повертає <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>:</p>

    <pre class="prettyprint lang-java">Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</pre>

    <p>Чому повертається тип <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>, а не <tt class="prettyprint lang-java">T</tt>? Тому що метод <tt class="prettyprint lang-java">max()</tt> може схибити в пошуку максимального значення (при порожньому потоці, наприклад):</p>

    <pre class="prettyprint lang-java">selectHighestTemperature(Stream.of());</pre>

    <p>Тепер цей код надрукує:</p>

    <pre class="prettyprint lang-java">Optional.empty</pre>

    <p>Для отримання значення з <tt class="prettyprint lang-java">Optional</tt> використовуються методи <tt class="prettyprint lang-java">isPresent()</tt> та <tt class="prettyprint lang-java">get()</tt>:</p>

    <pre class="prettyprint lang-java">
    public static void selectHighestTemperature(Stream&lt;Double&gt; temperatures) {
    	Optional&lt;Double&gt; max = temperatures.max(Double::compareTo);
    	if(max.isPresent()) {
    		System.out.println(max.get());
    	}
    }
    </pre>

    <p>Кожен раз писати перевірку умови втомливо (та не відповідає функціональному стилю), тож можна використовувати метод <tt class="prettyprint lang-java">ifPresent</tt> для написання спрощеного коду:</p>

    <pre class="prettyprint lang-java">
    max.ifPresent(System.out::println);
    </pre>

    <p>Цей метод <tt class="prettyprint lang-java">ifPresent()</tt> в <tt class="prettyprint lang-java">Optional</tt> приймає аргумент <tt class="prettyprint lang-java">Consumer&lt;T&gt;</tt>. Також можна використовувати такі методи як <tt class="prettyprint lang-java">orElse()</tt> та <tt class="prettyprint lang-java">orElseThrow()</tt>, які будуть розглянуті трохи пізніше, після обговорення створення об'єктів <tt class="prettyprint lang-java">Optional</tt>.</p>

    <h3>Створення об'єктів Optional</h3>

    <p>Існує багато способів створення об'єктів <tt class="prettyprint lang-java">Optional</tt>. Один з них - використання фабричних методів в класі <tt class="prettyprint lang-java">Optional</tt>:</p>

    <pre class="prettyprint lang-java">
    Optional&lt;String&gt; empty = Optional.empty();
    </pre>

    <p>Також можна використовувати <tt class="prettyprint lang-java">of()</tt> в класі <tt class="prettyprint lang-java">Optional</tt>:</p>

    <pre class="prettyprint lang-java">
    Optional&lt;String&gt; nonEmptyOptional = Optional.of("abracadabra");
    </pre>

    <p>Однак, не можна передавати <tt class="prettyprint lang-java">null</tt> в метод <tt class="prettyprint lang-java">Optional.of()</tt>:</p>

    <pre class="prettyprint lang-java">
    Optional&lt;String&gt; nullStr = Optional.of(null);
    System.out.println(nullStr);
    // помилка NullPointerException
    </pre>

    <p>Це призведе до виникнення помилки <tt class="prettyprint lang-java">NullPointerException</tt>. Якщо треба створити об'єкт <tt class="prettyprint lang-java">Optional</tt>, який може мати значення <tt class="prettyprint lang-java">null</tt>, слід використовувати метод <tt class="prettyprint lang-java">ofNullable()</tt>:</p>

    <pre class="prettyprint lang-java">
    Optional&lt;String&gt; nullableStr = Optional.ofNullable(null);
    System.out.println(nullableStr);
    // prints: Optional.empty
    </pre>

    <p><a href="#c06f02">Рисунок 6-2</a> показує представлення об'єктів <tt class="prettyprint lang-java">Optional&lt;String&gt;</tt>, на які вказують <tt class="prettyprint lang-java">nonEmptyOptional</tt>, <tt class="prettyprint lang-java">nullStr</tt > та <tt class="prettyprint lang-java">nullableStr</tt>.</p>

    <p><img id="c06f02" src="img/c06f02.jpg"/><br/>
    Рисунок 6-2. Представлення трьох об'єктів Optional&lt;String&gt;</p>

    <h3>Потік Optional</h3>

    <p>Також можна розглядати <tt class="prettyprint lang-java">Optional</tt> як потік, який може мати нуль або один елемент. Тож можна застосовувати на потоці такі методи як <tt class="prettyprint lang-java">map()</tt>, <tt class="prettyprint lang-java">filter()</tt > та <tt class="prettyprint lang-java">flatMap()</tt>! Навіщо? Приклад (<a href="#c06l04">Лістинг 6-4</a>):</p>

    <pre class="prettyprint lang-java" id="c06l04">
    // Лістинг 6-4. OptionalStream.java
    import java.util.Optional;

    public class OptionalStream {
        public static void main(String []args) {
            Optional&lt;String&gt; string = Optional.of(" abracadabra ");
            string.map(String::trim).ifPresent(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">abracadabra</pre>

    <p>Можна використовувати методи <tt class="prettyprint lang-java">orElse()</tt> чи <tt class="prettyprint lang-java">orElseThrow()</tt>, коли ці операції схиблять (наприклад, коли базовий <tt class="prettyprint lang-java">Optional</tt> містить значення <tt class="prettyprint lang-java">null</tt>):</p>

    <pre class="prettyprint lang-java">
    Optional&lt;String&gt; string = Optional.ofNullable(null);
    System.out.println(string.map(String::length).orElse(-1));
    </pre>

    <p>Цей код друкує <tt class="prettyprint lang-java">-1</tt> оскільки змінна стрічка є змінною <tt class="prettyprint lang-java">Optional</tt>, яка містить <tt class="prettyprint lang-java">null</tt>, отже метод <tt class="prettyprint lang-java">orElse()</tt> виконується та повертає <tt class="prettyprint lang-java">-1</tt>. Альтернативно, можна викликати виключення через метод <tt class="prettyprint lang-java">orElseThrow()</tt>:</p>

    <pre class="prettyprint lang-java">
    Optional&lt;String&gt; string = Optional.ofNullable(null);
    System.out.println(string.map(String::length).orElseThrow(IllegalArgumentException::new));
    </pre>

    <p>Цей фрагмент коду викликає <tt class="prettyprint lang-java">IllegalArgumentException</tt>. Викликати такі методи як <tt class="prettyprint lang-java">map()</tt>, <tt class="prettyprint lang-java">flatMap()</tt> чи <tt class="prettyprint lang-java">filter()</tt> на об'єкті <tt class="prettyprint lang-java">Optional</tt> корисно, коди маєте справу з об'єктом <tt class="prettyprint lang-java">Optional</tt>, який повертає якась функція, та не відомо, що він містить.</p>

    <h3>Примітивні версії Optional&lt;T&gt;</h3>

    <p>В попередньо розглянутому коді використовувалися типи <tt class="prettyprint lang-java">Stream&lt;Double&gt;</tt> та <tt class="prettyprint lang-java">Optional&lt;Double&gt;</tt>:</p>

    <pre class="prettyprint lang-java">
    public static void selectHighestTemperature(Stream&lt;Double&gt; temperatures) {
    	Optional&lt;Double&gt; max = temperatures.max(Double::compareTo);
    	if(max.isPresent()) {
    		System.out.println(max.get());
    	}
    }
    </pre>

    <p>Краще використовувати <tt class="prettyprint lang-java">DoubleStream</tt> та <tt class="prettyprint lang-java">OptionalDouble</tt>, які є примітивними версіями для <tt class="prettyprint lang-java">double</tt> для <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt> та <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt> відповідно. Інші дві версії для примітивних типів доступні для <tt class="prettyprint lang-java">int</tt> та <tt class="prettyprint lang-java">long</tt> називаються <tt class="prettyprint lang-java">OptionalInt</tt> та <tt class="prettyprint lang-java">OptionalLong</tt> відповідно. Отже, код може бути переписаний:</p>

    <pre class="prettyprint lang-java">
    public static void selectHighestTemperature(DoubleStream temperatures) {
    	OptionalDouble max = temperatures.max();
    	max.ifPresent(System.out::println);
    }
    </pre>

    <p>Його виклик:</p>

    <pre class="prettyprint lang-java">selectHighestTemperature(DoubleStream.of(24.5, 23.6, 27.9, 21.1, 23.5, 25.5, 28.3));</pre>

    <p>Максимальне значення правильно друкується на консолі:</p>

    <pre class="prettyprint lang-java">28.3</pre>

    <p>Як метод <tt class="prettyprint lang-java">max()</tt> в <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>, який повертає <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>, метод <tt class="prettyprint lang-java">max()</tt> в <tt class="prettyprint lang-java">DoubleStream</tt> повертає <tt class="prettyprint lang-java">OptionalDouble</tt>.</p>

    <h2>Методи даних та обчислень в потоці</h2>

    <p>Мета</p>

    <ul>
    	<li>Розробка коду, який використовує методи даних та обчислень класів  Stream</li>
    </ul>

    <p>Інтерфейс <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt> має методи даних та обчислень <tt class="prettyprint lang-java">count()</tt>, <tt class="prettyprint lang-java">min()</tt> та <tt class="prettyprint lang-java">max()</tt>. Методи <tt class="prettyprint lang-java">min()</tt> та <tt class="prettyprint lang-java">max()</tt> приймають об'єкт <tt class="prettyprint lang-java">Comparator</tt> як аргумент та повертають <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>. Приклад використання цих методів (<a href="#c06l05">Лістинг 6-5</a>).</p>

    <pre class="prettyprint lang-java" id="c06l05">
    // Лістинг 6-5. WordsCalculation.java
    import java.util.Arrays;

    public class WordsCalculation {
        public static void main(String []args) {
            String[] string = "ви ніколи не перерахуєте своє майно, доки не прибиретеся у кімнаті".split(" ");
            System.out.println(Arrays.stream(string).min(String::compareTo).get());
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">ви</pre>

    <p>Оскільки метод <tt class="prettyprint lang-java">min()</tt> потребує спосіб порівняння елементів в потоці, в цій програмі передається посилання на метод <tt class="prettyprint lang-java">String::compareTo</tt>. Оскільки метод <tt class="prettyprint lang-java">min()</tt> повертає <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt>, для отримання стрічки результату використовується метод <tt class="prettyprint lang-java">get()</tt>. Оскільки <tt class="prettyprint lang-java">String::compareTo</tt> порівнює дві стрічки лексикографічно, як результат отримуємо "ви".</p>

    <p>Нижче наведено змінений фрагмент коду, який порівнює стрічки не лексикографічно, а за їх довжиною:</p>

    <pre class="prettyprint lang-java">
    Comparator&lt;String&gt; lengthCompare = (str1, str2) -&gt; str1.length() - str2.length();
    System.out.println(Arrays.stream(string).min(lengthCompare).get());
    </pre>

    <p>З цією зміною програма друкує "у", оскільки це найкоротше слово в наданій стрічці.</p>

    <p>Існують додаткові методи даних та обчислень, такі як <tt class="prettyprint lang-java">sum()</tt> та <tt class="prettyprint lang-java">average()</tt>, запропоновані для примітивних версій інтерфейсу <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt>. <a href="#c06t02">Таблиця 6-2</a> перелічує важливі методи інтерфейсу <tt class="prettyprint lang-java">IntStream</tt>, які обговорюються в цьому розділі.</p>

    <table border="1" id="c06t02">
    	<caption>Таблиця 6-2. Важливі методи даних та обчислень в інтерфейсі <tt class="prettyprint lang-java">IntStream</tt></caption>
    	<tr><th>Method</th><th>Опис</th></tr>
    	<tr><td><tt class="prettyprint lang-java">int sum()</tt></td><td>Повертає суму елементів в потоці; <tt class="prettyprint lang-java">0</tt> в разі порожнього потоку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">long count()</tt></td><td>Повертає кількість елементів в потоці; <tt class="prettyprint lang-java">0</tt> для порожнього потоку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">OptionalDouble average()</tt></td><td>Повертає середнє значення елементів в потоці; порожнє значення <tt class="prettyprint lang-java">OptionalDouble</tt> в разі порожнього потоку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">OptionalInt min()</tt></td><td>Повертає мінімальне ціле значення в потоці; порожне значення <tt class="prettyprint lang-java">OptionalInt</tt> в разі порожнього потоку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">OptionalInt max()</tt></td><td>Повертає максимальне ціле значення в потоці; порожнє значення <tt class="prettyprint lang-java">OptionalInt</tt> в разі порожнього потоку.</td></tr>
    	<tr><td><tt class="prettyprint lang-java">IntSummaryStatistics<br/>
    	summaryStatistics()</tt></td><td>Повертає об'єкт <tt class="prettyprint lang-java">IntSummaryStatistics</tt>, який має значення <tt class="prettyprint lang-java">sum</tt>, <tt class="prettyprint lang-java">count</tt>, <tt class="prettyprint lang-java">average</tt>, <tt class="prettyprint lang-java">min</tt > та <tt class="prettyprint lang-java">max</tt>.</td></tr>
    </table>

    <p>Інтерфейси <tt class="prettyprint lang-java">LongStream</tt> та <tt class="prettyprint lang-java">DoubleStream</tt> мають схожі до перелічених в цій таблиці для <tt class="prettyprint lang-java">IntStream</tt> методи (<a href="#c06t02">Таблиця 6-2</a>). Проста програма, яка використовує їх (<a href="#c06l06">Лістинг 6-6</a>).</p>

    <pre class="prettyprint lang-java" id="c06l06">
    // Лістинг 6-6. WordStatistics.java
    import java.util.IntSummaryStatistics;
    import java.util.regex.Pattern;

    public class WordStatistics {
        public static void main(String []args) {
            String limerick = "Депутат фолькетинга із Данії " +
                    "Знаторів в каббалі та гаданні " +
                    "та друзякам з парламенту " +
                    "По сторінках регламенту " +
                    "Пророкує бюджетні бодання. ";

            IntSummaryStatistics wordStatistics =
                    Pattern.compile(" ")
                    .splitAsStream(limerick)
                    .mapToInt(word -&gt; word.length())
                    .summaryStatistics();

            System.out.printf(" Кількість слів = %d \n Сумарна довжина слів = %d \n" +
                    " Мінімальна довжина слова = %d \n Максимальна довжина слова %d \n" +
                    " Середня довжина слова = %f \n", wordStatistics.getCount(),
                    wordStatistics.getSum(), wordStatistics.getMin(),
                    wordStatistics.getMax(), wordStatistics.getAverage());
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
     Кількість слів = 19 
     Сумарна довжина слів = 116 
     Мінімальна довжина слова = 1 
     Максимальна довжина слова 11 
     Середня довжина слова = 6,105263 
    </pre>

    <p>Після формування потоку слів методом <tt class="prettyprint lang-java">splitAsStream()</tt> в класі <tt class="prettyprint lang-java">Pattern</tt> ця програма викликає метод <tt class="prettyprint lang-java">mapToInt()</tt> для перетворення слів в їх довжини. Чому метод <tt class="prettyprint lang-java">mapToInt()</tt>, а не <tt class="prettyprint lang-java">map()</tt>? Метод <tt class="prettyprint lang-java">map()</tt> повертає <tt class="prettyprint lang-java">Stream</tt>, але нам потрібно провести обчислення над базовими елементами потоку. Інтерфейс <tt class="prettyprint lang-java">Stream</tt> не має методів для проведення обчислень, але його версії для примітивних типів мають методи даних та обчислень. Отже, викликається метод <tt class="prettyprint lang-java">mapToInt()</tt>, який повертає <tt class="prettyprint lang-java">IntStream</tt>: <tt class="prettyprint lang-java">IntStream</tt> має багато корисних методів даних та обчислень (перелічені в <a href="#c06t02">Таблиці 6-2</a>). Викликаєтсья метод <tt class="prettyprint lang-java">summaryStatistics()</tt> в <tt class="prettyprint lang-java">IntStream</tt>. Наприкінці, викликаються різноманітні методи, такі як <tt class="prettyprint lang-java">sum()</tt> та <tt class="prettyprint lang-java">average()</tt> для об'єкту, який повернувся - <tt class="prettyprint lang-java">IntSummaryStatistics</tt>, для підведення підсумків щодо слів в наданому лімерику.</p>

    <p>Також можна безпосередньо викликати такі методи як <tt class="prettyprint lang-java">sum()</tt> та <tt class="prettyprint lang-java">average()</tt>, запропоновані в <tt class="prettyprint lang-java">IntStream</tt>:</p>

    <pre class="prettyprint lang-java">
    IntStream.of(10, 20, 30, 40).reduce(0, ((sum, val) -&gt; sum + val));
    </pre>

    <p>Навіщо потоковий API пропонує метод <tt class="prettyprint lang-java">reduce()</tt>, коли можна використовувати такі методи як <tt class="prettyprint lang-java">sum()</tt>, які більш лаконічні, зручні та легко читаються?</p>

    <p>Відповідь у тому, що <tt class="prettyprint lang-java">reduce()</tt> це біль загальний метод: його можна використовувати при необхідності виконувати повторні операції над елементами потоку для обчислення результату. Розглянемо факторіал <tt class="prettyprint lang-java">5</tt>. Не існує методу як <tt class="prettyprint lang-java">sum()</tt> в <tt class="prettyprint lang-java">IntStream</tt>, який допоможе помножити всі значення. В цьому випадку можна використати метод <tt class="prettyprint lang-java">reduce()</tt>:</p>

    <pre class="prettyprint lang-java">
    // factorial of 5
    System.out.println(IntStream.rangeClosed(1, 5).reduce((x, y) -&gt; (x * y)).getAsInt());
    // друкує: 120
    </pre>

    <p>Фактично метод <tt class="prettyprint lang-java">sum()</tt> в <tt class="prettyprint lang-java">IntStream</tt> внутрішньо реалізований з викликом методу <tt class="prettyprint lang-java">reduce()</tt> (в класі <tt class="prettyprint lang-java">IntPipeline</tt>):</p>

    <pre class="prettyprint lang-java">
    @Override
    public final int sum() {
    	return reduce(0, Integer::sum);
    }
    </pre>

    <p>В цьому випадку метод <tt class="prettyprint lang-java">sum()</tt> реалізований через надання посилання на метод <tt class="prettyprint lang-java">Integer::sum</tt> в якості другого аргументу методу<tt class="prettyprint lang-java">reduce()</tt>.</p>

    <p><hr/>Операції редукції (aka "редуктори") можуть бути явними чи неявними. Такі методи як <tt class="prettyprint lang-java">sum()</tt>, <tt class="prettyprint lang-java">min()</tt> та <tt class="prettyprint lang-java">max()</tt> в <tt class="prettyprint lang-java">IntStream</tt> це приклади неявних редукторів. При використанні методу <tt class="prettyprint lang-java">reduce()</tt> безпосередньо в коді використовуються явні редуктори. Неявні редуктори можна перетворити на еквівалентні явні редуктори.<hr/></p>

    <h2>Сортування колекції з використанням Stream API</h2>

    <p>Мета</p>

    <ul>
    	<li>Сортування колекції з використанням Stream API</li>
    </ul>

    <p>В Главі 4 (про узагальнення та колекції) обговорювалося, як сортувати колекцію з використанням інтерфейсів <tt class="prettyprint lang-java">Comparator</tt> та <tt class="prettyprint lang-java">Comparable</tt>. <tt class="prettyprint lang-java">Streams</tt> спрощує завдання сортування колекції. Нижче наведено програму, яка сортує стрічки з лексикографічним порівнянням (<a href="#c06l07">Лістинг 6-7</a>).</p>

    <pre class="prettyprint lang-java" id="c06l07">
    // Лістинг 6-7. SortingCollection.java
    import java.util.Arrays;
    import java.util.List;

    public class SortingCollection {
        public static void main(String []args) {
            List words =
                Arrays.asList("слідуй за своїм серцем але із своїм мозком".split(" "));
            words.stream().distinct().sorted().forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    але
    за
    мозком
    своїм
    серцем
    слідуй
    із
    </pre>

    <p>В цьому коді слова це колекція типу <tt class="prettyprint lang-java">List</tt>. Спочатку отримується потік з того списку з використанням методу <tt class="prettyprint lang-java">stream()</tt>, потім викликається метод <tt class="prettyprint lang-java">distinct()</tt> для усунення дублікатів (слово "своїм" повторюється в колекції). Потім викликається метод <tt class="prettyprint lang-java">sorted()</tt>.</p>

    <p>Метод <tt class="prettyprint lang-java">sorted()</tt> сортує елементи за "природнім порядком"; метод <tt class="prettyprint lang-java">sorted()</tt> потребує, щоб елементи в потоці реалізовували інтерфейс <tt class="prettyprint lang-java">Comparable</tt>. Як сортувати елементи в якомось іншому порядку? Для цього можна викликати перевантажений метод <tt class="prettyprint lang-java">sorted</tt>, який приймає аргумент <tt class="prettyprint lang-java">Comparator</tt>:</p>

    <pre class="prettyprint lang-java">
    Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)
    </pre>

    <p>Нижче (<a href="#c06l08">Лістинг 6-8</a>) наведено модифіковану версію попередньої програми (в <a href="#c06l07">Лістингу 6-7</a>), яка сортує елементи за довжиною стрічки.</p>

    <pre class="prettyprint lang-java" id="c06l08">
    // Лістинг 6-8. SortByLength.java
    import java.util.Arrays;
    import java.util.List;
    import java.util.Comparator;

    public class SortByLength {
        public static void main(String []args) {
            List words =
                Arrays.asList("слідуй за своїм серцем але із своїм мозком".split(" "));
            Comparator&lt;String&gt; lengthCompare = (str1, str2) -&gt; str1.length() - str2.length();
            words.stream().distinct().sorted(lengthCompare).forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    за
    із
    але
    своїм
    слідуй
    серцем
    мозком
    </pre>

    <p>В цьому виводі слова відсортовані за їх довжиною. Слово "слідуй" з'являється перед словом "серцем", хоча вони мають однакову довжину. Якщо треба спочатку відсортувати слова за довжиною, а потім в природньому порядку? Для цього можна використати метод по замовчанню <tt class="prettyprint lang-java">thenComparing()</tt>, запропонований в інтерфейсі <tt class="prettyprint lang-java">Comparator</tt> (<a href="#c06l09">Лістинг 6-9</a>).</p>

    <pre class="prettyprint lang-java" id="c06l09">
    // Лістинг 6-9. SortByLengthThenNatural.java
    import java.util.Arrays;
    import java.util.Comparator;
    import java.util.List;

    public class SortByLengthThenNatural {
        public static void main(String []args) {
            List words =
                    Arrays.asList("слідуй за своїм серцем але із своїм мозком".split(" "));
            Comparator&lt;String&gt; lengthCompare = (str1, str2) -&gt; str1.length() - str2.length();
            words.stream()
                    .distinct()
                    .sorted(lengthCompare.thenComparing(String::compareTo))
                    .forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    за
    із
    але
    своїм
    мозком
    серцем
    слідуй
    </pre>

    <p>А якщо треба розгорнути цей порядок? На щастя, інтерфейс <tt class="prettyprint lang-java">Comparator</tt> в Java 8 був поліпшений багатьма корисними методами по замовчанню та статичними методами. Один з таких доданих методів <tt class="prettyprint lang-java">reversed()</tt> та його й слід використати (<a href="#c06l10">Лістинг 6-10</a>).</p>

    <pre class="prettyprint lang-java" id="c06l10">
    // Лістинг 6-10. SortByLengthThenNaturalReversed.java
    import java.util.Arrays;
    import java.util.Comparator;
    import java.util.List;

    public class SortByLengthThenNaturalReversed {
        public static void main(String []args) {
            List words =
                    Arrays.asList("слідуй за своїм серцем але із своїм мозком".split(" "));
            Comparator&lt;String&gt; lengthCompare = (str1, str2) -&gt; str1.length() - str2.length();
            words.stream()
                    .distinct()
                    .sorted(lengthCompare.thenComparing(String::compareTo).reversed())
                    .forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    слідуй
    серцем
    мозком
    своїм
    але
    із
    за
    </pre>

    <h2>Збереження результатів в колекцію</h2>

    <p>Мета</p>

    <ul>
    	<li>Збереження результатів в колекцію з використанням методу collect та групування/секціонування даних з використанням класу Collectors</li>
    </ul>

    <p>Клас <tt class="prettyprint lang-java">Collectors</tt> має методи, які підтримують задачу збору елементів до колекції. Для створення колекції з потоку можна використовувати такі методи як <tt class="prettyprint lang-java">toList()</tt>, <tt class="prettyprint lang-java">toSet()</tt>, <tt class="prettyprint lang-java">toMap()</tt > та <tt class="prettyprint lang-java">toCollection()</tt>. Нижче наведено простий приклад, який створює <tt class="prettyprint lang-java">List</tt> х потоку та повертає його (<a hreg="#c06l11">Лістинг 6-11</a>). Цей код використовує метод <tt class="prettyprint lang-java">collect()</tt> з <tt class="prettyprint lang-java">Stream</tt> та метод <tt class="prettyprint lang-java">toList()</tt> з класу <tt class="prettyprint lang-java">Collectors</tt>.</p>

    <pre class="prettyprint lang-java" id="c06l11">
    // Лістинг 6-11. CollectorsToList.java
    import java.util.stream.Collectors;
    import java.util.regex.Pattern;
    import java.util.List;

    public class CollectorsToList {
        public static void main(String []args) {
            String frenchCounting = "un:deux:trois:quatre";
            List gmailList = Pattern.compile(":")
                    .splitAsStream(frenchCounting)
                    .collect(Collectors.toList());
            gmailList.forEach(System.out::println);
        }
    }
    </pre>

    <p>Метод <tt class="prettyprint lang-java">collect()</tt> в <tt class="prettyprint lang-java">Stream</tt> приймає аргумент <tt class="prettyprint lang-java">Collector</tt>:</p>

    <pre class="prettyprint lang-java">
    &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);
    </pre>

    <p>В цьому коді для збору елементів з потоку в <tt class="prettyprint lang-java">List</tt> використовується метод <tt class="prettyprint lang-java">toList()</tt> в класі <tt class="prettyprint lang-java">Collectors</tt>.</p>

    <p>Нижче наведено приклад, який використовує метод <tt class="prettyprint lang-java">Collectors.toSet()</tt> (<a href="#c06l12">Лістинг 6-12</a>):</p>

    <pre class="prettyprint lang-java" id="c06l12">
    // Лістинг 6-12. CollectorsToSet.java
    import java.util.Arrays;
    import java.util.Set;
    import java.util.stream.Collectors;

    public class CollectorsToSet {
        public static void main(String []args) {
            String []roseQuote = "a rose is a rose is a rose".split(" ");
            Set words = Arrays.stream(roseQuote).collect(Collectors.toSet());
            words.forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    a
    rose
    is
    </pre>

    <p>Цей код перетворює речення, надане як стрічка, в потік слів. Викликається метод <tt class="prettyprint lang-java">Collectors.toSet()</tt> всередині методу <tt class="prettyprint lang-java">collect()</tt>, який збирає слова в <tt class="prettyprint lang-java">Set</tt>. Оскільки <tt class="prettyprint lang-java">Set</tt> видаляє дублікати, ця програма друкує в консоль лише слова "<tt class="prettyprint lang-java">a</tt>", "<tt class="prettyprint lang-java">rose</tt>" та "<tt class="prettyprint lang-java">is</tt>".</p>

    <p>Як <tt class="prettyprint lang-java">List</tt>-и та <tt class="prettyprint lang-java">Set</tt>-и можна створювати <tt class="prettyprint lang-java">Map</tt>-и з потоку. Нижче наведено програму, яка створює <tt class="prettyprint lang-java">Map</tt> з потоку стрічок (<a href="#c06l13">Лістинг 6-13</a>).</p>

    <pre class="prettyprint lang-java" id="c06l12">
    // Лістинг 6-13. CollectorsToMap.java
    import java.util.Map;
    import java.util.stream.Collectors;
    import java.util.stream.Stream;

    public class CollectorsToMap {
        public static void main(String []args) {
            Map&lt;String, Integer&gt; nameLength = Stream.of("Arnold", "Alois", "Schwarzenegger")
                    .collect(Collectors.toMap(name -&gt; name, name -&gt; name.length()));
            nameLength.forEach((name, len) -&gt; System.out.printf("%s - %d \n", name, len));
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    Alois - 5
    Schwarzenegger - 14
    Arnold - 6
    </pre>

    <p>Метод <tt class="prettyprint lang-java">Collectors.toMap()</tt> приймає два аргументи - перший для ключів та другий для значень. Тут самі елементи в потоці використовуються як ключі, а довжина стрічки - як значення. Можна помітити, що порядок стрічок "<tt class="prettyprint lang-java">Arnold</tt>", "<tt class="prettyprint lang-java">Alois</tt>"та "<tt class="prettyprint lang-java">Schwarzenegger</tt>" в потоці не залишився незмінним? Це тому, що <tt class="prettyprint lang-java">Map</tt> не підтримує порядок вставки елементів.</p>

    <p>В цьому коді використовувався <tt class="prettyprint lang-java">name -&gt; name</tt>:</p>

    <pre class="prettyprint lang-java">
    Collectors.toMap(name -&gt; name, name -&gt; name.length())
    </pre>

    <p>Можна спростити, надавши <tt class="prettyprint lang-java">Function.identity()</tt>:</p>

    <pre class="prettyprint lang-java">
    Collectors.toMap(Function.identity(), name -&gt; name.length())
    </pre>

    <p>Згадайте, що метод <tt class="prettyprint lang-java">identity()</tt> в інтерфейсі <tt class="prettyprint lang-java">Function</tt> повертає отриманий аргумент (обговорювалося в Главі 5).</p>

    <p>Що з використанням специфічної колекції, наприклад <tt class="prettyprint lang-java">TreeSet</tt>, для агрегації елементів з методу <tt class="prettyprint lang-java">collect()</tt>? Для цього можна використовувати метод <tt class="prettyprint lang-java">Collections.toCollection()</tt> та передавати посилання на конструктор <tt class="prettyprint lang-java">TreeSet</tt> як аргумент (<a href="#c06l14">Лістинг 6-14</a>).</p>

    <pre class="prettyprint lang-java" id="c06l14">
    // Лістинг 6-14. CollectorsToTreeSet.java
    import java.util.Arrays;
    import java.util.Set;
    import java.util.TreeSet;
    import java.util.stream.Collectors;

    public class CollectorsToTreeSet {
        public static void main(String []args) {
            String []roseQuote = "a rose is a rose is a rose".split(" ");
            Set words = Arrays.stream(roseQuote).collect(Collectors.toCollection(TreeSet::new));
            words.forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    a
    is
    rose
    </pre>

    <p>Пам'ятайте, що <tt class="prettyprint lang-java">TreeSet</tt> впорядковує елементи, отже вивід наданий в відсортованому порядку.</p>

    <p>Також можна групувати елементи потоку, базуючись на певному критерії (<a href="#c06l15">Лістинг 6-15</a>).</p>

    <pre class="prettyprint lang-java" id="c06l15">
    // Лістинг 6-15. GroupStringsByLength.java
    import java.util.Arrays;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Collectors;
    import java.util.stream.Stream;

    public class GroupStringsByLength {
        public static void main(String []args) {
            String []string= "ви ніколи не перерахуєте своє майно, доки не прибиретеся у кімнаті".split(" ");
            Stream&lt;String&gt; distinctWords = Arrays.stream(string).distinct();
            Map&lt;Integer, List&lt;String&gt;&gt; wordGroups =
            distinctWords.collect(Collectors.groupingBy(String::length));
            wordGroups.forEach(
                (count, words) -&gt; {
                    System.out.printf("слова довжиною %d %n", count);
                    words.forEach(System.out::println);
                }
            );
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    слова довжиною 1 
    у
    слова довжиною 2 
    ви
    не
    слова довжиною 4 
    своє
    доки
    слова довжиною 6 
    ніколи
    майно,
    слова довжиною 7 
    кімнаті
    слова довжиною 11 
    перерахуєте
    прибиретеся
    </pre>

    <p>Метод <tt class="prettyprint lang-java">groupingBy()</tt> в класі <tt class="prettyprint lang-java">Collectors</tt> приймає аргумент <tt class="prettyprint lang-java">Function</tt>. Він використовує результат функції для повернення <tt class="prettyprint lang-java">Map</tt>. Об'єкт <tt class="prettyprint lang-java">Map</tt> складається із значень, які повертає <tt class="prettyprint lang-java">Function</tt>, та <tt class="prettyprint lang-java">List</tt> з елементів, які підходять.</p>

    <p>А якщо треба відокремити довгі слова від коротших? Для цього можна використати метод <tt class="prettyprint lang-java">partitioningBy()</tt> в класі <tt class="prettyprint lang-java">Collectors</tt> (<a href="#c06l16">Лістинг 6-16</a>). Метод секціонування приймає аргумент <tt class="prettyprint lang-java">Predicate</tt>.</p>

    <pre class="prettyprint lang-java" id="c06l16">
    /// Лістинг 6-16. PartitionStrings.java
    import java.util.Arrays;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Collectors;
    import java.util.stream.Stream;

    public class PartitionStrings {
        public static void main(String []args) {
            String []string= "ви ніколи не перерахуєте своє майно, доки не прибиретеся у кімнаті".split(" ");
            Stream&lt;String&gt; distinctWords = Arrays.stream(string).distinct();
            Map&lt;Boolean, List&lt;String&gt;&gt; wordBlocks =
                    distinctWords.collect(Collectors.partitioningBy(str -&gt; str.length() &gt; 4));
            System.out.println("Короткі слова (len &lt;= 4): " + wordBlocks.get(false));
            System.out.println("Довгі слова (len &gt; 4): " + wordBlocks.get(true));
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    Короткі слова (len <= 4): [ви, не, своє, доки, у]
    Довгі слова (len > 4): [ніколи, перерахуєте, майно,, прибиретеся, кімнаті]
    </pre>

    <p>В методі <tt class="prettyprint lang-java">partitioningBy()</tt> надається умова <tt class="prettyprint lang-java">str -&gt; str.length() > 4</tt>. Результат буде поділений на дві частини: з елементами, обчисленими в <tt class="prettyprint lang-java">true</tt> для цієї умови, та з елементами, обчисленими в <tt class="prettyprint lang-java">false</tt>. В цьому випадку для розділення слів на короткі (<tt class="prettyprint lang-java">length &lt;= 4</tt>) та довгі (<tt class="prettyprint lang-java">length &gt; 4</tt>) використовується метод <tt class="prettyprint lang-java">partitioningBy()</tt>.</p>

    <p><hr/>Чим відрізняються методи <tt class="prettyprint lang-java">groupingBy()</tt> та <tt class="prettyprint lang-java">partitioningBy()</tt>? Метод <tt class="prettyprint lang-java">groupingBy()</tt> приймає функцію класифікації (типу <tt class="prettyprint lang-java">Function</tt> ) та повертає отримані елементи та ознаки їх відповідності на основі функції класифікації (та організує результати в <tt class="prettyprint lang-java">Map&lt;K, List&lt;T&gt;&gt;</tt> ). Метод <tt class="prettyprint lang-java">partitioningBy()</tt> приймає аргумент <tt class="prettyprint lang-java">Predicate</tt> та класифікує елементи як <tt class="prettyprint lang-java">true</tt> та <tt class="prettyprint lang-java">false</tt> на основі наданого <tt class="prettyprint lang-java">Predicate</tt> (та організує результати в <tt class="prettyprint lang-java">Map&lt;Boolean, List&lt;T&gt;&gt;</tt> ).<hr/></p>

    <h2>Використання методу flatMap в потоці</h2>

    <p>Мета</p>

    <ul>
    	<li>Використання методів flatMap() Stream API</li>
    </ul>

    <p>В попередній програмі знаходилися унікальні слова в стрічці після виклику методу <tt class="prettyprint lang-java">split()</tt>:</p>

    <pre class="prettyprint lang-java">
    String []string= "ви ніколи не перерахуєте своє майно, доки не прибиретеся у кімнаті".split(" ");
    Stream<String> distinctWords = Arrays.stream(string).distinct();
    </pre>

    <p>Як знайти унікальні символи в реченні? Чи працюватиме цей код?</p>

    <pre class="prettyprint lang-java">
    String []string= "ви ніколи не перерахуєте своє майно, доки не прибиретеся у кімнаті".split(" ");
    Arrays.stream(string)
    		.map(word -> word.split(""))
    		.distinct()
    		.forEach(System.out::print);
    </pre>

    <p>Цей код друкує якусь нісенітницю:</p>

    <pre class="prettyprint lang-java">Ljava.lang.String;@5f184fc6[Ljava.lang.String;@3feba861[Ljava.lang.String;@5b480cf9[</pre>

    <p>Тому що <tt class="prettyprint lang-java">word.split()</tt> повертає <tt class="prettyprint lang-java">String[]</tt> та <tt class="prettyprint lang-java">distinct()</tt> видаляє дублікати. Оскільки елементи в потоці належать типу <tt class="prettyprint lang-java">String[]</tt>, то <tt class="prettyprint lang-java">forEach()</tt> виклики друку адресовані до реалізації по замовчанню <tt class="prettyprint lang-java">toString()</tt>, яка друкує щось, що не можна прочитати.</p>

    <p>Один спосіб вирішити цю проблему це використовувати <tt class="prettyprint lang-java">Arrays.stream()</tt> для <tt class="prettyprint lang-java">word.split("")</tt> та перетворити отримані потоки в самостійні елементи (тобто, "сплощити" потоки): <tt class="prettyprint lang-java">flatMap(word -&gt; Arrays.stream(word.split("")))</tt>. З такою зміною програма наведена нижче (<a href="#c06l17">Лістинг 6-17</a>), вона друкує унікальні символи в реченні.</p>

    <pre class="prettyprint lang-java" id="c06l17">
    // Лістинг 6-17. UniqueCharacters.java
    import java.util.Arrays;

    public class UniqueCharacters {
        public static void main(String []args) {
            String []string= "ви ніколи не перерахуєте своє майно, доки не прибиретеся у кімнаті".split(" ");
            Arrays.stream(string)
                    .flatMap(word -&gt; Arrays.stream(word.split("")))
                    .distinct()
                    .forEach(System.out::print);
        }
    }
    </pre>

    <p>This program correctly prints:</p>

    <pre class="prettyprint lang-java">виніколепрахуєтсмй,дбя</pre>

    <p>Обговоримо приклад, який чітко ілюструє різницю між методами <tt class="prettyprint lang-java">map()</tt> та <tt class="prettyprint lang-java">flatMap()</tt> (<a href="#c06l18">Listings 6-18</a> та <a href="#c06l19">6-19</a>).</p>

    <pre class="prettyprint lang-java" id="c06l18">
    // Лістинг 6-18. UsingMap.java
    import java.util.Arrays;
    import java.util.List;

    public class UsingMap {
        public static void main(String []args) {
            List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5);
            integers.stream()
                    .map(i -&gt; i * i)
                    .forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre class="prettyprint lang-java">
    1
    4
    9
    16
    25
    </pre>

    <p>В цій програмі маємо <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt> із значеннями від 1 до 5. Оскільки елементи <tt class="prettyprint lang-java">Integer</tt>, для їх перетворення в значення їх квадратів можна прямо викликати метод <tt class="prettyprint lang-java">map()</tt>(дивись <a href="#c06f03">Рисунок 6-3</a>).</p>

    <p><img id="c06f03" src="img/c06f03.png"/><br/>
    Рисунок 6-3. Метод map() перетворює елементи в потоці</p>

    <p>Складніше, коли маємо <tt class="prettyprint lang-java">List</tt> з <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt>, як в <a href="#c06l19">Лістинг 6-19</a>.</p>

    <pre class="prettyprint lang-java" id="Lisintg0619">
    // Listing 6-19. UsingFlatMap.java
    import java.util.Arrays;
    import java.util.List;

    public class UsingFlatMap {
        public static void main(String []args) {
            List&lt;List&lt;Integer&gt;&gt; intsOfInts = Arrays.asList(
                    Arrays.asList(1, 3, 5),
                    Arrays.asList(2, 4));
            intsOfInts.stream()
                    .flatMap(ints -&gt; ints.stream())
                    .sorted()
                    .map(i -&gt; i * i)
                    .forEach(System.out::println);
        }
    }
    </pre>

    <p>Ця програма дає той самий вихід, що й попередня (<a href="#c06l18">Лістинг 6-18</a>). Також вона друкує квадрати значень від <tt class="prettyprint lang-java">1</tt> до <tt class="prettyprint lang-java">5</tt>.</p>

    <p>В цій програмі є змінна <tt class="prettyprint lang-java">intsOfInts</tt>, яка є <tt class="prettyprint lang-java">List</tt> з <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt>. При виклику метода <tt class="prettyprint lang-java">stream()</tt> на <tt class="prettyprint lang-java">intsOfInts</tt> який буде тип елементів? Він буде <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt>. Як обробляти елементи всередині <tt class="prettyprint lang-java">List&lt;Integer&gt;</tt>? Для цього один спосіб викликати метод <tt class="prettyprint lang-java">stream()</tt> на кожному з елементів. Для конвертації цих потоків в елементи <tt class="prettyprint lang-java">Integer</tt>викликається метод <tt class="prettyprint lang-java">flatMap()</tt>. Після виклику <tt class="prettyprint lang-java">flatMap()</tt> маємо потік <tt class="prettyprint lang-java">Integers</tt>. Тепер можна виконувати такі операції як <tt class="prettyprint lang-java">sorted()</tt> та <tt class="prettyprint lang-java">map()</tt> для обробки чи перетворення цих елементів. <a href="#c06f04">Рисунок 6-4</a> показує різницю між методами <tt class="prettyprint lang-java">map()</tt> та <tt class="prettyprint lang-java">flatMap()</tt> в <tt class="prettyprint lang-java">Stream</tt>.</p>

    <p><img id="c06f04" src="img/c06f04.png"/><br/>
    Рисунок 6-4. Метод flatMap() сплощує потоки</p>

    <p><hr/>Метод <tt class="prettyprint lang-java">flatMap()</tt> оперує над елементами так, як і метод <tt class="prettyprint lang-java">map()</tt>. Однак, <tt class="prettyprint lang-java">flatMap()</tt> сплощує потоки, які повертаються після співставлення (мапінгу) кожного з його елементів, в один плаский потік.<hr/></p>

    <h2>Підсумки</h2>

    <p>Ничже стисло наведені ключові тези цієї лекції.</p>

    <b>Розробка коду для отримання даних з об'єкту за допомогою методів <tt class="prettyprint lang-java">peek()</tt> та <tt class="prettyprint lang-java">map()</tt>, включаючи примітивні версії методу <tt class="prettyprint lang-java">map()</tt></b>

    <ul>
    	<li>Метод <tt class="prettyprint lang-java">peek()</tt> корисний для відладки: він допомогає зрозуміти, як на конвейєрі перетворюються елементи.</li>
    	<li>Можна перетворити (або просто отримати) елементи з потоку за допомогою методу <tt class="prettyprint lang-java">map()</tt></li>
    </ul>

    <b>Пошук даних з використанням пошукових методів класів <tt class="prettyprint lang-java">Stream</tt>, зокрема <tt class="prettyprint lang-java">findFirst</tt>, <tt class="prettyprint lang-java">findAny</tt>, <tt class="prettyprint lang-java">anyMatch</tt>, <tt class="prettyprint lang-java">allMatch</tt> та <tt class="prettyprint lang-java">noneMatch</tt></b>

    <ul>
    	<li>Можна порівнювати елементи потоку з наданим предикатом за допомогою методів <tt class="prettyprint lang-java">allMatch()</tt>, <tt class="prettyprint lang-java">noneMatch()</tt > та <tt class="prettyprint lang-java">anyMatch()</tt>. На відміну від методу <tt class="prettyprint lang-java">anyMatch()</tt>, який повертає <tt class="prettyprint lang-java">false</tt> для порожнього потоку, методи <tt class="prettyprint lang-java">allMatch()</tt> та <tt class="prettyprint lang-java">noneMatch()</tt> повертають <tt class="prettyprint lang-java">true</tt>, коли потік порожній.</li>
    	<li>Можна шукати елементи в потоці за допомогою методів <tt class="prettyprint lang-java">findFirst()</tt> та <tt class="prettyprint lang-java">findAny()</tt>. Метод <tt class="prettyprint lang-java">findAny()</tt> швидший в порівнянні з методом <tt class="prettyprint lang-java">findFirst()</tt> в разі паралельних потоків.</li>
    	<li>Методи "match" та "find" використовують "швидку логіку": обчислення припиняється при знаходженні результата та решта потоку не обчислюється.</li>
    </ul>

    <b>Розробка коду, який використовує клас <tt class="prettyprint lang-java">Optional</tt></b>

    <ul>
    	<li>Коли в потоці немає елементів та аикликається така операція як <tt class="prettyprint lang-java">max</tt>, то замість повертання <tt class="prettyprint lang-java">null</tt> чи виклику винятку, в Java 8 повертаються значення <tt class="prettyprint lang-java">Optional</tt>.</li>
    	<li>Версії <tt class="prettyprint lang-java">Optional&lt;T&gt;</tt> для примітивних типів <tt class="prettyprint lang-java">int</tt>, <tt class="prettyprint lang-java">long</tt > та <tt class="prettyprint lang-java">double</tt> це <tt class="prettyprint lang-java">OptionalInteger</tt>, <tt class="prettyprint lang-java">OptionalLong</tt > та <tt class="prettyprint lang-java">OptionalDouble</tt> відповідно.</li>
    </ul>

    <b>Розробка коду, який використовує методи даних та підрахунку інтерфейсу Stream</b>

    <ul>
    	<li>Інтерфейс <tt class="prettyprint lang-java">Stream&lt;T&gt;</tt> має методи даних та підразунку <tt class="prettyprint lang-java">count()</tt>, <tt class="prettyprint lang-java">min()</tt> та <tt class="prettyprint lang-java">max()</tt>; потрідно передати об'єкт <tt class="prettyprint lang-java">Comparator</tt> як параметр при виклику цих методів <tt class="prettyprint lang-java">min()</tt> та <tt class="prettyprint lang-java">max()</tt>.</li>
    	<li>Версії для примітивних типів інтерфейсу <tt class="prettyprint lang-java">Stream</tt> мають наступні методи даних та підрахунку: <tt class="prettyprint lang-java">count()</tt>, <tt class="prettyprint lang-java">sum()</tt>, <tt class="prettyprint lang-java">average()</tt>, <tt class="prettyprint lang-java">min()</tt > та <tt class="prettyprint lang-java">max()</tt>.</li>
    	<li>Метод <tt class="prettyprint lang-java">summaryStatistics()</tt> в <tt class="prettyprint lang-java">IntStream</tt>, <tt class="prettyprint lang-java">LongStream</tt > та <tt class="prettyprint lang-java">DoubleStream</tt> має методи для підрахунку кількості, суми, середнього , мінімального та максимального значень серед елементів потоку.</li>
    </ul>

    <b>Сортування колекції з використанням Stream API</b>

    <ul>
    	<li>Один спосіб відсортувати колекцію це отримати з колекції потік та викликати на ньому метод <tt class="prettyprint lang-java">sorted()</tt>. Метод <tt class="prettyprint lang-java">sorted()</tt> сортує елементи потоку в природньому порядку (він потребує, щоб елементи потоку реалізювали інтерфейс <tt class="prettyprint lang-java">Comparable</tt>).</li>
    	<li>При необхідності відсортувати елементи потоку не в природньому порядку можна передати в метод <tt class="prettyprint lang-java">sorted()</tt> об'єкт <tt class="prettyprint lang-java">Comparator</tt>.</li>
    	<li>Інтерфейс <tt class="prettyprint lang-java">Comparator</tt> в Java 8 був покращений багатьма корисними статичними методами та методами за замовчанням, зокрема <tt class="prettyprint lang-java">thenComparing()</tt> та <tt class="prettyprint lang-java">reversed()</tt>.</li>
    </ul>

    <b>Збереження результатів в колекцію з використанням методу <tt class="prettyprint lang-java">collect</tt> та групування/секціонування даних за допомогою класу <tt class="prettyprint lang-java">Collectors</tt></b>

    <ul>
    	<li>Метод <tt class="prettyprint lang-java">collect()</tt> класу <tt class="prettyprint lang-java">Collectors</tt> має методи, які підтримують задачу збору елементів в колекцію.</li>
    	<li>Клас <tt class="prettyprint lang-java">Collectors</tt> надає методи на зразок <tt class="prettyprint lang-java">toList()</tt>, <tt class="prettyprint lang-java">toSet()</tt>, <tt class="prettyprint lang-java">toMap()</tt > та <tt class="prettyprint lang-java">toCollection()</tt> для створення колекції з потоку.</li>
    	<li>Можна групувати елементи потоку за дпомогою методу <tt class="prettyprint lang-java">Collectors.groupingBy()</tt> та надавати критерій для групування як аргумент (наданий як <tt class="prettyprint lang-java">Function</tt>).</li>
    	<li>Можна розділяти елемент потоку на основі умови (наданої як <tt class="prettyprint lang-java">Predicate</tt>) за допомогою методу <tt class="prettyprint lang-java">partition()</tt> класу <tt class="prettyprint lang-java">Collectors</tt>.</li>
    </ul>

    <b>Використання методу <tt class="prettyprint lang-java">flatMap()</tt> Stream API</b>

    <ul>
    	<li>Метод <tt class="prettyprint lang-java">flatMap()</tt> в <tt class="prettyprint lang-java">Stream</tt> сплощує потоки, відображаючи кожен елемент в один плаский потік.</li>
    </ul>


    <h1>Лекція 7</h1>
    <h1>Винятки та твердження</h1>
    <p>Цілі</p>
    <ul>
        <li>Використання операторів try-catch та throw</li>
        <li>Використання клауз catch, multi-catch та finally</li>
        <li>Використання ресурсів Autoclose з оператором <tt>try-with-resources</tt></li>
        <li>Створення власних винятків та ресурсів Auto-closeable</li>
        <li>Перевірка інваріантів з використанням тверджень</li>
    </ul>

    <p>З цм матеріалом ви детально ознайомитеся з тим, як в Java підтримується обробка винятків. В цьому уроці ви навчитеся роботі з блоком try, catch, multi-catch та finally. Також познайомитеся із такими нещодавно доданими властивостями мови як оператори try-with-resources та multi-catch. Потім ви довідаєтеся, як визначати власні класи винятків. Наприкінці ми поговоримо на пов'язану тему тверджень та навчимося використовувати їх в своїх програмах. Для ілюстрації концепцій обробки винятків багато прикладів використовують функції вводу-виводу, які ми розглянемо пізніше.</p>

    <h2>Throwable та його під-класи</h2>

    <p>В Java об'єкт <tt>thrown</tt> має бути object екземпляром класу <tt>Throwable</tt> чи одного з його під-класів (<tt>Throwable</tt> це початковий клас ієрархії винятків в Java). Такі конструкції обробк винятків, як оператор <tt>throw</tt>, клаузи <tt>throws</tt> та <tt>catch</tt>мають справи лише з <tt>Throwable</tt> та його під-класами. Існує три важливі під-класи <tt>Throwable</tt>, які треба детально вивчити: класи <tt>Error</tt>, <tt>Exception</tt> та <tt>RuntimeException</tt>. <a href="#c07f01">Figure 7-1</a> містить високорівневий огляд цих класів.</p>

    <p><img id="c07f01" src="Images/c07f01uk.png"/><br/>
    Рис. 7-1. Ієрархія винятків Java</p>

    <p>Короткий опис трьох важливих класів, які розширюють клас Throwable:</p>

    <ul>
        <li>Винятки типу <tt>Exception</tt> відомі як <em>винятки, що перевіряються</em>. Якщо код може викликати <tt>Exception</tt>, ви повинні обробити його, використавши блок <tt>catch</tt>, чи оголосити, що метод викликає це винятки, примусивши таким чином того, хто використовує цей метод, обробити те винятки.</li>

        <li><tt>RuntimeException</tt> це породжений від <tt>Exception</tt> клас. винятки, породжені від цього класу, відомі як <em>винятки, що не перевіряються</em>. Обробка таких винятків є не обов'язковою. Якщо фрагмент коду в методі може викликати винятки, що не перевіряється, то не обов'язково "ловити" його, чи оголошувати в клаузі <tt>throws</tt> цього методу.</li>

        <li>Коли JVM виявляє в програмі значні ненормальні умови, вона викликає винятки типу <tt>Error</tt>. винятки типу <tt>Error</tt> показують на ненормалні умови в програмі. Немає сенсу отстежувати таке винятки та намагатися продовжити виконання ніби нічого не трапилося. Це <em>дійсно</em> погана практика!</li>
    </ul>

    <p>Тепер поивимося, як викликати та відстежувати винятки.</p>

    <h3>Виклик винятків</h3>

    <p>Цілі</p>

    <ul><li>Використання операторів try-catch та throw</li></ul>

    <p><a href="#Listing0701">Лістинг 7-1</a> це дуже простий приклад, в якому ми бажаємо відтворити в консолі текст, наданий як аргумент командного рядку. Припустимо, що користувач повинен надркувати який-небудь текст як аргумент командного рядку, ябо ви маєте проінформувати користувача про "помилкові умови"</p>

    <pre id="Listing0701">
    // Лістинг 7-1. Echo.java
    // Проста програма без коду обробки винятків

    class Echo {
        public static void main(String []args) {
            if(args.length == 0) {
                // нема аргументів - показати користувачу помилку
                System.out.println("Помилка: Команді echo не надані аргументи... ");
                System.exit(-1);
            }
            else {
                for(String str : args) {
                    // аргументи командного рядку розділені та передаються як масив
                    // надрукувати їх, додавши пробіл між елементами масиву
                    System.out.print(str + " ");
                }
            }
        }
    }
    </pre>

    <p>В цьому прикладі ви з використанням оператора <tt>println()</tt> друкуєте в консолі повідомлення про помилку. Це тривіальна програма, а помилка виникає в методі <tt>main()</tt>, тож обробити помилку дуже легко. В цьому випадку ви можете перервати виконання програми після друку повідомлення про помилку. Однак, якщо ви заглиблені в стеку викликів функцій в складному застосунку ви потребуєте кращого способу вказати на трапляння "виключних умов" та проінформувати того, кто викликав ваш метод, про ці умови. Крім того, часто вам треба відновитися після помилки, а не перервати програму. Тож, вам потрібно вміти "опрацювати" винятки чи передати його вище по стеку для опрацвання тим, хто викликав ваш код (далі ми повернемося до теми повторного виклику винятків). А тепер змінемо програму в <a href="#Listing0701">Лістингу 7-1</a> для виклику винятки замість друку повідомлення про помилку (в окремій програмі <tt>Echo1.java</tt>) таким чином:</p>

    <pre>
    if(args.length == 0) {
        // нема аргументів - викликати виняток
        throw new IllegalArgumentException("Команді echo не надані аргументи");
    }
    </pre>

    <p>Цей блок всередені умови <tt>if</tt> для <tt>args.length == 0</tt> - єдине місце в програмі, де потрібні зміни. Зверніть увагу на синтаксис виклику винятка: ключове слово <tt>throw</tt> з об'єктом винятку за ним. Тут ми використовуємо <tt>IllegalArgumentException</tt>, який вже визначений в бібліотеці Java. Пізніше ми навчимося визначати власні винятки.</p>

    <p>Тепер якщо запустити програму без аргументів, вона викличе <tt>IllegalArgumentException</tt>:</p>

    <pre>
    Exception in thread "main" java.lang.IllegalArgumentException: Команді echo не надані аргументи
    </pre>

    <p>Оскільки для цього винятку немає обробника, цей неспійманий виняток перериває програму. Ви явно викликали виняток. Винятки можуть бути викликані також в вашому коді чи виклику функцій Java API. Подивимося на приклад.</p>

    <h3>Необроблені винятки</h3>

    <p>Розглянемо програму в <a href="#Listing0702">Лістингу 7-2</a>, яка намагається зчитати ціле значення, яке користувач друкує в консолі, так надрукувати це зчитане ціле. Для читання цілого з консолі ми використовуємо метод <tt>nextInt()</tt>, наданий в класі<tt>java.util.Scanner</tt>. Для інстанціювання класу <tt>Scanner</tt> використовуємо <tt>System.in</tt>, який є посиланням до <em>системного вхідного потоку</em>.</p>

    <pre id="Listing0702">
    // Лістинг 7-2. ScanInt1.java
    // Проста програма для прийому цілого від користувача
    import java.util.Scanner;

    class ScanInt1 {
        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле в консолі: ");
            Scanner consoleScanner = new Scanner(System.in);
            System.out.println("Ви надрукували ціле: " + consoleScanner.nextInt());
        }
    }
    </pre>

    <p>При запуску цієї програми та друку цілого, наприклад <tt>10</tt>, програма працює правильно та успішно друкує це ціле.</p>

    <pre>
    $ java ScanInt1 
    Надрукуйте ціле в консолі: 
    10
    Ви надрукували ціле: 10
    </pre>

    <p>А якщо користувач помилково надрукує рядок "десять"" замість цілого "10"? Програма припинить виконання після виклику винятку:</p>

    <pre>
    $ java ScanInt1 
    Надрукуйте ціле в консолі: 
    десять
    Exception in thread "main" java.util.InputMismatchException
        at java.base/java.util.Scanner.throwFor(Scanner.java:939)
        at java.base/java.util.Scanner.next(Scanner.java:1594)
        at java.base/java.util.Scanner.nextInt(Scanner.java:2258)
        at java.base/java.util.Scanner.nextInt(Scanner.java:2212)
        at ScanInt1.main(ScanInt1.java:9)
    </pre>

    <p>В документації до <tt>nextInt()</tt> вказано, що цей метод може викликати <tt>InputMismatchException</tt> &ndash; “if the next token does not match the Integer regular expression, or is out of range.” В цій простій програмі ми припускаємо, що коритувач завжди друкуватиме ціле, а коли це припущення хибить, викликається виняток. Якщо це в програмі є виняток, який залишається без обробки, програма після викликів по стеку аварійно припинить виконання, як показано.</p>

    <p>Слід стеку <em>(stack trace)</em> показує перелік методів (з номерами рядків), які викликалися перед тим, як управлянні досягло оператора, в якому був викликаний виняток. Як програмісти, ви знайдете корисним відслідковувати потік управління для відлагодження програм та усунення проблем, які призводять до винятків.</p>

    <p>Тож як ми дамо ладу в цій ситуації? Нам треба помістити цей код проміж блоками <tt>try</tt> та <tt>catch</tt> та опрацювати виняток.</p>

    <h4>Оператори Try та Catch</h4>

    <p>Цілі</p>

    <ul><li>Використання клауз catch, multi-catch та finally</li></ul>

    <p>Для обробки будь-якого винятку, який може бути викликаний у вашому коді, Java надає ключові слова <tt>try</tt> та <tt>catch</tt>. <a href="#Listing0703">Лістинг 7-3</a> це удосконалена версія програми з <a href="#Listing0702">Лістингу 7-2</a>.</p>

    <pre id="Listing0703">
    // Лістинг 7-3. ScanInt2.java
    // Проста програма для прийому цілого від користувача у звичайному випадку
    // інакше друкує повідомлення про помилку
    import java.util.Scanner;
    import java.util.InputMismatchException;

    class ScanInt2 {
        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле в консолі: ");
            Scanner consoleScanner = new Scanner(System.in);
            try {
                System.out.println("Ви надрукували ціле: " + consoleScanner.nextInt());
            } catch(InputMismatchException ime) {
                // nextInt() викликає InputMismatchException у випадку
                // друку в консолі чогочь окрім цілого; обробити це
                System.out.println("Помилка: Ви надрукували деякий текст, який не є цілим значенням...");
            }
        }
    }
    </pre>

    <p>Якщо на вхід друкуєтсья щось інше, крім валідного цілого, ця програма друкує користувачеві читабельне повідомлення про помилку.</p>

    <pre>
    $ java ScanInt2 
    Надрукуйте ціле в консолі: 
    десять
    Помилка: Ви надрукували деякий текст, який не є цілим значенням...
    </pre>

    <p>Проаналізуємо цей код. Блок за ключовим словом <tt>try</tt> обмежує фрагмент коду, в якому ви очікуєте виклик будь-якого винятку. Якщо в блоці <tt>try</tt> викликаєтсья будь-який виняток, Java часу виконання шукатиме <em>відповідний обробник</em> (поговоримо про це трохи пізніше). В нашому випадку наявний обробник винятку для <tt>InputMismatchException</tt>, який належить точно тому типу, як і викликаний виняток. Цей <em>точно відповідний</em> обробник <tt>catch</tt> доступний одразу за блоком <tt>try</tt> в формі блоку, що починається ключовим словом <tt>catch</tt>, тож виконується цей блок <tt>catch</tt>. В блоці <tt>catch</tt> ми відловлюємо цей виняток, тож саме тут міститься обробка винятку. Ми надаємо читабельний рядок з помилкою замість виклику по стеку (як робили раніше в програмі з <a href="#Listing0702">Лістингу 7-2</a>) &ndash; доволі елегантний вихід з програми.</p>

    <h5>Декілька блоків Catch</h5>

    <p>В <a href="#Listing0702">Лістингу 7-2</a> для читання цілого з консолі ми використовували об'єкт <tt>Scanner</tt>. Зауважте, що об'єкт <tt>Scanner</tt> можна також використовувати для читання із <tt>String</tt> (див. <a href="#Listing0704">Лістинг 7-4</a>).</p>

    <pre id="Listing0704">
    // Лістинг 7-4. ScanInt3.java
    // Програма, яка шукає ціле в наданому рядку
    import java.util.Scanner;
    import java.util.InputMismatchException;

    class ScanInt3 {
        public static void main(String [] args) {
            String integerStr = "100";
            System.out.println("Рядок для пошуку в ньому цілого: " + integerStr);
            Scanner consoleScanner = new Scanner(integerStr);
            try {
                System.out.println("Ціле значення для пошуку в наданому рядку: " +
                        consoleScanner.nextInt());
            } catch(InputMismatchException ime) {
                // nextInt() викликає InputMismatchException у випадку
                // надання чогось стрічки без цілого
                System.out.println("Помилка: Не можна знайти ціле в наданому рядку");
            }
        }
    }
    </pre>

    <p>Ця програма друкує наступне:</p>

    <pre>
    Рядок для пошуку в ньому цілого: 100
    Ціле значення для пошуку в наданому рядку: 100
    </pre>

    <p>Що трапиться, якщо змінити програму з <a href="#Listing0704">Лістингу 7-4</a> так, щоби рядок містив не-ціле значення, наприклад</p>

    <pre>String integerStr = "сто";</pre>

    <p>Блок <tt>try</tt> викличе <tt>InputMismatchException</tt>, який буде оброблений в блоці <tt>catch</tt>, та ми отримаємо на виході:</p>

    <pre>
    Рядок для пошуку в ньому цілого: сто
    Помилка: Не можна знайти ціле в наданому рядку
    </pre>

    <p>А тепер, якщо змінити програму з <a href="#Listing0704">Лістингу 7-4</a> так, щоби рядок містив порожній рядок:</p>

    <pre>
    String integerStr = "";
    </pre>

    <p>Тоді <tt>nextInt()</tt> викличе <tt>NoSuchElementException</tt>, який не оброблюється в цій програмі, тож програма завершиться аварійно.</p>

    <pre>
    Рядок для пошуку в ньому цілого:
    Exception in thread "main" java.util.NoSuchElementException
    at java.util.Scanner.throwFor(Scanner.java:907)
    at java.util.Scanner.next(Scanner.java:1530)
    at java.util.Scanner.nextInt(Scanner.java:2160)
    at java.util.Scanner.nextInt(Scanner.java:2119)
    at ScanInt3.main(ScanInt.java:11)
    </pre>

    <p>В документації (JavaDoc) для методу <tt>Scanner.nextInt()</tt> вказано, що він може також викликати <tt>IllegalStateException</tt> (цей виняток викликається якщо метод <tt>nextInt()</tt> викликається на вже закритому об'єкті <tt>Scanner</tt>). Представимо обробники для <tt>InputMismatchException</tt>, <tt>NoSuchElementException</tt> та <tt>IllegalStateException</tt> (див.e <a href="#Listing0705">Лістинг 7-5</a>).</p>

    <pre id="Listing0705">
    // Лістинг 7-5. ScanInt4.java
    // Програма, яка шукає ціле в наданому рядку
    import java.util.Scanner;
    import java.util.InputMismatchException;
    import java.util.NoSuchElementException;

    class ScanInt4 {
        public static void main(String [] args) {
            String integerStr = "";
            System.out.println("Рядок для пошуку в ньому цілого: " + integerStr);
            Scanner consoleScanner = new Scanner(integerStr);
            try {
                System.out.println("Ціле значення для пошуку в наданому рядку: " +
                        consoleScanner.nextInt());
            } catch(InputMismatchException ime) {
                System.out.println("Помилка: Не можна знайти ціле в наданому рядку");
            } catch(NoSuchElementException nsee) {
                System.out.println("Помилка: Не можна знайти ціле в наданому рядку");
            } catch(IllegalStateException ise) {
                System.out.println("Помилка: nextInt() викликаний на закритому об'єкті Scanner");
            }
        }
    }
    </pre>

    <p>Вивід програми:</p>

    <pre>
    Рядок для пошуку в ньому цілого: 
    Помилка: Не можна знайти ціле в наданому рядку
    </pre>

    <p>Як видно із виводу програми, оскільки рядок порожній, викликається <tt>NoSuchElementException</tt>. Він ловиться в обробнику для таких винятків та для коректного виходу з програми виконується код, наведений всередині блоку <tt>catch</tt>.</p>

    <p>Зверніть увагу на те, як ми надали декілька обробників винятків, розташувавши їх у стеку знизу догори: ми надали специфічні обробники (тобто, породжених типів) перед більш загальними (тобто, базового типу). Якщо надати тип породженого винятку після типу базового винятку, ми отримаємо помилку компіляції. Можливо, ви ще не знаєте, але <tt>NoSuchElementException</tt> є базовим типом для <tt>InputMismatchException</tt>! Подивимося, що трапиться при спробі змінити порядок обробників для <tt>InputMismatchException</tt> та <tt>NoSuchElementException</tt>.</p>

    <pre>
    try {
        System.out.println("Ціле значення для пошуку в наданому рядку: "
                + consoleScanner.nextInt());
    } catch(NoSuchElementException nsee) {
        System.out.println("Помилка: Не можна знайти ціле в наданому рядку");
    } catch(InputMismatchException ime) {
        System.out.println("Помилка: Не можна знайти ціле в наданому рядку");
    }
    </pre>

    <p>Цей фрагмент коду призведе до помилки компіліції:</p>

    <pre>
    ScanInt4.java:14: error: exception InputMismatchException has already been caught
        } catch(InputMismatchException ime) {
                ^
    1 error
    </pre>

    <p><hr/>При наданні багатьох обробників винятків треба оброблювати специфічні винятки перед обробкою загальних винятків. Якщо надати породжений клас обробника винятку після базового класу обробника винятку, код не скомпілюється.
    <hr/></p>

    <h5>Блоки Multi-Catch</h5>

    <p>Java надає засіб на ім'я <em>блоки multi-catch</em>, за допомогою якого можна комбінувати багато обробників винятків. Використаємо його для об'єднання клауз <tt>catch</tt> винятків <tt>NoSuchElementException</tt> та <tt>IllegalStateException</tt> (див. <a href="#Listing0706">Лістинг 7-6</a>):</p>

    <pre id="Listing0706">
    // Лістинг 7-6. ScanInt5.java
    // Програма, що демонструє блоки multi-catch
    import java.util.Scanner;
    import java.util.NoSuchElementException;

    class ScanInt5 {
        public static void main(String [] args) {
            String integerStr = "";
            System.out.println("Рядок для пошуку в ньому цілого: " + integerStr);
            Scanner consoleScanner = new Scanner(integerStr);
            try {
                System.out.println("Ціле значення для пошуку в наданому рядку: " +
                        consoleScanner.nextInt());
            } catch(NoSuchElementException | IllegalStateException multie) {
                System.out.println("Помилка: Трапилася помилка при спробі знайти ціле");
            }
        }
    }
    </pre>

    <p>Подивіться, як можна об'єднувати обробники винятків із застосуванням оператора <tt>| (OR)</tt> (той самий оператор, який використовується для по-бітової операції <tt>OR</tt> над цілими значеннями) для комбінування клауз <tt>catch</tt> винятків <tt>NoSuchElementException</tt> та <tt>IllegalStateException</tt>.</p>

    <p>На відміну від об'єднання клауз <tt>catch</tt> винятків <tt>NoSuchElementException</tt> та <tt>IllegalStateException</tt>, не можна комбінувати клаузи <tt>catch</tt> винятків <tt>NoSuchElementException</tt> та <tt>InputMismatchException</tt>. Як вже говорилося, <tt>NoSuchElementException</tt> є базовим класом для <tt>InputMismatchException</tt>, а обидва їх не можна "ловити" в одному блоці <tt>multi-catch</tt>. При спробі скомпілювати таку клаузу multi-catch ми отримаємо наступну помилку:</p>

    <pre>
    ScanInt5.java:11: error: Alternatives in a multi-catch statement cannot be related by subclassing
    } catch(InputMismatchException | NoSuchElementException exception) {
                                                                     ^
    </pre>

    <p>Чи існує альтернатива? Коли потрібний обробник для винятків, один з яких є базовим для іншого, достатньо надати обробник лише для базового класу винятку (оскільки цей базовий клас обробника опрацює виняток породженого класу винятку).</p>

    <p><hr/>В блоці multi-catch не можна комбінувати обробники для двох винятків, які знаходяться у відношенні "базовий та породжений класи". Можна комбінувати лише обробники для винятків, між якими немає відношень "батько-дитина".<hr/></p>

    <p>Що вважати за найкраще: комбінувати блоки обробників чи впорядковувати їх у стек? Це &ndash; питання проектування, при якому слід розглядати наступні аспекти:</p>
    <ol>
        <li>Винятки викликаються з однієї (схожої) причини чи з різних?</li>
        <li>Код обробки однаковий (схожий) чи ні?</li>
    </ol>

    <p>Якщо "схожий" &ndash; це відповідь на обидва питання, краще комбінувати блоки обробки; інакше &ndash; розділити їх.</p>

    <p>Розгланемо конкретну ситуацію в <a href="#Listing0706">Лістингу 7-6</a>. Краще комбінувати чи розділити обробники для винятків <tt>InputMismatchException</tt> та <tt>IllegalStateException</tt>? Видно, що обробка винятку однакова для обох блоків обробки. Але причини для цих двох винятків значно відрізняються. <tt>InputMismatchException</tt> викликається при отриманні невалідного вводу (наприклад, "сто" з розглянутих прикладів). А <tt>IllegalStateException</tt> викликається внаслідок помилки програмування при виклику методу <tt>nextInt()</tt> після виклику методу <tt>close()</tt> класу <tt>Scanner</tt>. Отже, в цьому випадку кращим проектним рішенням буде розділити обробники для цих двох винятків.</p>

    <h5>Загальні обробники</h5>

    <p>При використанні API для операцій вводу/виводу може бути викликано багато винятків. Ми нещодавно побачили, що для виклику лише одного методу <tt>nextInt()</tt> класу <tt>Scanner</tt> нам потрібно обробити три винятки: <tt>InputMismatchException</tt>, <tt>NoSuchElementException</tt> та <tt>IllegalStateException</tt>. Якщо оброблювати такі специфічні винятки, які можуть виникнути при роботі вашої програми, а можуть й ні, більшість вашого коду складатиметься з блоків <tt>try-catch</tt>! Чи існує кращий спосіб вказати "Оброби всі інші винятки"? Так, можна надати <em>обробник загального винятку</em>.</p>

    <p>Нижче наведено фрагмент коду, який показує лише блоки <tt>try-catch</tt> для класу <tt>ScanInt3</tt> з <a href="#Listing0704">Лістингу 7-4</a>, покращений обробником загального винятку:</p>

    <pre>
    try {
        System.out.println("Ви надрукували ціле значення: " + consoleScanner.nextInt());
    } catch(InputMismatchException ime) {
        // якщо надано не ціле, отримаємо цей виняток, тож обробимо його
        System.out.println("Помилка: Надрукований текст не є цілим значенням...");
    } catch(Exception e) {
        // спіймати IllegalStateException тут мало ймовірно...
        System.out.println("Помилка: Трапився виняток та не можна зчитати ціле з консолі... ");
    }
    </pre>

    <p>Цей код надає обробник для базового винятку типу <tt>Exception</tt>. Тож, якщо блок <tt>try</tt> викликає будь-який інший на вдміну від <tt>InputMismatchException</tt> виняток, та якщо цей виняток класу, породженого від класу <tt>Exception</tt>, цей загальний обробникопрацює його. Це рекомендована практика &ndash; обробляти специфічні винятки, а потім надавати обробник загального винятку для забезпечення обробки всіх інших винятків.</p>

    <h5>Вивільнення ресурсів</h5>

    <p>Як можна помітити, програми в лістингах <a href="#Listing0702">7-2</a>, <a href="#Listing0703">7-3</a> та <a href="#Listing0704">7-4</a> мають <em>витік ресурсів</em> (оскільки об'єкт <tt>Scanner</tt> відкривається, але не зачиняється). Слово "ресурс" відноситься до будь-якого класу, який отримує від базової операційної системи будь-яке системне джерело, наприклад, обробник для роботи з мережею, файлом, базою даних і таке інше. Але як розпізнати, які класи потребують закриття? Відповідь: якщо клас реалізує інтерфейс <tt>java.io.Closeable</tt>, то треба викликати його метод <tt>close()</tt>; інакше траплятиметься витік ресурсів.</p>

    <p><hr/>Збірник сміття &ndash; Garbage Collector (GC) відповідає лише за вивільнення ресурсів пам'яті. При використанні класів, які отримують системні ресурси, їх вивільнення шляхом виклику методу <tt>close()</tt> відповідного об'єкту залишається обов'язком програміста.<hr/></p>

    <p><tt>ScanInt6</tt> (<a href="#Listing0707">7-7</a>) викликає метод <tt>close()</tt> об'єкту <tt>Scanner</tt> в своєму методі <tt>main()</tt>; можна скоротити код за рахунок використання загального обробника для опрацювання всіх винятків, які можуть трапитися в блоці <tt>try</tt>.</p>

    <pre id="Listing0707">
    // Лістинг 7-7. ScanInt6.java
    import java.util.Scanner;

    class ScanInt6 {
        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле: ");
            Scanner consoleScanner = new Scanner(System.in);
            try {
                System.out.println("Ви надрукували ціле значення: " + consoleScanner.nextInt());
                System.out.println("Текст зчитаний... закриття Scanner");
                consoleScanner.close();
            } catch(Exception e) {
                // всі інші винятки викликаються тут ...
                System.out.println("Помилка: Трапився виняток та не можна зчитати ціле з консолі... ");
                System.out.println("Вихід з програми - перезапустіть програму!");
            }
        }
    }
    </pre>

    <p>Подивимось на роботу програми.</p>

    <pre>
    $ java ScanInt6
    Надрукуйте ціле: 
    10
    Ви надрукували ціле значення: 10
    Текст зчитаний... закриття Scanner
    </pre>

    <p>Оскільки програма надрукувала "<tt>Текст зчитаний... закриття Scanner</tt>" та закінчила виконання нормально, можна припустити, що оператор <tt>consoleScanner.close();</tt> теж був виконаний. Що трапиться при виникненні винятку?</p>

    <pre>
    $ java ScanInt6
    Надрукуйте ціле: 
    десять
    Помилка: Трапився виняток та не можна зчитати ціле з консолі... 
    Вихід з програми - перезапустіть програму!
    </pre>

    <p>Як видно з виводу програми, вона не надрукувала "<tt>Текст зчитаний... закриття Scanner</tt>", тож оператор <tt>consoleScanner.close()</tt>; не був виконаний. Як це виправити? Один спосіб &ndash; викликати <tt>consoleScanner.close()</tt> також в блоці <tt>catch</tt>:</p>

    <pre id="snippet0701">
            try {
                System.out.println("Ви надрукували ціле значення: " + consoleScanner.nextInt());
                System.out.println("Текст зчитаний... закриття Scanner");
                consoleScanner.close();
            } catch(Exception e) {
                // call all other exceptions here ...
                // всі інші винятки викликаються тут ...
                System.out.println("Помилка: Трапився виняток та не можна зчитати ціле з консолі... ");
                System.out.println("Вихід з програми - перезапустіть програму!");
            }
    </pre>

    <p>Це рішення буде працювати, але його не можна назвати елегантним. Можна ж мати багато блоків <tt>catch</tt>, тоді треба викликати <tt>consoleScanner.close();</tt> в кожному з них! Чи існує кращий спосіб вивільнення ресурсів? Так, можна вивільнити ресурсі в блоці <tt>finally</tt> (див. Листінг <a href="#Listing0708">7-8</a>).</p>

    <pre id="Listing0708">
    // Лістинг 7-8. ScanInt7.java
    import java.util.Scanner;

    class ScanInt7 {
        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле: ");
            Scanner consoleScanner = new Scanner(System.in);
            try {
                System.out.println("Ви надрукували ціле значення: " + consoleScanner.nextInt());
            } catch(Exception e) {
                // call all other exceptions here ...
                System.out.println("Помилка: Трапився виняток та не можна зчитати ціле з консолі... ");
                System.out.println("Вихід з програми - перезапустіть програму!");
            } finally {
                System.out.println("Читання цілого завершено... закриття Scanner");
                consoleScanner.close();
            }
        }
    }
    </pre>

    <p>Блок <tt>finally</tt> розташовано після блоку <tt>catch</tt>. Цей блок <tt>finally</tt> виконуватиметься незалежно від того, чи трапиться виняток. Отже, блок <tt>finally</tt> &ndash; це гарне місце для виклику методу <tt>close()</tt> об'єкту <tt>Scanner</tt> для забезпечення незалежного від умов вивільнення русурсу.</p>

    <p><hr/>Виклик <tt>System.exit()</tt> звередини методу призводить до аварійного завершення програми. Якщо метод, який робить виклик, має блок <tt>finally</tt>, він не буде викликаний та ресурс може втекти. З-за цієї причини виклик <tt>System.exit()</tt> для завершення програми &ndash; це погана практика програмування.<hr/></p>

    <p>Подивимось, чи закривається <tt>scanner</tt> у випадку нормального завершення програми (тобто, без виклику винятку) та у випадку завершення програми внаслідок виклику винятку.</p>

    <pre>
    $ java ScanInt7
    Надрукуйте ціле: 
    10
    Ви надрукували ціле значення: 10
    Читання цілого завершено... закриття Scanner

    $ java ScanInt7
    Надрукуйте ціле: 
    десять
    Помилка: Трапився виняток та не можна зчитати ціле з консолі... 
    Вихід з програми - перезапустіть програму!
    Читання цілого завершено... закриття Scanner
    </pre>

    <p>Так, речення "Читання цілого завершено... закриття Scanner" друкується незалежно від того, чи був викликаний виняток. Зауважте, що блок <tt>finally</tt> можна розміщати прямо після блоку <tt>try</tt> також без блоку <tt>catch</tt>; хоча ця властивість використовується рідко, вона може бути корисною.</p>

    <p>Примітка: блок <tt>finally</tt> виконується завжди поза залежності від того, чи був викликаний виняток в блоці <tt>try</tt>, чи ні. Розглянемо наступний метод. Він поверне <tt>true</tt> чи <tt>false</tt>?</p>

    <pre>
    boolean returnTest() {
        try {
            return true;
        }
        finally {
            return false;
        }
    }
    </pre>

    <p>Цей метод завжди повертатиме <tt>false</tt>, оскільки <tt>finally</tt> виконується завжди, хоча це і контрінтуітивно. При використанні опції "<tt>-Xlint</tt>" ми отримаємо наступне попередження: "<tt>finally clause cannot complete normally.</tt>". Зауважте, що за блоком <tt>try</tt> можуть бути розташовані блок <tt>catch</tt> чи блок <tt>finally</tt> чи обидва.</p>

    <h3>Клауза Throws</h3>

    <p>AМетод може викликати винятки, що перевіряються; клауза <tt>throw</tt> вказує ці винятки в сигнатурі метода.В клаузі <tt>throws</tt> мають бути перелічені <em>винятки, що перевіряютсья</em>, які може викликати метод. Навіщо потрібна клауза <tt>throws</tt>? Подивившися на клаузу <tt>throws</tt> будь-якого методу, можна зрозуміти, які винятки можуть бути ним викликані. Розуміння винятків, що перевіряються, потрібно для розуміння клаузи <tt>throws</tt>. Оскільки в поередній главі про типи винятків ми розглянули винятки, що перевіряються, зараз поговоримо про клаузу <tt>throws</tt>.</p>

    <p>Спробуємо зчитати ціле, яке зберігається в файлі з іменем <tt>integer.txt</tt> в поточному каталозі. Існує перевантажений конструтор класу <tt>Scanner</tt>, який приймає на вхід об'єкт <tt>File</tt>, тож спробуємо використати його. Лістинг <a href="#Listing0709">7-9</a> містить програму. Чи працюватиме вона?</p>

    <pre id="Listing0709">
    // Лістинг 7-9. ThrowsClause1.java
    import java.io.File;
    import java.util.Scanner;

    class ThrowsClause1 {
        public static void main(String []args) {
            System.out.println("Читання цілого з файлу 'integer.txt': ");
            Scanner consoleScanner = new Scanner(new File("integer.txt"));
            System.out.println("Знайдено ціле значення: " + consoleScanner.nextInt());
        }
    }
    </pre>

    <p>Цей код призведе до помилки компілятора "<tt>unreported exception FileNotFoundException; must be caught or declared to be thrown</tt>". Якщо подивитися на оголошення цього методу <tt>Scanner</tt>, можна побачити клаузу <tt>throws</tt>:</p>

    <pre>public Scanner(File source) throws FileNotFoundException {</pre>

    <p>Отже, будь-який метод, який викликає цей конструктор, має чи оброблювати цей виняток, чи додати до свого оголошення клаузу<tt>throws</tt>, для декларації того, що метод може викликати цей виняток. Додамо клаузу <tt>throws</tt> до методу <tt>main()</tt>; див. Лістинг <a href="#Listing0710">7-10</a>.</p>

    <pre id="Listing0710">
    // Лістинг 7-10. ThrowsClause2.java
    import java.io.File;
    import java.io.FileNotFoundException;
    import java.util.Scanner;

    class ThrowsClause2 {
        public static void main(String []args) throws FileNotFoundException {
            System.out.println("Читання цілого з файлу 'integer.txt': ");
            Scanner consoleScanner = new Scanner(new File("integer.txt"));
            System.out.println("Знайдено ціле значення: " + consoleScanner.nextInt());
        }
    }
    </pre>

    <p>Якщо при запуску програми не існуватиме файла з іменем <tt>integer.txt</tt>, вона аварійно завершиться з винятком:</p>

    <pre>
    Читання цілого з файлу 'integer.txt':
    Exception in thread "main" java.io.FileNotFoundException: integer.txt (The system cannot find the file specified)
        at java.io.FileInputStream.open(Native Method)
        at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)
        at java.util.Scanner.&lt;init&gt;(Scanner.java:656)
        at ThrowsClause2.main(ThrowsClause2.java:7)
    </pre>

    <p>Перенесемо код з методу <tt>main()</tt> в новий метод <tt>readIntFromFile()</tt>. Його треба визначити як метод екземляра, тому також буде стоврений об'єкт класу <tt>ThrowsClause3</tt> для виклику цього методу з методу <tt>main()</tt>. Оскільки код всередині <tt>readIntFromFile()</tt> може викликати <tt>FileNotFoundException</tt>, цей метод має ввести обробник для опрацювання цього винятку або оголосити цей виняток в своїй клаузі <tt>throws</tt> (див. Лістинг <a href="#Listing0711">7-11</a>).</p>

    <pre id="Listing0711">
    // Лістинг 7-11. ThrowsClause3.java
    import java.io.File;
    import java.io.FileNotFoundException;
    import java.util.Scanner;

    class ThrowsClause3 {
        // оскільки цей метод не оброблює FileNotFoundException,
        // метод має декларувати цей виняток в клаузі throws
        public int readIntFromFile() throws FileNotFoundException {
            Scanner consoleScanner = new Scanner(new File("integer.txt"));
            return consoleScanner.nextInt();
        }
        // оскільки readIntFromFile() викликає FileNotFoundException, а main() не оброблює
        // його, метод main() декларує цей виняток в клаузі throws
        public static void main(String []args) throws FileNotFoundException {
            System.out.println("Читання цілого з файлу 'integer.txt': ");
            System.out.println("Знайдено ціле значення: "
                    + new ThrowsClause3().readIntFromFile());
        }
    }
    </pre>

    <p>Поведінка програми залишається однаковою в обох лістингах <a href="#Listing0710">7-10</a> та <a href="#Listing0711">7-11</a>. Однак, Лістинг <a href="#Listing0711">7-11</a> показує, що метод <tt>main()</tt> також має досі оголошувати виклик <tt>FileNotFoundException</tt> в своїй клаузі <tt>throws</tt> (інакше програма не буде скомпільована).</p>

    <h4>Перевизначення методів та клауза Throws</h4>

    <p>Коли в методі, який припускає перевизначення, є клауза <tt>throws</tt>, при його перевизначенні треба брати до уваги багато чого. Розглянемо програму в Лістингу <a gref="#Listing0712">7-12</a>, яка реалізує інтерфейс <tt>IntReader</tt>. Цей інтерфейс оголошує один метод <tt>readIntFromFile()</tt> з клаузою <tt>throws FileNotFoundException</tt>.</p>

    <pre id="Listing0712">
    // Лістинг 7-12. ThrowsClause4.java
    import java.io.File;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.util.Scanner;

    // Інтерфейс для реалізації класами, які зчитують цілі значення з файлу
    interface IntReader {
        int readIntFromFile() throws IOException;
    }

    class ThrowsClause4 implements IntReader {
        // реалізує readIntFromFile з тією самою клаузою throws
        // чи з більш специфічною клаузою throws
        public int readIntFromFile() throws FileNotFoundException {
            Scanner consoleScanner = new Scanner(new File("integer.txt"));
            return consoleScanner.nextInt();
        }
        // метод main опущений, оскільки головне тут - зрозуміти
        // проблеми, пов'язані з перевизначенням з наявною клаузою throws
    }
    </pre>

    <p>Зверніть увагу на декілька важливих фактів в цьому коді:</p>

    <ul>
        <li>Можна оголошувати клаузу <tt>throws</tt> для методів, оголошених в інтерфейсах; також можна надавати клаузу <tt>throws</tt> для абстрактних методів, оголошених в абстрактних класах.</li>

        <li>Метод, оголошений в інтерфейсі <tt>IntReader</tt> оголошує виклик <tt>IOException</tt>, який є більш загальним по відношенню до <tt>FileNotFoundException</tt> (Рис.&nbsp;<a href="#c07f02">7-2</a>). При реалізації метода припустимо надати клаузу <tt>throws</tt> з переліком як таких самих типів винятків, як і в базовому методі, так і більш специфічних типів, ніж в базовому методі. В нашому випадку, метод <tt>readIntFromFile()</tt> перелічує в своїй клаузі <tt>throws</tt> більш специфічний виняток (<tt>FileNotFoundException</tt>) в порівнянні з більш загальним винятком <tt>IOException</tt>, вказаним в клаузі <tt>throws</tt> базового методу, оголошеному в інтерфейсі<tt>IntReader</tt>.</li>
    </ul>

    <p><img id="c07f02" src="Images/c07f02.png"/><br/>
    Figure 7-2. Ієрархія класів FileNotFoundException</p>

    <p>А якщо змінити клаузу <tt>throws</tt>? Існує багато способів змінити клаузу <tt>throws</tt> в перевизначеному методі, наприклад:</p>

    <ul>
        <li>Перелічити для виклику більш загальні винятки, що перевіряються.</li>
        <li>Перелічити більше винятків, що перевіряються, на додаток до наданих в базовому методі.</li>
    </ul>

    <p>При спробі будь-якого з цих варіантів отримаємо помилку компілятора. Наприклад, при наданні більш загального у порівнянні до вказаного в базовому класі винятку виникне помилка компілятора.</p>

    <p>Можна обрати варіант не вказувати жодного винятку у клаузі <tt>throws</tt> перевизначеного методу, забезпечивши або відсутність виклику будь-якого винятку, що перевіряється, або обробку такого винятку в блоці <tt>try-catch</tt>.</p>

    <p>Підсумковуючи, клауза <tt>throws</tt> методу базового класу &ndash; це контракт, який пропонується для користувача цього методу: він каже, що той, хто викликає цей метод, має обробляти перелічені винятки або оголосити їх в своїй клаузі <tt>throws</tt>. При перевизначенні базового методу породжений метод також має підтримувати цей контракт. Користувач базового методу готується обробляти лише винятки, перелічені в базовому методі, тож перевизначений метод не може викликати більш загальні або інші винятки, що перевіряються.</p>

    <p>Однак, зауважте, вимога, щоби клауза <tt>throws</tt> методу породженого класу підтримувала контракт для клаузи <tt>throws</tt> базового методу, обмежена винятками, що перевіряються. Винятки, що не перевіряються, досі можуть бути додані до контракту чи видалені з нього. Наприклад, розглянемо наступний фрагмент:</p>

    <pre>
    public int readIntFromFile() throws IOException, NoSuchElementException {
        Scanner consoleScanner = new Scanner(new File("integer.txt"));
        return consoleScanner.nextInt();
    }
    </pre>

    <p>Це &ndash; припустима клауза <tt>throws</tt>, оскільки <tt>NoSuchElementException</tt> може бути викликаний з методу <tt>readIntFromFile()</tt>. Цей виняток &ndash; виняток, який не перевіряється, та викликається, коли метод <tt>nextInt()</tt> не може зчитати ціле з файлу. Це &ndash; загальна ситуація, наприклад, якщо файл <tt>integer.txt</tt> порожній; спроба зчитати ціле з цього файлу призведе до цього винятку.</p>

    <div id="c07d01">
        <hr/>
        МІТКА @THROWS
        <hr/>
        <p>Існує гарна практика використовувати мітку JavaDoc <tt>@throws</tt> (або синонім <tt>@exception</tt>) для документування специфічних ситуацій чи випадків, в яких виняток (що не перевіряється або що перевіряється) може бути викликаний з методу. Ось формат надання мітки <tt>@throws</tt> на прикладі:</p>

    <pre>
    @throws exception-name description-text
    @throws IllegalStateException if this scanner is closed
    </pre>

    <p>Цю мітку можна використовувати лише для методів та конструкторів.</p>

    <p>Ничже наведено приклад коментаря JavaDoc для методу <tt>nextInt()</tt> в класі <tt>Scanner</tt>:</p>

    <pre>
    /**
    * Scans the next token of the input as an &lt;tt&gt;int&lt;/tt&gt;.
    *
    * &lt;p&gt; An invocation of this method of the form
    * &lt;tt&gt;nextInt()&lt;/tt&gt; behaves in exactly the same way as the
    * invocation &lt;tt&gt;nextInt(radix)&lt;/tt&gt;, where &lt;code&gt;radix&lt;/code&gt;
    * is the default radix of this scanner.
    *
    * @return the &lt;tt&gt;int&lt;/tt&gt; scanned from the input
    * <b><u>@throws InputMismatchException</u></b>
    *         if the next token does not match the &lt;i&gt;Integer&lt;/i&gt;
    *         regular expression, or is out of range
    * <b><u>@throws NoSuchElementException</u></b> if input is exhausted
    * <b><u>@throws IllegalStateException</u></b> if this scanner is closed
    */
    public int nextInt() {
        return nextInt(defaultRadix);
    }
    </pre>

    <p>Звернять увагу на мітку <tt>@throws</tt> для <tt>InputMismatchException</tt>, <tt>NoSuchElementException</tt> та <tt>IllegalStateException</tt>. Коли метод може викликати багато винятків, за угодою вони перелічуються в алфавітному порядку (як в цьому випадку).</p>

    </div>

    <h5>Змінення та повторний виклик винятків</h5>

    <p>Можна відловлювати винятки, обгортати їх у більш загальні винятки та викликати їх для рівня вище по стеку викликів. Коли ви спіймали виняток та створили дільш загальний виняток, можна зберегти посилання на оригінальний виняток; це називається <em>зцепленням винятків</em>.</p>

    <pre>
    catch(LowLevelException lle) {
        // wrap the low-level exception to a higher-level exception;
        // also, chain the original exception to the newly thrown exception
        throw new HighLevelException(lle);
    }
    </pre>

    <p>Зцеплення винятків корисне для цілей відладки. При створенні загального винятку можна перевірити, чи існує зцеплений виняток нижчого рівня, та спробувати зрозуміти причину його трапляння.</p>

    <h3>Пам'ятка</h3>

    <p>Варто запам'ятати:</p>

    <ul>
        <li>Якщо метод не має клаузи <tt>throws</tt>, це <em>не</em> означає, що він не може викликати будь-який виняток; це лише значить, що ві не може викликати жоден виняток, <em>що перевіряється</em>.</li>

        <li>Статичні блоки ініціалізації не можуть викликати жоден виняток, що перевіряється. Чому? Пригадайте, що статичні блоки ініціалізації викликаються при завантаженні класу, тож не можна обробити викликаний виняток у процесі, який робить виклик. Більш за те, не можна оголосити винятки, що перевіряються, в клаузі <tt>throws</tt> (оскільки йдеться про <em>блоки</em>, а не методи).</li>

        <li>Не-статичні блоки ініціалізації можуть викликати винятки, що перевіряються; однак, всі конструктори мають оголошувати такі винятки в своїх клаузах <tt>throws</tt>. Чому? Компілятор в фазі генерації з'єднує код для не-статичних блоків ініціалізації та конструкторів, отже клауза tt>throws</li> конструктора може бути використана для оголошення винятків, що перевіряються, які може викликати не-статичний блок ініціалізації.</li>

        <li>Перевизначений метод не може оголосити в клаузі <tt>throws</tt> винятків, що перевіряються, більше, чим у списку винятків, оголошеному в клаузі <tt>throws</tt> базового метода. Чому? Користувачі базового методу бачать тільки список винятків, наданий в клаузі <tt>throws</tt> того методу, та оголошуватимуть обробники цих винятків, що перевіряються, в своєму коді (та не більше).</li>

        <li>Перевизначений метод може оголосити більш специфічні винятки, ніж винятки, перелічені в клаузі <tt>throws</tt> базового методу; іншими словами, можна оголосити породжені винятки в клаузі <tt>throws</tt> перевизначеного методу.</li>

        <li>Якщо метод оголошений в двох чи більше інтерфейсах, та якщо цей метод оголошує виклик різних винятків в своїй клаузі <tt>throws</tt>, реалізація методу має перелічити всі ці винятки.</li>
    </ul>

    <h2>Try-with-Resources</h2>

    <p>Цілі</p>

    <ul><li>Використання ресурсів Autoclose з оператором <tt>try-with-resources</tt></li></ul>

    <p>Доволі поширена серед програмістів Java помилка забувати вивільняти ресурси, навіть у блоці <tt>finally</tt>. Також при роботі з багатьма ресурсами досить втомливо пам'ятати викликати метод <tt>close()</tt> в блоці <tt>finally</tt>. Властивість <tt>try-with-resources</tt> (запроваджена в Java 7) спрощує життя. Лістинг <a href="#Listing0713">7-13</a> використовує цю властивість; це &ndash; поліпшена версія Лістингу <a href="#Listing0708">7-8</a>, яка робить явний виклик <tt>close</tt>, а саме <tt>consoleScanner.close()</tt>.</p>

    <pre id="Listing0713">
    // Лістинг 7-13. TryWithResources1.java
    import java.util.Scanner;

    class TryWithResources1 {
        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле: ");
            try(Scanner consoleScanner = new Scanner(System.in)) {
                System.out.println("Ви надрукували ціле значення: " + consoleScanner.nextInt());
            } catch(Exception e) {
                // зловити всі інші винятки тут ...
                System.out.println("Помилка: Трапився виняток та ціле не можна зчитати з консолі... ");
                System.out.println("Вихід з програми - перезапустіть програму!");
            }
        }
    }
    </pre>

    <p>Придивіться до синтаксису блоку <tt>try-with-resources</tt>.</p>

    <pre>try(Scanner consoleScanner = new Scanner(System.in)) {</pre>

    <p>В цьому операторі ви отримуєте ресурси всередині дужок після ключового слова <tt>try</tt>, але перед блоком <tt>try</tt>. Також в прикладі не потрібно надавати блок <tt>finally</tt>. Компілятор Java всередині перекладе цей блок <tt>try-with-resources</tt> в блок a <tt>try-finally</tt> (звичайно, компілятор залишить надані вами блоки <tt>catch</tt>). Ви можете отримати багато ресурсів в блоці <tt>try-with-resources</tt>. Оператори таких отримань ресурсів мають бути розділені крапкою з комою.</p>

    <p>Чи можна використовувати оператори <tt>try-with-resources</tt> без явних блоків <tt>catch</tt> чи <tt>finally</tt>? Так! Пам'ятайте, що блок <tt>try</tt> може бути пов'язаним з блоком <tt>catch</tt>, блоком <tt>finally</tt> чи обома. Блок оператора <tt>try-with-resources</tt> внутрішньо розширюється в блок <tt>try-finally</tt>. Тож, можна використовувати оператор <tt>try-with-resources</tt> без явних блоків <tt>catch</tt> чи <tt>finally</tt>. В лістингу <a href="#Listing0714">7-14</a> використовується оператор <tt>try-with-resources</tt> без явних блоків <tt>catch</tt> чи <tt>finally</tt>.</p>

    <pre id="Listing0714">
    // Лістинг 7-14. TryWithResources2.java
    import java.util.Scanner;

    class TryWithResources2 {
        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле: ");
            try(Scanner consoleScanner = new Scanner(System.in)) {
                System.out.println("Ви надрукували ціле значення: " + consoleScanner.nextInt());
            }
        }
    }
    </pre>

    <p>Хоча й можливо створювати оператор <tt>try-with-resources</tt> без жодного явного <tt>catch</tt> чи <tt>finally</tt>, це не означає, що треба так робити! Наприклад, оскільки наведений фрагмент не має блоку <tt>catch</tt>, при неправильному вводі програма завершиться аварійно.</p>

    <pre>
    $ java TryWithResources2 
    Надрукуйте ціле: 
    десять
    Exception in thread "main" java.util.InputMismatchException
        at java.base/java.util.Scanner.throwFor(Scanner.java:939)
        at java.base/java.util.Scanner.next(Scanner.java:1594)
        at java.base/java.util.Scanner.nextInt(Scanner.java:2258)
        at java.base/java.util.Scanner.nextInt(Scanner.java:2212)
        at TryWithResources2.main(TryWithResources2.java:8)
    </pre>

    <p>Тож, перевага оператора <tt>try-with-resources</tt> полягає в тому, що він спрощує життя, дозволяючи не надавати явно блоки <tt>finally</tt>. Однак, блоки <tt>catch</tt> blocks досі треба надавати.</p>

    <p>Зауважте, що для того, щоб ресурс був придатним для використання в операторі tt>try-with-resources</p>, його клас має реалізувати інтерфейс <tt>java.lang.AutoCloseable</tt>. Цей інтерфейс оголошує один метод <tt>close()</tt>. Цей інтерфейс <tt>AutoCloseable</tt> був запроваджений разом з властивістю <tt>try-with-resources</tt> в Java 7 як базовий для інтерфейсу <tt>Closeable</tt>. Це забезпечує безпроблемну роботу існуючих класів ресурсів з оператором <tt>try-with-resources</tt>. Інауше кажучи, з <tt>try-with-resources</tt> можна використовувати старі класи потоків, оскільки вони реалізують інтерфейс <tt>AutoCloseable</tt>.</p>

    <p><img id="c07f03" src="Images/c07f03.jpg"/><br/>
    Рис. 7-3. Інтерфейс <tt>Closeabe</tt> розширює інтерфейс <tt>AutoCloseable</tt></p>

    <h3>Закриття декількох ресурсів</h3>

    <p>В операторі <tt>try-with-resources</tt> можна використовувати декілька ресурсів. Розглянемо приклад створення zip-файла із наданого текстового файлу з використанням оператора <tt>try-with-resources</tt>:</p>

    <pre id="c07s02">
    // buffer це тимчасовий байтовий буфер для копіювання даних
    // з одного потоку до іншого
    byte [] buffer = new byte[1024];

    // ці конструктори потоку можуть викликати FileNotFoundException
    try (ZipOutputStream zipFile = new ZipOutputStream(new FileOutputStream(zipFileName));
        FileInputStream fileIn = new FileInputStream(fileName)) {
        zipFile.putNextEntry(new ZipEntry(fileName));   // putNextEntry може викликати
                                                        // IOException
        int lenRead = 0; // змінна для відслідковування квлькості вдало зчитаних байтів
        // скопіювати вміст вхідного файлу до zip файлу
        while((lenRead = fileIn.read(buffer)) &gt; 0) {    // read може викликати IOException
            zipFile.write(buffer, 0, lenRead);          // write може викликати IOException
        }
        // потоки будуть закриті автоматично оскільки вони всередині оператору try-with-resources
    }
    </pre>

    <p>В коді <tt>buffer</tt> &ndash; це байтовий масив. Цей масив &ndash; тимчасове сховище для копіювання необроблених даних з одного потоку до іншого. В операторі <tt>try-with-resources</tt> відкриваємо два потоки: <tt>ZipOutputStream</tt> для запису в zip-файл та <tt>FileInputStream</tt> для читання з текстового файлу (Примітка: підтримка API для zip (та jar) файлів наявна в пакеті <tt>java.util.zip</tt>). Ми хочемо читати вхідний текстовий файл, архівувати його та покласти результат в файл zip. Для покладання файла/каталога в архівний файл клас <tt>ZipOutputStream</tt> пропонує метод <tt>putNextEntry()</tt>, який приймає об'єкт <tt>ZipEntry</tt> як аргумент. Оператор <tt>zipFile.putNextEntry(new ZipEntry(fileName));</tt> поміщає файл <tt>fileName</tt> в <tt>zipFile</tt>.</p>

    <p>Для читання змісту текстового файла використовуємо метод <tt>read()</tt> в класі <tt>FileInputStream</tt>. Метод <tt>read()</tt> приймає масив  <tt>buffer</tt> як аргумент. Кількість даних для зчитування за одну ітерацію (тобто, розмір "шматка даних" для читання) завдається розміром  він повертає <tt>-1</tt>. Цикл <tt>while</tt> перевіряє успіх читання (використовуючи умову <tt>> 0</tt>) перед записом даних в файл <tt>zip</tt>.</p>

    <p>Для запису даних в файл <tt>zip</tt> використовується метод <tt>write()</tt> в класі <tt>ZipOutputStream</tt>. Метод <tt>write()</tt> приймає три аргументи: перший аргумент &ndash; це буфер даних; другий &ndash; початкове зміщення в буфері даних (в прикладі &ndash; <tt>0</tt> оскільки ми завжди читаємо з почтаку буфера);третій &ndash; кількість байтів для запису.</p>

    <p>Тепер ми підходимо до головного. Звернять увагу на те, як ми відкриваємо два ресурси в блоці <tt>try</tt>, та на крапку з комою для відокремлення операторів отримання цих ресурсів. Нам не потрібен у явному вигляді блок <tt>finally</tt> для вивільнення ресурсів, оскільки компілятор автоматично вставить виклики методів <tt>close</tt> для цих двох потоків в блоці(-ках) <tt>finally</tt>.</p>

    <p>Лістинг <a href="#Listing0715">7-15</a> містить повну програму, яка використовує цей фрагмент коду для демонстрації використання оператора <tt>try-with-resources</tt> для автоматичного закриття декількох потоків.</p>

    <pre id="Listing0715">
    // Лістинг 7-15. ZipTextFile.java
    import java.util.*;
    import java.util.zip.*;
    import java.io.*;

    // клас ZipTextFile приймає ім'я текстового файлу на вхід та створює файл zip
    // після компресії текстового файлу
    class ZipTextFile {
        public static final int CHUNK = 1024; // для копіювання блоків по 1KB
        public static void main(String []args) {
            if(args.length == 0) {
                System.out.println("Надайте як аргумент ім'я файлу в поточному каталозі, який треба стиснути");
                System.exit(-1);
            }
            String fileName = args[0];
            // ім'я файлу zip це ім'я вхідного файлу із суфіксом ".zip"
            String zipFileName = fileName + ".zip";
            byte [] buffer = new byte[CHUNK];
            // ці конструктори можуть викликати FileNotFoundException
            try (ZipOutputStream zipFile = new ZipOutputStream(new FileOutputStream(zipFileName));
                    FileInputStream fileIn = new FileInputStream(fileName)) {
                // putNextEntry може викликати IOException
                zipFile.putNextEntry(new ZipEntry(fileName));
                int lenRead = 0; // змінна для відсідковування кількості вдало зчитаних байтів
                // скопіювати вміст вхідного файлу до файлу zip
                while((lenRead = fileIn.read(buffer)) &gt; 0) {
                    // обидва методи read та write можуть викликати IOException
                    zipFile.write (buffer, 0, lenRead);
                }
                // потоки будуть закриті автоматично оскільки вони всередині оператора try-with-resources
            }
            // це може спрацювати завдяки багатьом виняткам, викликаним в блоці try;
            // використовуйте "пригнічені винятки" для отримання винятків, які були пригнічені!
            catch(Exception e) {
                System.out.println("Спіймані винятки: " + e);
                System.out.print("Пригнічені винятки: ");
                for(Throwable suppressed : e.getSuppressed()) {
                    System.out.println(suppressed);
                }
            }
        }
    }
    </pre>

    <p>Ми обговорили блок <tt>try-with-resources</tt>. Про що не поговорили &ndash; <em>пригнічені (suppressed) винятки</em>. В операторі <tt>try-with-resources</tt> можу бути викликано більше одного винятку; наприклад, один всередині блоку <tt>try</tt>, один всередині блоку <tt>catch</tt>, а інший &ndash; всередині блоку <tt>finally</tt>. Однак, піймати можна лише один виняток, тож інші винятки мають бути перелічені як винятки  <tt>getSuppressed</tt>. В отриманому об'єкті <tt>exception</tt> можна використати метод <tt>getSuppressed()</tt> для отримання списку пригнічених винятків.</p>

    <h3>Пам'ятка</h3>

    <p>Варто запам'ятати:</p>

    <ul>
        <li>Всередині тіла оператора <tt>try-with-resources</tt> не можна робити будь-яке присвоєння змінним, оголошеним в <tt>try-with-resources</tt>. Це зроблено для забезпечення того, що в блоці <tt>finally</tt> будуть вивільнені ті самі ресурси, які було отримано в заголовці оператора <tt>try-with-resources</tt>.</li>

        <li>
            Поширена помилка явно закривати ресурс всередині оператора <tt>try-with-resources</tt>. Пам'ятайте, що <tt>try-with-resources</tt> озширюється викликами метода <tt>close()</tt> в блоці <tt>finally</tt>, тож, якщо ви явно надасте метод <tt>close()</tt>, розширений код міститиме подвійний виклик метода <tt>close()</tt>. Розглянемо наступний код:

            <pre>
    try(Scanner consoleScanner = new Scanner(System.in)) {
        System.out.println("Ви надрукували ціле значення: " +
                consoleScanner.nextInt());
       consoleScanner.close();
       // явний виклик методу close() - пам'ятайте, що оператор try-with-resources
       // буде розширений до виклику close() в фінальному методі;
       // отже, це призведе до виклику методу close() в Scanner двічі!
    }
    </pre>
        </li>

        <li>Документація для метода <tt>close()</tt> в класі <tt>Scanner</tt> твердить: якщо об'єкт <tt>scanner</tt> вже закритий, то виклик методу знов не матиме ефекту. Тож, цього разу все гаразд. Однак, загалом, не можна очікувати, що всі ресурси при імплементації методу <tt>close()</tt> забезпечують таку поведінку при подвійному виклику. Тож, явний виклик метода <tt>close()</tt> всередині оператора <tt>try-with-resource</tt> є поганою практикою.</li>
    </ul>

    <h2>Власні винятки</h2>

    <p>Цілі</p>

    <ul><li>Створення власних винятків та ресурсів Auto-closeable</li></ul>

    <p>В багатьох ситуаціях достатньо викликати винятки, які вже надано в бібліотеці Java. Наприклад, при перевірці правильності наданих до публічної функції аргументів та виявленні порожніх значень чи значень поза межами припустимого діапазону можна викликати<tt>IllegalArgumentException</tt>. Однак, для більшості нетривіальних програм для обізначення виняткових умов необхідно розробляти власні класи винятків (власні винятки).</p>

    <p>Як визначається власний виняток? Існує два варіанти: в залежності від потреб можна розширити клас <tt>Exception</tt> чи клас <tt>RuntimeException</tt>.</p>

    <p>Якщо треба примусити користувача вашого власного винятка обробляти його, то можна розширитися від класу <tt>Exception</tt> &ndash; це зробить ваш власний виняток винятком, що перевіряється.</p>

    <p>Якщо треба надати користувачу гнучкості в обробці вашого власного винятка та залишити йому право вирішувати, чи буде він його обробляти, можна породити власний виняток від класу <tt>RuntimeException</tt>.</p>

    <p>Отже, ви маєте вирішити, чи бажаєте зробити власний виняток винятком, що перевіряється, чи винятком, що не перевіряється, породивши його від класу <tt>Exception</tt> чи класу <tt>RuntimeException</tt> відповідно.</p>

    <p>Що на рахунок породження власних винятків від класів <tt>Throwable</tt> чи <tt>Error</tt>? Клас <tt>Throwable</tt> є дуже загальним для того, щоб робити його базовим для власних винятків, тож це не рекомендується. Клас <tt>Error</tt> cзаразервований для фатальних винятків, які викликає JVM (наприклад, <tt>StackOverflowError</tt>), тож він не доступний в якості базового для власних винятків.</p>

    <p><hr/>Власні винятки мають розширювати клас <tt>Exception</tt> або клас <tt>RuntimeException</tt>. Створення власних винятків від <tt>Throwable</tt> чи <tt>Error</tt> є поганою практикою.<hr/></p>

    <p>Для розширення від бізового класа потрібно подивитися на запропоновані ним методи. Припустимо створення власного винятку від класів <tt>Exception</tt> чи <tt>RuntimeException</tt> classes. Оскільки клас <tt>Exception</tt> є базовим для класу <tt>RuntimeException</tt>, достатньо знати члени класу <tt>Exception</tt>. В таблиці <a href="c07t01">7-1</a> перелічено важливі методи класу <tt>Exception</tt> (включаючи конструктори).</p>

    <table>
        <caption>Таблиця 7-1. Важливі методи та конструктори класа <tt>Exception</tt></caption>
        <tr><th>Член</th><th>Короткий опис</th></tr>
        <tr><td><tt>Exception()</tt></td><td>Конструктор по замовчанню класа <tt>Exception</tt> без додаткової (детальної) інформації про виняток.</td></tr>
        <tr><td><tt>Exception(String)</tt></td><td>Конструктор, який приймає як аргумент рядок з детальною інформацією.</td></tr>
        <tr><td><tt>Exception(String, Throwable)</tt></td><td>У доповнення до рядка з детальною інформацією цей конструктор приймає як аргумент причину винятка (яка є іншим винятком).</td></tr>
        <tr><td><tt>Exception(Throwable)</tt></td><td>Конструктор, який приймає як аргумент причину винятка.</td></tr>
        <tr><td><tt>String getMessage()</tt></td><td>Повертає детальне повідомлення (передається як рядок при створенні винятка).</td></tr>
        <tr><td><tt>Throwable getCause()</tt></td><td>Повертає причину винятка (<tt>null</tt> якщо немає).</td></tr>
        <tr><td><tt>Throwable[] getSuppressed()</tt></td><td>Повертає як масив перелік пригнічених винятків (виникають зазвичай внаслідок використання оператора <tt>try-with-resources</tt>).</td></tr>
        <tr><td><tt>void printStackTrace()</tt></td><td>Друкує на консоль (стандартний потік помилок) слід треку викликів (тобто, перелік викликів методів з відповідними номерами рядків). Якщо у винятку доступна причина (яка є іншим винятком), ця інформація також друкується. Якщо існують пригнічені винятки, вони також друкуються.</td></tr>
    </table>

    <p>Для демонстрації створення власних класів винятків розглянемо створення <tt>InvalidInputException</tt>. При невдалій спробі читати вхід (читання цілого в нашому випадку), ми бажаємо викликати <tt>InvalidInputException</tt>. Лістинг <a href="#Listing0716">7-16</a> визначає цей виняток як розширення класу <tt>RuntimeException</tt>.</p>

    <pre id="Listing0716">
    // Лістинг 7-16. InvalidInputException.java
    // власний "виняток, що не перевіряється", що буде викликаний
    // при неправильному вводі від користувача
    class InvalidInputException extends RuntimeException {
        // default constructor
        public InvalidInputException() {
            super();
        }
        // конструктор, який приймає String з детальною інформацією,
        // який ми передаємо далі при виклику винятка
        public InvalidInputException(String str) {
            super(str);
        }
        // конструктор, який запам'ятовує причину винятка та
        // викликає новий виняток
        public InvalidInputException(Throwable originalException) {
            super(originalException);
        }
        // перший аргумент приймає рядок детальної інформації,
        // створений при виклику винятка
        // а другий - для запам'ятовування причини винятка
        public InvalidInputException(String str, Throwable originalException) {
            super(str, originalException);
        }
    }
    </pre>

    <p>В класі <tt>InvalidInputException</tt> ми не запровадили жодного нового поля, але це можна зробити при необхідності. Це простий власний виняток, в якому конструктори просто викликають базові версії того ж типу. Клас <tt>CustomExceptionTest</tt> (див. Лістинг <a href="#Listing0717">7-17</a>) демонструє використання власного винятка.</p>

    <pre id="Listing0717">
    // Лістинг 7-17. CustomExceptionTest.java
    import java.util.Scanner;
    import java.util.NoSuchElementException;

    // клас для тестування власного винятку InvalidInputException
    class CustomExceptionTest {
        public static int readIntFromConsole() {
            Scanner consoleScanner = new Scanner(System.in);
            int typedInt = 0;
            try {
                typedInt = consoleScanner.nextInt();
            } catch(NoSuchElementException nsee) {
                System.out.println("Обгортання винятку та його виклик...");
                throw new InvalidInputException("Невірне ціле надано в консолі", nsee);
            } catch(Exception e) {
                // call all other exceptions here ...
                System.out.println("Помилка: Трапився виняток та неможливо зчитати ціле з консолі... ");
            }
            return typedInt;
        }

        public static void main(String [] args) {
            System.out.println("Надрукуйте ціле: ");
            try {
                System.out.println("Ви надрукували ціле значення: " + readIntFromConsole());
            } catch(InvalidInputException iie) {
                System.out.println("Помилка: Невірний ввід в консолі... ");
                System.out.println("Поточний пійманий виняток належить типу: " + iie);
                System.out.println("Оригінальний пійманий виняток належить типу: " +
                        iie.getCause());
            }
        }
    }
    </pre>

    <p>Спочатку треба скомпілювати програму.</p>

    <pre>
    $ java CustomExceptionTest 
    Надрукуйте ціле: 
    десять
    Обгортання винятку та його виклик...
    Помилка: Невірний ввід в консолі... 
    Поточний пійманий виняток належить типу: InvalidInputException: Невірне ціле надано в консолі
    Оригінальний пійманий виняток належить типу: java.util.InputMismatchException
    </pre>

    <p>В цьому коді використовується <tt>InvalidInputException</tt> так само, як будь-який заздалегідь визначений в бібліотеці Java виняток. В методі <tt>main()</tt> ми ловимо <tt>InvalidInputException</tt>, який викликається в методі <tt>readIntFromConsole()</tt>. Наступний оператор викликає метод <tt>toString()</tt> в класі <tt>InvalidInputException</tt>:</p>

    <pre>System.out.println("Поточний пійманий виняток належить типу: " + iie);</pre>

    <p>Ми не перевизначили метод <tt>toString()</tt>, тож клас <tt>InvalidInputException</tt> наслідує імплементацію по замовчанню метода <tt>toString()</tt> від базового класа <tt>RuntimeException</tt>. Цей метод по замовчанню <tt>toString()</tt> друкує ім'я викликаного винятка (<tt>InvalidInputException</tt>), а також включає рядок з детальною інформацією ("Невірне ціле надано в консолі"), яку ми передаємо при створенні об'єкта винятка. Останній оператор в методі <tt>main()</tt> отримує причину винятка.</p>

    <pre>System.out.println("Оригінальний пійманий виняток належить типу: " + iie.getCause());</pre>

    <p>Оскільки причиною <tt>InvalidInputException</tt> є <tt>InputMismatchException</tt>, то це ім'я винятка друкується нв консолі як повністю кваліфіковане ім'я <tt>java.util.InputMismatchException</tt>. Отже, <tt>InputMismatchException</tt> є причиною <tt>InvalidInputException</tt>; ці два винятки відомі як зцеплені винятки.</p>

    <h2>Твердження</h2>

    <p>Цілі</p>

    <ul><li>Перевірка інваріантів з використанням тверджень</li></ul>

    <p>При створенні програм ми робимо багато припущень. Іноді трапляється, що ці припущення не здійснюються, що призводить до помилкових ситуацій. Оператор <tt>assert</tt> використовується для перевірки наших припущень щодо програмного контексту.</p>

    <p>В Java підтримку для тверджень надає ключове слово <tt>assert</tt>. Коже опреатор твердження містить булевий вираз. Якщо його результат <tt>true</tt>, це означає істинність твердження та нічого не трапляється, а якщо результат <tt>false</tt>, тоді припущення, яке мало місце щодо програми, вже не вірне, та викликається <tt>AssertionError</tt>. Пам'ятайте, що клас <tt>Error</tt> та породжені від нього класи призначені для вказівки на серйозні проблеми часу виконання та не призначені для обробки. Аналогічно, при виклику <tt>AssertionError</tt> краща поведінка &ndash; не ловити виняток, а дозволити програмі заврешитися. Після цього треба з'ясувати, чому припущення стало хибним, та виправити програму.</p>

    <p>Для використання тверджень в програмах є багато причин. Одна причин: це дозволяє знайти проблеми раніше; при перевірці в програмі припущень, та виявленні хибності деяких з них, ми одразу знаємо, де шукати проблему. Також, коли інші програмісти читають вашу програму з твердженнями, вони краще розумітимуть код за рахунок того, що ви робите припущення за допмогою явних тверджень.</p>

    <h3>Опертор <tt>assert</tt></h3>

    <p>Оператори тверджень мають дві форми:</p>

    <pre>
    assert booleanExpression;

    assert booleanExpression : "Рядок з детальним повідомленням про помилку";
    </pre>

    <p>При використанні не булевого виразу в операторі <tt>assert</tt> виникне помилка компілятора. Лістинг <a href="#Listing0718">7-18</a> містить перший приклад тверджень.</p>

    <pre id="Listing0718">
    // Лістинг 7-18. AssertionExample1.java
    class AssertionExample1 {
        public static void main(String []args) {
            int i = Integer.MIN_VALUE;
            if(i &lt; 0) {
                // якщо значення від'ємне, конвертувати його в позитивне
                i = -i;
            }
            System.out.println("значення i: " + i);
            // в цій точці припускається, що i не може бути від'ємним;
            // ствердимо це, оскільки це припущення завжди справедливе
            assert (i &gt;= 0) : "неможливо: i від'ємне!";
        }
    }
    </pre>

    <p>В цій програмі перевіряється, чи значення <tt>i &lt; 0</tt>; використовується вираз <tt>-i</tt> для його перетворення в додатнє значення. Після виконання перевірки умови <tt>if(i &lt; 0)</tt> значення <tt>i</tt> не може бути від'ємним, в тому й полягає наше припущення. Про такі припущення можна стверджувати за допоогою оператора <tt>assert</tt>. Оператор <tt>assert</tt>:</p>

    <pre>assert (i &gt;= 0) : "неможливо: i від'ємне!";</pre>

    <p>Програма чудово виконується, якщо булевий вираз (<tt>i &gt;= 0</tt>) обчислюється в <tt>true</tt>. Якщо ж він обчислюється в <tt>false</tt>, програма завершиться аварійно з викликом <tt>AssertionError</tt>. Перевіримо цю поведінку (треба буде використовувати прапорець <tt>-ea</tt>, щоб дозволити твердження під час виконання; проце поговоримо трохи пізніше).</p>

    <pre>
    $ java -ea AssertionExample1 
    значення i: 10
    </pre>

    <p>Так, ця програма виконується успішно без виклику винятків.</p>

    <p>Чи існує якесь значення <tt>i</tt>, при якому умова схибить? Так! Якщо значенням <tt>i</tt> буде мінімальне можливе значення цілого, тоді його не можна буде перетворити в додатнє. Чому? Пам'ятаєте діапазон цілих: від -2<sup>31</sup> до 2<sup>31</sup> - 1, тобто значення <tt>i</tt> може біти від <tt>-2147483648</tt> до <tt>2147483647</tt>. Інакше кажучи, додатнє значення <tt>2147483648</tt> не належить до діапазону цілих. Отже, якщо значення <tt>i</tt> це <tt>-2147483648</tt>, то вираз <tt>-i</tt> викличе <em>переповнення</em>, а результатом знов буде <tt>-2147483648</tt>. Таким чином, наше припущення хибить.</p>

    <p>В лістингу <a href="#Listing0718">7-18</a> змінимо значення <tt>i</tt> на мінімальне для цілого:</p>

    <pre>int i = Integer.MIN_VALUE;</pre>

    <p>Тепер запустимо програму.</p>

    <pre>
    $ java -ea AssertionExample1 
    значення i: -2147483648
    Exception in thread "main" java.lang.AssertionError: неможливо: i від'ємне!
        at AssertionExample1.main(AssertionExample1.java:12)
    </pre>

    <p>Зверніть увагу, як хибить твердження. Програма завершується аварійно, оскільки викликає <tt>AssertionError</tt>, а для нього немає обробника.</p>

    <p>Важливо запам'ятати, що твердження по замовчанню заборонені під час виконання; для іх дозволу треба використовувати перемикач <tt>-ea</tt> (або його довгу форму <tt>-enableasserts</tt>). Для заборони тверджень під час виконання використовуйте перемикач <tt>-da</tt>. Якщо твердження заборонені під час виконання, навіщо використовувати перемикач <tt>-da</tt>? Багато для чого. Наприклад, якщо ми бажаємо дозволити твердження для всіх класів в даному пакеті та заборонити твердження для окремого класа з йього пакета, тоді перемикач <tt>-da</tt> стане у нагоді. Таблиця <a href="#c07t02">7-2</a> перелічує важливі аргументи командного рядка та їх значення. Зауважте, що потрібно перекомпілювати програми для дозволу або заборони тверджень; використання аргументів командного рядка при виклику JVM дозволяє або забороняє твердження.</p>

    <table id="c07t02">
        <caption>Таблиця 7-2. Важливі аргументи командного рядка для дозволу/заборони тверджень</caption>
        <tr><th>Аргумент командного рядка</th><th>Короткий опис</th></tr>
        <tr><td><tt>-ea</tt></td><td>Дозволяє твердження по замовчанню (окрім системних класів).</td></tr>
        <tr><td><tt>-ea:&lt;class name&gt;</tt></td><td>Дозволяє твердження для наданого <tt>class name</tt>.</td></tr>
        <tr><td><tt>-ea:&lt;package name&gt;...</tt></td><td>Дозволяє твердження у всіх членах даного пакета &lt;package name&gt;.</td></tr>
        <tr><td><tt>-ea:...</tt></td><td>Дозволяє твердження в даному пакеті без імені.</td></tr>
        <tr><td><tt>-esa</tt></td><td>Скорочення для <tt>-enablesystemsassertions</tt>; дозволяє твердження в системних класах. Використовується рідко.</td></tr>
        <tr><td><tt>-da</tt></td><td>Заобороняє твердження по замовчанню (окрім системних класів).</td></tr>
        <tr><td><tt>-da:&lt;class name&gt;</tt></td><td>Забороняє твердження для наданого <tt>class name</tt>.</td></tr>
        <tr><td><tt>-da:&lt;package name&gt;...</tt></td><td>Забороняє твердження у всіх членах даного пакета &lt;package name&gt;.</td></tr>
        <tr><td><tt>-da:...</tt></td><td>Забороняє твердження в даному пакеті без імені.</td></tr>
        <tr><td><tt>-dsa</tt></td><td>Скорочення для <tt>-disablesystemsassertions</tt>; забороняє твердження в системних класах. Використовується рідко.</td></tr>
    </table>

    <h2>Підсумки</h2>

    <p>Коротенько оглянемо ключові моменти теми.</p>

    <b>Використання операторів <tt>try-catch</tt> та <tt>throw</tt></b>

    <ul>
        <li>Коли виняток викликається зсередини блоку <tt>try</tt>, JVM шукає відповідний обробник <tt>catch</tt> у списку обробників по ланцюгу викликів метода. Якщо відповідного обробника не знайдено, такий необроблений виняток завершує програму аварійно.</li>
        <li>При наданні декількох обробників винятків (упорядкованих в стек обробників), специфічні обробники мають передувати більш загальним.</li>
        <li>Можливо отримати програмний доступ до сліду стеку за допомогою таких методів як <tt>printStackTrace()</tt> та <tt>getStackTrace()</tt>, які можна викликати в будь-якому об'єкті винятку.</li>
    </ul>

    <b>Використання клауз <tt>catch</tt>, <tt>multi-catch</tt> та <tt>finally</tt></b>

    <ul>
        <li>Блок <tt>block</tt> може мати багато обробників. Якщо причини двох або більше винятків схожі, та код обробки також схожий, можна вирішити об'єднати обробники в блок <tt>multi-catch</tt>.</li>
        <li>Блок <tt>catch</tt> не має опрацьовувати виняток чи повторно викликати його. <em>Приховування</em> або <em>замовчування</em> винятка шляхом його перехоплення без обробки є поганою практикою.</li>
        <li>Можна обгорнути певний виняток та викликати його як інший виняток. Такі два винятки стають <em>зціпленими винятками</em>. У викликаному винятку можна отримати його причину.</li>
        <li>Код всередині блоку <tt>finally</tt> виконуватиметься поза залежністю від успіху виконання блоку <tt>try</tt>.</li>
    </ul>

    <b>Використання автоматичного закриття ресурсів з оператором <tt>try-with-resources</tt></b>

    <ul>
        <li>Забути вивільнити ресурси шляхом явного виклику метода <tt>close()</tt> це поширена помилка. Можна використовувати оператор <tt>try-with-resources</tt> для спрощення коду та автоматичного закриття ресурсів.</li>
        <li>Опертором <tt>try-with-resources</tt> можна закривати декілька ресурсів. Ці ресурми треба відокремлювати крапкою з комою в заголовці оператора <tt>try-with-resources</tt>.</li>
        <li>Якщо блок <tt>try</tt> викликає виняток, а блок <tt>finally</tt> також викликає виняток (винятки), тоді винятки, які викликаються в блоці <tt>finally</tt>, будуть додані до винятка, який буде викликаний з блоку <tt>try</tt>, в якості пригнічених винятків.</li>
    </ul>

    <b>Створення власних винятків та ресурсів з автоматичним закриттям</b>

    <ul>
        <li>Рекомендується породжувати власні винятки від класів <tt>Exception</tt> чи <tt>RuntimeException</tt>.</li>
        <li>Клауза <tt>throws</tt> в методі це частина контракту, який повинен виконуватися перевизначеним методом породженого класа.</li>
        <li>Перевизначений метод може надати таку саму клаузу <tt>throws</tt>, як і в базовому методі, або більш специфічну.</li>
        <li>Перевизначений метод не може надати більш загальну клаузу <tt>throws</tt> або оголосити виклик додаткових винятків, що перевіряються, у порівнянні з клаузою <tt>throws</tt> базового методу.</li>
        <li>Для того, щоб ресурс можна було використовувати в операторі <tt>try-with-resources</tt>, його клас має реалізувати інтерфейс <tt>java.lang.AutoCloseable</tt> та вищначити метод <tt>close()</tt>.</li>
    </ul>

    <b>Перевірка інваріантів за допомогою тверджень</b>

    <ul>
        <li>Твердження це перевірка умов в програмі; вони можуть бути використані для явної перевірки припущень, зроблених під час написання програми.</li>
        <li>Оператор <tt>assert</tt> має дві форми: одна приймає аргумент <tt>Boolean</tt>, а інша приймає додатковий рядок.</li>
        <li>Якщо умова <tt>Boolean</tt>, яку надано оператору <tt>assert</tt>, хибить, (тобто, обчислюється в <tt>false</tt>), програма завершується з викликом <tt>AssertionError</tt>. Не рекомендується відловлювати та відновлюватися після виклику <tt>AssertionError</tt>.</li>
        <li>По замовчанню, твердження заборонені під час виконання. Можна використовувати аргументи командного рядка при виклику JVM <tt>-ea</tt> (для дозволу тверджень) та <tt>-da</tt> (для заборони тверджень) та їх варіанти.</li>
    </ul>

    <h1>Лекція 8</h1>
    <h1>Використання Java 8 Date/Time API</h1>
    <p>Цілі</p>
    <ul>
        <li>Створення подій, які засновані на даті та часі, та керування ними, в тому числі об'єднання дати та часу до одного об'єкту з використанням <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt>, <tt class="prettyprint lang-java">LocalDateTime</tt>, <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt> та <tt class="prettyprint lang-java">Duration</tt></li>
        <li>Робота з датами та часом крізь часові зони та керування змінами, що трапляються внаслідок переходу на літній час та назад, включаючи форматування значень дати та часу</li>
        <li>Визначення, створення та управління подіями, які засновані на даті та часі, з використанням <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt>, <tt class="prettyprint lang-java">Duration</tt> та <tt class="prettyprint lang-java">TemporalUnit</tt></li>
    </ul>

    <h2>Зміст</h2>

    <ol>
        <li><a href="#toc0801">Розуміння важливих класів <tt class="prettyprint lang-java">java.time</tt></a>
            <ol>
                <li><a href="#toc080101">Використання класу <tt class="prettyprint lang-java">LocalDate</tt></a></li>
                <li><a href="#toc080102">Використання класу <tt class="prettyprint lang-java">LocalTime</tt></a></li>
                <li><a href="#toc080103">Використання класу <tt class="prettyprint lang-java">LocalDateTime</tt></a></li>
                <li><a href="#toc080104">Використання класу <tt class="prettyprint lang-java">Instant</tt></a></li>
                <li><a href="#toc080105">Використання класу <tt class="prettyprint lang-java">Period</tt></a></li>
                <li><a href="#toc080106">Використання класу <tt class="prettyprint lang-java">Duration</tt></a></li>
            </ol>
        </li>
        <li><a href="#toc0802">Використання інтерфейсу <tt class="prettyprint lang-java">TemporalUnit</tt></a></li>
        <li><a href="#toc0803">Робота з часовими зонами та літнім часом</a>
            <ol>
                <li><a href="#toc080301">Використання класів, пов'язаних з часовою зоною</a>
                    <ol>
                        <li><a href="#toc08030101">Використання класу <tt class="prettyprint lang-java">ZoneId</tt></a></li>
                        <li><a href="#toc08030102">Використання класу <tt class="prettyprint lang-java">ZoneOffset</tt></a></li>
                        <li><a href="#toc08030103">Використання класу <tt class="prettyprint lang-java">ZonedDateTime</tt></a></li>
                    </ol>
                </li>
                <li><a href="#toc080302">Перехід на літній час</a></li>
            </ol>
        </li>
        <li><a href="#toc0804">Форматування дати та часу</a></li>
        <li><a href="#toc0805">Приклад авіа-подорожі</a></li>
        <li><a href="#toc0806">Підсумки</a></li>
    </ol>

    <p>Новий API Java для дати та часу запроваджений в пакеті <tt class="prettyprint lang-java">java.time</tt>. Цей новий API (в Java 8) замінює такі старі класи для підтримки функціональності, пов'язаної за датами та часом, як <tt class="prettyprint lang-java">Date</tt>, <tt class="prettyprint lang-java">Calendar</tt> та <tt class="prettyprint lang-java">TimeZone</tt>, що входять до пакету <tt class="prettyprint lang-java">java.util</tt>.</p>

    <p>Навіщо в Java 8 було запропоновано новий API для дати та часу, якщо вже с початку в ній були такі класи як <tt class="prettyprint lang-java">Date</tt> та <tt class="prettyprint lang-java">Calendar</tt>? Головна причина - незручний дизайн того API. Наприклад, клас <tt class="prettyprint lang-java">Date</tt> має компоненти як для дати, так і для часу; якщо потрібна лише інформація про час без прив'язки до дати, треба встановити значення компоненти для дати в нуль. Деякі аспекти класів також контр-інтуітивні. Наприклад, в конструкторі <tt class="prettyprint lang-java">Date</tt>, діапазон значень для дня від 1 до 31, але для місяця від 0 до 11 (не від 1 до 12)! Далі, існує багато проблем, пов'язаних з одночасною роботою <tt class="prettyprint lang-java">java.util.Date</tt> та
    <tt class="prettyprint lang-java">SimpleDateFormatter</tt>, оскільки вони не є потоко-безпечними.</p>

    <p>Java 8 в новому пакеті <tt class="prettyprint lang-java">java.time</tt> пропонує дуже гарну підтримку для функціональності, пов'язаної з датами та часом. Більшість класів в цьому пакеті незмінні (immutable) та потоко-безпечні. Ця лекція пояснює, як використовувати важливі класи та інтерфейси цього пакету, включаючи <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt>, <tt class="prettyprint lang-java">LocalDateTime</tt>, <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt>, <tt class="prettyprint lang-java">Duration</tt> та <tt class="prettyprint lang-java">TemporalUnit</tt>. Також ми навчимося, як працювати з часовими зонами та переходом на літній час, а також як форматувати значення дати та часу.</p>

    <p>API <tt class="prettyprint lang-java">java.time</tt> реалізує концепцію плавних інтерфейсів: його спроектовано у такий спосіб, що код стає більш читабельним та простішим у використанні. За цієї причини класи в цьому пакеті мають велику кількість статичних методів (багато з яких є фабричними <em>factory</em>). На додаток до цього, методи класів слідують загальній конвенції по іменуванню (наприклад, вони використовують префікси <tt class="prettyprint lang-java">plus</tt> та <tt class="prettyprint lang-java">minus</tt> для додавання чи віднімання значень дати або часу).</p>

    <h2 id="toc0801">Розуміння важливих класів <tt class="prettyprint lang-java">java.time</tt></h2>

    <p>Цілі</p>

    <ul>
        <li>Створення подій, які засновані на даті та часі, та керування ними, в тому числі об'єднання дати та часу до одного об'єкту з використанням <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt>, <tt class="prettyprint lang-java">LocalDateTime</tt>, <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt> та <tt class="prettyprint lang-java">Duration</tt></li>
        <li>Визначення, створення та управління подіями, які засновані на даті та часі, з використанням <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt>, <tt class="prettyprint lang-java">Duration</tt> та <tt class="prettyprint lang-java">TemporalUnit</tt></li>
    </ul>

    <p>Пакет <tt class="prettyprint lang-java">java.time</tt> складається з чотирьох під-пакетів:</p>

    <dl>
        <dt><tt class="prettyprint lang-java">java.time.temporal</tt></dt><dd>Забезпечує доступ до полів та складових одиниць дата/час</dd>
        <dt><tt class="prettyprint lang-java">java.time.format</tt></dt><dd>Форматує ввід та вивід об'єктів дата/час</dd>
        <dt><tt class="prettyprint lang-java">java.time.zone</tt></dt><dd>Надає засоби для управління зонами часу</dd>
        <dt><tt class="prettyprint lang-java">java.time.chrono</tt></dt><dd>Підтримує різні календарні системи, наприклад японський чи тайський календарі</dd>
    </dl>

    <p>В цьому розділі увагу зосереджено на темі дати/часу лише в обсязі сертифікаційного екзамену. Почнемо навчатися використовувати класи <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt>, <tt class="prettyprint lang-java">LocalDateTime</tt>, <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt> та <tt class="prettyprint lang-java">Duration</tt>.</p>

    <h3 id="toc080101">Використання класу <tt class="prettyprint lang-java">LocalDate</tt></h3>

    <p><tt class="prettyprint lang-java">java.time.LocalDate</tt> представляє дату без часу або часової зони. <tt class="prettyprint lang-java">LocalDate</tt> представлено в календарній системі ISO-8601 в форматі рік-місяць-день (YYYY-MM-DD): наприклад, 2020-04-16.</p>

    <hr/>
    В Java 8 API для дати та часу в якості формата календарної системи по замовчанню використовується ISO-8601. В цьому міжнародно визнаному форматі значення дати та часу впорядковано від найбільшої до найменшої одиниці часу: рік, місяць/тиждень, день, година, хвилина, секунда та мілісекунда/наносекунда.
    <hr/>

    <p>Приклад використання <tt class="prettyprint lang-java">LocalDate</tt>:</p>

    <pre id="LD01" class="prettyprint lang-java">
    LocalDate today = LocalDate.now();
    System.out.println("Сьогодні: " + today);
    </pre>

    <p>При запуску цей код надрукує:</p>

    <pre id="outLD01">
    Сьогодні: 2020-04-16
    </pre>

    <p>Метод <tt class="prettyprint lang-java">LocalDate.now()</tt> отримує поточну дату з використанням системного годинника, який базується на часовій зоні по замочанню. Можна отримати об'єкт <tt class="prettyprint lang-java">LocalDate</tt>, вказавши компоненти для дня, місяця та року явно:</p>

    <pre id="LD02" class="prettyprint lang-java">
    LocalDate newYear2021 = LocalDate.of(2021, 1, 1);
    System.out.println("Новий 2021 рік: " + newYear2021);
    </pre>

    <p>Цей код надрукує:</p>

    <pre id="outLD02">
    Новий 2021 рік: 2021-01-01
    </pre>

    <p>Розглянемо наступний код:</p>

    <pre id="LD03" class="prettyprint lang-java">
    LocalDate javaBirthday = LocalDate.of(1995, 23, 5);
    System.out.println("Дата офіційного випуску Java: " + javaBirthday);
    </pre>

    <p>Він викличе виняток:</p>

    <pre id="outLD03">
    Exception in thread "main" java.time.DateTimeException: Invalid value for MonthOfYear (valid values 1 - 12): 23
    </pre>

    <p>В цьому випадку значення аргументів <tt class="prettyprint lang-java">month</tt> та <tt class="prettyprint lang-java">dayOfMonth</tt> помінялися місцями. Метод <tt class="prettyprint lang-java">of()</tt> класу <tt class="prettyprint lang-java">LocalDate</tt> оголошений наступним чином:</p>

    <pre class="prettyprint lang-java">
    LocalDate of(int year, int month, int dayOfMonth)
    </pre>

    <p>Для уникнення цієї помилки американці можуть використовувати перевантажену версію <tt class="prettyprint lang-java">LocalDate.of(int year, Month month, int day)</tt>. Другий аргумент - <tt class="prettyprint lang-java">java.time.Month</tt> - перелічення, яке представляє 12 місяців року. При обміні місяцми аргументів дня та місяця ми отримаємо помилку уомпілятора. Нижче наведено поліпшену версію з використанням цього перелічення:</p>

    <pre id="LD04" class="prettyprint lang-java">
    LocalDate javaBirthday = LocalDate.of(1995, Month.MAY, 23);
    System.out.println("Дата офіційного випуску Java: " + javaBirthday);
    </pre>

    <p>Цей код надрукує:</p>

    <pre id="outLD04">
    Дата офіційного випуску Java: 1995-05-23
    </pre>

    <p>Клас <tt class="prettyprint lang-java">LocalDate</tt> має методи для додавання чи віднімання днів, тижнів, місяців чи років до/від поточного об'єкту <tt class="prettyprint lang-java">LocalDate</tt>. Наприклад, припустимо, що карантин закінчиться через 15 діб відтепер. Нижче наведено фрагмент коду, який показує дату закінчення карантину (з припущенням, що сьогодні 2020-04-16):</p>

    <pre id="LD05" class="prettyprint lang-java">
    long quarantineDays = 15L;
    LocalDate currDate = LocalDate.now();
    System.out.println("Карантин закінчиться: " + currDate.plusDays(quarantineDays));
    </pre>

    <p>Цей фрагмент надрукує:</p>

    <pre id="outLD05">
    Карантин закінчиться: 2020-05-01
    </pre>

    <p>Окрім методу <tt class="prettyprint lang-java">plusDays()</tt>, <tt class="prettyprint lang-java">LocalDate</tt> надає методи <tt class="prettyprint lang-java">plusWeeks()</tt>, <tt class="prettyprint lang-java">plusMonths()</tt> та <tt class="prettyprint lang-java">plusYears()</tt>, а також методи для віднімання: <tt class="prettyprint lang-java">minusDays()</tt>, <tt class="prettyprint lang-java">minusWeeks()</tt>, <tt class="prettyprint lang-java">minusMonths()</tt> та <tt class="prettyprint lang-java">minusYears()</tt>. В <a href="#c08t01">таблиці 8-1</a> перелічено ще декілька методів класу <tt class="prettyprint lang-java">LocalDate</tt>, які корисно знати (ця таблиця посилається до таких класів як <tt class="prettyprint lang-java">ZoneId</tt> - вони будуть розглянуті пізніше).</p>

    <table id="c08t01" border="1">
        <caption>Таблиця 8-1. Важливі методу класу <tt class="prettyprint lang-java">LocalDate</tt></caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
            <th>Приклад використання</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalDate now(Clock clock)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">LocalDate</tt> з поточною датою, використовуючи наданий аргумент <tt class="prettyprint lang-java">clock</tt></td>
            <td><tt class="prettyprint lang-java">LocalDate.now(Clock.systemDefaultZone());</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalDate now(ZoneId zone)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">LocalDate</tt> з поточною датою, використовуючи наданий аргумент <tt class="prettyprint lang-java">zone</tt></td>
            <td><tt class="prettyprint lang-java">LocalDate.now(ZoneId.of("Pacific/Chatham"));</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalDate ofYearDay(int year, int dayOfYear)</tt></td>
            <td>Повертає <tt class="prettyprint lang-java">LocalDate</tt> з наданих аргументів <tt class="prettyprint lang-java">year</tt> та <tt class="prettyprint lang-java">dayOfYear</tt></td>
            <td><tt class="prettyprint lang-java">LocalDate.ofYearDay(2020, 256);</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalDate parse(CharSequence dateString)</tt></td>
            <td>Повертає <tt class="prettyprint lang-java">LocalDate</tt> з наданого аргументу <tt class="prettyprint lang-java">dateString</tt></td>
            <td><tt class="prettyprint lang-java">LocalDate.parse("2020-04-16");</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalDate ofEpochDay(Long epochDay)</tt></td>
            <td>Повертає <tt class="prettyprint lang-java">LocalDate</tt>, додавши кількість днів <tt class="prettyprint lang-java">epochDay</tt> до першого дня епохи (почалася з 1970-м)</td>
            <td><tt class="prettyprint lang-java">LocalDate.ofEpochDay(18368);</tt></td>
        </tr>
    </table>

    <h3 id="toc080102">Використання класу <tt class="prettyprint lang-java">LocalTime</tt></h3>

    <p>Клас <tt class="prettyprint lang-java">java.time.LocalTime</tt> подібний до <tt class="prettyprint lang-java">LocalDate</tt> за винятком того, що <tt class="prettyprint lang-java">LocalTime</tt> представляє час без дат або часових зон. Час представлений в форматі календарної системи ISO-8601: HH:MM:SS.nanosecond. Обидва класи <tt class="prettyprint lang-java">LocalTime</tt> та <tt class="prettyprint lang-java">LocalDate</tt> використовують системний годинник та часову зону по замовчанню.</p>

    <p>Приклад використання <tt class="prettyprint lang-java">LocalTime</tt>:</p>

    <pre id="LT01" class="prettyprint lang-java">
    LocalTime currTime = LocalTime.now();
    System.out.println("Поточний час: " + currTime);
    </pre>

    <p>При виконанні надрукує:</p>

    <pre id="outLT01">
    Поточний час: 12:23:05.072
    </pre>

    <p>Як говорилося, <tt class="prettyprint lang-java">LocalTime</tt> використовує системний годинник та часову зону по замовчанню. Для створення інших об'єктів, заснованих на специфічних значеннях часу можна використовувати перевантажений метод <tt class="prettyprint lang-java">of()</tt> класу <tt class="prettyprint lang-java">LocalTime</tt>:</p>

    <pre id="LT02" class="prettyprint lang-java">
    System.out.println(LocalTime.of(18, 30));
    // надрукує: 18:30
    </pre>

    <p><tt class="prettyprint lang-java">LocalTime</tt> надає багато корисних методів для додавання чи віднімання годин, хвилин, секунд та наносекунд. Наприклад, у вас заплановано зустріч через 6.5 годин, та треба знайти точний час зустрічі. Фрагмент коду для цього:</p>

    <pre id="LT03" class="prettyprint lang-java">
    long hours = 6;
    long minutes = 30;
    LocalTime currTime = LocalTime.now();
    System.out.println("Зараз    : " + currTime);
    System.out.println("Зустріч в: " + currTime.plusHours(hours).plusMinutes(minutes));
    </pre>

    <p>Цей код надрукує наступне:</p>

    <pre id="outLT03">
    Зараз    : 00:53:14.470384
    Зустріч в: 07:23:14.470384
    </pre>

    <p>Окрім <tt class="prettyprint lang-java">plusHours()</tt> <tt class="prettyprint lang-java">LocalTime</tt> підримує методи <tt class="prettyprint lang-java">plusMinutes()</tt>, <tt class="prettyprint lang-java">plusSeconds()</tt> та <tt class="prettyprint lang-java">plusNanos()</tt>; також для віднімання існують <tt class="prettyprint lang-java">minusHours()</tt>, <tt class="prettyprint lang-java">minusMinutes()</tt>, <tt class="prettyprint lang-java">minusNanos()</tt> та <tt class="prettyprint lang-java">minusSeconds()</tt>. В <a href="#c08t02"> таблиці 8-2</a> перелічені декілька важливих методів класу <tt class="prettyprint lang-java">LocalTime</tt>.</p>

    <table id="c08t02" border="1">
        <caption>Таблиця 8-2. Важливі методи класу <tt class="prettyprint lang-java">LocalTime</tt></caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
            <th>Приклад використання</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalTime now(Clock clock)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">LocalTime</tt> з поточним часом, використовуючи аргумент <tt class="prettyprint lang-java">clock</tt></td>
            <td><tt class="prettyprint lang-java">LocalTime.now(Clock.systemDefaultZone()) // повертає поточний час як 01:04:01.372067</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalTime now(ZoneId zone)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">LocalTime</tt> з поточним часом, використовуючи аргумент <tt class="prettyprint lang-java">zone</tt></td>
            <td><tt class="prettyprint lang-java">LocalTime.now(ZoneId.of("Pacific/Chatham"); // поточний час як 10:50:59.212171</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalTime ofSecondOfDay(long daySeconds)</tt></td>
            <td>Повертає <tt class="prettyprint lang-java">LocalTime</tt> з аргументу <tt class="prettyprint lang-java">daySeconds</tt> (в добі 86400 секунд)</td>
            <td><tt class="prettyprint lang-java">LocalTime.ofSecondOfDay(66620); // повертає 18:30:20 оскільки саме тоді з початку доби мине (вже минуло) 66620 секунд</tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">LocalTime parse(CharSequence timeString)</tt></td>
            <td>Повертає <tt class="prettyprint lang-java">LocalTime</tt> з аргументу <tt class="prettyprint lang-java">dateString</tt></td>
            <td><tt class="prettyprint lang-java">LocalTime.parse("18:30:05"); // повертає об'єкт <tt class="prettyprint lang-java">LocalTime</tt>, який відповідає наданому <tt class="prettyprint lang-java">String</tt>, тобто: 18:30:05</tt></td>
        </tr>
    </table>

    <h3 id="toc080103">Використання класу <tt class="prettyprint lang-java">LocalDateTime</tt></h3>

    <p>Клас <tt class="prettyprint lang-java">java.time.LocalDateTime</tt> представляє дату і час без часових зон. <tt class="prettyprint lang-java">LocalDateTime</tt> можна уявляти як логічну комбінацію класів <tt class="prettyprint lang-java">LocalTime</tt> та <tt class="prettyprint lang-java">LocalDate</tt>. Формати дати та часу використовують календарну систему ISO-8601: YYYY-MM-DD HH:MM:SS.nanosecond.</p>

    <p>Приклад друкування поточних дати та часу:</p>

    <pre id="LDT01" class="prettyprint lang-java">
    LocalDateTime currDateTime = LocalDateTime.now();
    System.out.println("Сьогоднішня дата та поточний час: " + currDateTime);
    </pre>

    <p>Цей код надрукує:</p>

    <pre id="outLDT01">
    Сьогоднішня дата та поточний час: 2020-04-16T13:17:54.265719
    </pre>

    <p>Зверніть увагу, що літера <tt class="prettyprint lang-java">T</tt> стоїть перед часом та відокремлює компоненти дати та часу. Використання <tt class="prettyprint lang-java">LocalDateTime.now()</tt> повертає поточні дату та час з використанням системного годинника з часовою зоною по замовчанню.</p>

    <p>Багато класів в пакеті <tt class="prettyprint lang-java">java.time</tt>, вкючаючи <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt> та <tt class="prettyprint lang-java">LocalDateTime</tt>, підтримують методи для порівняння <tt class="prettyprint lang-java">isAfter()</tt> та <tt class="prettyprint lang-java">isBefore()</tt>:</p>

    <pre id="LDT02" class="prettyprint lang-java">
    LocalDateTime cPlusPlusBirthday = LocalDateTime.of(1983, 12, 30, 0, 0);
    LocalDateTime javaBirthday = LocalDateTime.of(1995, 5, 23, 0, 0);
    System.out.println("Java з'явилася після C++? "+javaBirthday.isAfter(cPlusPlusBirthday));
    </pre>

    <p>Для отримання з даного об'єкту <tt class="prettyprint lang-java">LocalDateTime</tt> об'єктів <tt class="prettyprint lang-java">LocalDate</tt> та <tt class="prettyprint lang-java">LocalTime</tt> можна використовувати відповідно методи <tt class="prettyprint lang-java">toLocalDate()</tt> та <tt class="prettyprint lang-java">toLocalTime()</tt>:</p>

    <pre id="LDT03" class="prettyprint lang-java">
    LocalDateTime dateTime = LocalDateTime.now();
    System.out.println("Сьогоднішня дата та поточний час: " + dateTime);
    System.out.println("Компонент дати: " + dateTime.toLocalDate());
    System.out.println("Компонент часу: " + dateTime.toLocalTime());
    </pre>

    <p>Цей код надрукує:</p>

    <pre id="outLDT03">
    Сьогоднішня дата та поточний час: 2020-04-16T11:37:17.825968
    Компонент дати: 2020-04-16
    Компонент часу: 11:37:17.825968
    </pre>

    <p>Подібно до методів, наведених в таблицях <a href="#c08t01">8-1</a> та <a href="#c08t02">8-2</a>, <tt class="prettyprint lang-java">LocalDateTime</tt> має такі методи як <tt class="prettyprint lang-java">now()</tt>, <tt class="prettyprint lang-java">of()</tt> та <tt class="prettyprint lang-java">parse()</tt>. Також, як і <tt class="prettyprint lang-java">LocalDate</tt> та <tt class="prettyprint lang-java">LocalTime</tt>, цей клас надає методи для додавання та віднімання років, місяців, днів, годин, хвилин, секунд та наносекунд.</p>

    <h3 id="toc080104">Використання класу <tt class="prettyprint lang-java">Instant</tt></h3>

    <p>Припустимо, нам необхідно відтрейсити виконання програми на Java або зберігти події в програмі у файлі. Для цх цілей знадобляться значення часових міток (timestamp), і ми зможемо зробити це, виористовуючи клас <tt class="prettyprint lang-java">java.time.Instant</tt>. Миттєві значення починаються з 1 січня 1970 о 00:00:00 (цей час відомий як <em>епоха Unix</em>).</p>

    <p>Всередині клас <tt class="prettyprint lang-java">Instant</tt> використовує змінну <tt class="prettyprint lang-java">long</tt>, яка містить кількість секунд, які минули з початку епохи Unix: 1970-01-01T00:00:00Z (значення до початку цієї епохи розглядаються як від'ємні). На додаток, <tt class="prettyprint lang-java">Instant</tt> використовує цілу змінну для збереження кількості наносекунд, які минули з цієї секунди. Програма в <a href="#Listing0801">Лістингу 8-1</a> використовує клас <tt class="prettyprint lang-java">Instant</tt>.</p>

    <pre id="Listing0801" class="prettyprint lang-java">
    // Лістинг 8-1. UsingInstant.java
    import java.time.Instant;

    public class UsingInstant {
        public static void main(String args[]){
            // Друкує мітку поточного часу із часовою зоною UTC
            Instant currTimeStamp = Instant.now();
            System.out.println("Миттєва мітка часу: "+ currTimeStamp);

            // Друкує кількість секунд з початку епохи Unix
            System.out.println("Минуло секунд: " + currTimeStamp.getEpochSecond());

            // Друкує часову мітку Unix в мілісекундах
            System.out.println("Минуло мілісекунд: " + currTimeStamp.toEpochMilli());
        }
    }
    </pre>

    <p>Ця програма надрукує:</p>

    <pre id="outListing0801">
    Миттєва мітка часу: 2020-04-15T07:31:06.373954Z
    Минуло секунд: 1586935866
    Минуло мілісекунд: 1586935866373
    </pre>

    <p>Яка різниця між <tt class="prettyprint lang-java">LocalDateTime</tt> та <tt class="prettyprint lang-java">Instant</tt>? Цей <a href="#UsingInstant01">приклад</a> ілюструє її:</p>

    <pre id="UsingInstant01" class="prettyprint lang-java">
    LocalDateTime localDateTime = LocalDateTime.now();
    Instant instant = Instant.now();
    System.out.println("LocalDateTime: " + localDateTime + " \nInstant: " + instant);
    </pre>

    <p>Він надрукує:</p>

    <pre id="outUsingInstant01">
    LocalDateTime: 2020-04-15T10:35:47.377699 
    Instant      : 2020-04-15T07:35:47.380462Z
    </pre>

    <p>Як можна побачити, значення часу <tt class="prettyprint lang-java">LocalDateTime</tt> відрізняється від значення <tt class="prettyprint lang-java">Instant</tt>. Чому? Тому що, наприклад, ми виконуємо цю програму на комп'ютері з часовою зоною 'Europe/Kiev', яка на +03:00 години випереджає грінвичський час. <tt class="prettyprint lang-java">LocalDateTime</tt> використовує часову зону по замовчанню, а <tt class="prettyprint lang-java">Instant</tt> - ні.</p>

    <h3 id="toc080105">Використання класу <tt class="prettyprint lang-java">Period</tt></h3>

    <p>Клас <tt class="prettyprint lang-java">java.time.Period</tt> використовується для вимірянн кільеості часу в термінах років, місяців та днів. Припустимо, ми придбали медичний препарат, та хочемо встигнути використати його до закінчення його терміну придатності. <a href="#UsingnPeriod01">Ось</a> як можна знайти, через скільки він скінчиться:</p>

    <pre id="UsingPeriod01" class="prettyprint lang-java">
    LocalDate manufacturingDate = LocalDate.of(2020, Month.JANUARY, 1);
    LocalDate expiryDate = LocalDate.of(2022, Month.JULY, 18);

    Period expiry = Period.between(manufacturingDate, expiryDate);

    System.out.printf("Термін придатності препарату закінчиться через: %d років, %d місяців та %d днів (%s)\n",
            expiry.getYears(), expiry.getMonths(), expiry.getDays(), expiry);
    </pre>

    <p>Ця програма надрукує:</p>

    <pre id="outUsingPeriod01">
    Термін придатності препарату закінчиться через: 2 років, 6 місяців та 17 днів (P2Y6M17D)
    </pre>

    <p>Цей приклад використовує метод <tt class="prettyprint lang-java">Period.between()</tt>, який приймає як аргументи два значення <tt class="prettyprint lang-java">LocalDate</tt> та повертає <tt class="prettyprint lang-java">Period</tt>. Ця програма використовує методи <tt class="prettyprint lang-java">getYears()</tt>, <tt class="prettyprint lang-java">getMonths()</tt> та <tt class="prettyprint lang-java">getDays()</tt> (вони повертають значення типу <tt class="prettyprint lang-java">int</tt>), які відповідно повертають кількість років, місяців та днів у наданому періоді. Метод <tt class="prettyprint lang-java">toString()</tt> класу <tt class="prettyprint lang-java">Period</tt> повертає значення <tt class="prettyprint lang-java">P2Y6M17D</tt>. В цьому рядку літери <tt class="prettyprint lang-java">P</tt>, <tt class="prettyprint lang-java">Y</tt>, <tt class="prettyprint lang-java">M</tt> та <tt class="prettyprint lang-java">D</tt> означають відповідно період, роки, місяці та дні.</p>

    <p>Можна додавати роки, місяці та дні до значення <tt class="prettyprint lang-java">Period</tt> або віднімати їх від нього, використовуючи методи <tt class="prettyprint lang-java">plusYears()</tt>, <tt class="prettyprint lang-java">plusMonths()</tt>, <tt class="prettyprint lang-java">plusDays()</tt>, <tt class="prettyprint lang-java">minusYears()</tt>, <tt class="prettyprint lang-java">minusMonths()</tt> та <tt class="prettyprint lang-java">minusDays()</tt>. В <a href="#c08t03">таблиці 8-3</a> наведено список інших важливих методів цього класу.</p>

    <table id="c08t03" border="1">
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
            <th>Приклад використання</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Period of(int years, int months, int days)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Period</tt>, устворений з наданих аргументів</td>
            <td><tt class="prettyprint lang-java"></tt></td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Period ofWeeks(int unit)</tt><br/>
                <tt class="prettyprint lang-java">Period ofDays(int unit)</tt><br/>
                <tt class="prettyprint lang-java">Period ofMonths(int unit)</tt><br/>
                <tt class="prettyprint lang-java">Period ofYears (int unit)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Period</tt>, устворений з наданого аргументу одиниці часу</td>
            <td><tt class="prettyprint lang-java">Period.ofWeeks(2) // Повертає P14D</tt><br/>
                <tt class="prettyprint lang-java">Period.ofDays(15) // Повертає P15D</tt><br/>
                <tt class="prettyprint lang-java">Period.ofMonths(6) // Повертає P6M</tt><br/>
                <tt class="prettyprint lang-java">Period.ofYears(4) // Повертає P4Y</tt><br/>
            </td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Period parse(CharSequence string)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Period</tt>, устворений з наданого рядку <tt class="prettyprint lang-java">string</tt></td>
            <td><tt class="prettyprint lang-java">Period.parse("P4Y6M15D") // Повертає P4Y6M15D</tt></td>
        </tr>
    </table>

    <hr/>
    Способи використання API Java 8 для дати та часу людиною та комп'ютером відрізняються з точки зору відповідної інформації. Наприклад, клас <tt class="prettyprint lang-java">Instant</tt> презентує часову мітку Unix та всередині використовує змінні <tt class="prettyprint lang-java">long</tt> та <tt class="prettyprint lang-java">int</tt>. Значення <tt class="prettyprint lang-java">Instant</tt> не дужи читабельні людиною, оскільки клас не підтримує методи для днів, місяців, годин і так далі (навпроти, клас <tt class="prettyprint lang-java">Period</tt> підтримує такі методи).
    <hr/>

    <h3 id="toc080106">Використання класу <tt class="prettyprint lang-java">Duration</tt></h3>

    <p>Як ми зазначали раніше, клас <tt class="prettyprint lang-java">Period</tt> представляє час в термінах років, місяців та днів. <tt class="prettyprint lang-java">Duration</tt> це еквівалент <tt class="prettyprint lang-java">Period</tt> для часу. Клас <tt class="prettyprint lang-java">Duration</tt> представляє час в термінах годин, хвилин, секунд і так далі. Він зручний для вимірювання машинного часу чи при роботі з об'єктами <tt class="prettyprint lang-java">Instance</tt>. Як і клас <tt class="prettyprint lang-java">Instance</tt>, клас <tt class="prettyprint lang-java">Duration</tt> зберігає компоненту для секунд як значення <tt class="prettyprint lang-java">long</tt>, а наносекунди - з використанням значення <tt class="prettyprint lang-java">int</tt>.</p>

    <p>Припустимо, ми бажаємо узнати, скільки часу лишилося до півночі:</p>

    <pre id="UsingDuration01" class="prettyprint lang-java">
    LocalDateTime comingMidnight =
            LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.MIDNIGHT);
    LocalDateTime now = LocalDateTime.now();
    Duration between = Duration.between(now, comingMidnight);
    System.out.println(between);
    </pre>

    <p>Цей код надрукує наступне:</p>

    <pre id="outUsingDuration01">
    PT11H32M56.26579S
    </pre>

    <p>Цей приклад використовує перевантажену версію метода <tt class="prettyprint lang-java">of()</tt> класу <tt class="prettyprint lang-java">LocalDateTime</tt>: <tt class="prettyprint lang-java">LocalDateTime of(LocalDate, LocalTime)</tt>. Виклик <tt class="prettyprint lang-java">LocalDate.now()</tt> повертає поточну дату, але нам потрібно додати добу до цього значення, отже ми використовуємо <tt class="prettyprint lang-java">LocalTime.MIDNIGHT</tt> для посилання на північ, що наближаєтсья. Метод <tt class="prettyprint lang-java">between()</tt> в <tt class="prettyprint lang-java">Duration</tt> приймає два значення часу &ndash; в даному випадку об'єкти <tt class="prettyprint lang-java">LocalDateTime</tt>. При виконанні цієї програми на годиннику було 12:27:03, тобто до півночі лишалося 11 годин, 32 хвилини та 56 з чимось секунд. Це відображається результатом <tt class="prettyprint lang-java">toString()</tt>, значенням типу <tt class="prettyprint lang-java">Period</tt>: PT11H32M56.26579S. Префікс <tt class="prettyprint lang-java">PT</tt> показує проміжок часу (period time), <tt class="prettyprint lang-java">H</tt> показує години, <tt class="prettyprint lang-java">M</tt> показує хвилини, а <tt class="prettyprint lang-java">S</tt> показує секунди.</p>

    <p>В таблиці <a href="#c08t04">8-4</a> перелічені деякі важливі методи класу <tt class="prettyprint lang-java">Duration</tt>. <tt class="prettyprint lang-java">TemporalUnit</tt> та <tt class="prettyprint lang-java">ChronoUnit</tt> обговорюватимуться нами трохи пізніше.</p>

    <table id="c08t04" border="1">
        <caption>Таблиця 8-4. Важливі методи класу <tt class="prettyprint lang-java">Duration</tt></caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
            <th>Приклад використання</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Duration of(long number, TemporalUnit unit)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Duration</tt>, утворений з наданого числа певної одиниці виміру</td>
            <td><tt class="prettyprint lang-java">Duration.of(3600, ChronoUnit.MINUTES) // Повертає "PT60H"</tt></td>
        </tr>
        <tr>
            <td>
                <tt class="prettyprint lang-java">Duration ofDays(long unit)</tt><br/>
                <tt class="prettyprint lang-java">Duration ofHours(long unit)</tt><br/>
                <tt class="prettyprint lang-java">Duration ofMinutes(long unit)</tt><br/>
                <tt class="prettyprint lang-java">Duration ofSeconds(long unit)</tt><br/>
                <tt class="prettyprint lang-java">Duration ofMillis(long unit)</tt><br/>
                <tt class="prettyprint lang-java">Duration ofNanos(long unit)</tt>
            </td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Duration</tt>, утворений з наданого аргументу</td>
            <td>
                <tt class="prettyprint lang-java">Duration.ofDays(4) // Повертає "PT96H"</tt><br/>
                <tt class="prettyprint lang-java">Duration.ofHours(2) // Повертає "PT2H"</tt><br/>
                <tt class="prettyprint lang-java">Duration.ofMinutes(15) // Повертає "PT15M"</tt><br/>
                <tt class="prettyprint lang-java">Duration.ofSeconds(30) //Повертає "PT30S"</tt><br/>
                <tt class="prettyprint lang-java">Duration.ofMillis(120) // Повертає "PT0.12S"</tt><br/>
                <tt class="prettyprint lang-java">Duration.ofNanos(120) // Повертає "PT0.00000012S"</tt><br/>
            </td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Duration parse(CharSequence string)</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Period</tt>, утворений з рядку <tt class="prettyprint lang-java">string</tt></td>
            <td><tt class="prettyprint lang-java"></tt></td>
        </tr>
    </table>

    <h2 id="toc0802">Використання інтерфейсу <tt class="prettyprint lang-java">TemporalUnit</tt></h2>

    <p>Інтерфейс <tt class="prettyprint lang-java">TemporalUnit</tt> є частиною пакету <tt class="prettyprint lang-java">java.time.temporal</tt>. Він представляє такі одиниці виміру дат та часу, як секунди, години, дні, місяці, роки і таке інше. Перелічення <tt class="prettyprint lang-java">java.time.temporal.ChronoUnit</tt> реалізує цей інтерфейс. Замість використання константних значень краще використовувати еквівалентні значення перелічення. Чому? Тому що використання значень перелічення <tt class="prettyprint lang-java">ChronoUnit</tt> призводить до більш читабельного коду; а крім того, зменшується шанс зробити помилку.</p>

    <p>Лістинг <a href="#Listing0802">8-2</a> друкує значення перелічення, засновані як на даті, так і на часі, а також на тривалості (проміжку часу).</p>

    <pre id="Listing0802" class="prettyprint lang-java">
    // Лістинг 8-2. ChronoUnitValues.java
    import java.time.temporal.ChronoUnit;

    public class ChronoUnitValues {
        public static void main(String []args) {
            System.out.println("ChronoUnit \t На даті \t На часі \t Тривалість");
            System.out.println("-----------------------------------------------------------");
            for(ChronoUnit unit : ChronoUnit.values()) {
                System.out.printf("%10s \t %b \t\t %b \t\t %s %n",
                unit, unit.isDateBased(), unit.isTimeBased(), unit.getDuration());
            }
        }
    }
    </pre>

    <p>Він друкує наступне:</p>

    <pre id="outListing0802">
    ChronoUnit   На даті     На часі     Тривалість
    -----------------------------------------------------------
         Nanos   false       true        PT0.000000001S 
        Micros   false       true        PT0.000001S 
        Millis   false       true        PT0.001S 
       Seconds   false       true        PT1S 
       Minutes   false       true        PT1M 
         Hours   false       true        PT1H 
      HalfDays   false       true        PT12H 
          Days   true        false       PT24H 
         Weeks   true        false       PT168H 
        Months   true        false       PT730H29M6S 
         Years   true        false       PT8765H49M12S 
       Decades   true        false       PT87658H12M 
     Centuries   true        false       PT876582H 
     Millennia   true        false       PT8765820H 
          Eras   true        false       PT8765820000000H 
       Forever   false       false       PT2562047788015215H30M7.999999999S 
    </pre>

    <p>Багато методів в пакеті <tt class="prettyprint lang-java">java.time</tt> приймають <tt class="prettyprint lang-java">TemporalUnit</tt> як аргумент. Наприклад, метод <tt class="prettyprint lang-java">of()</tt> класу <tt class="prettyprint lang-java">Duration</tt>:</p>

    <pre>
    Duration of(long amount, TemporalUnit unit)
    </pre>

    <p>Оскільк перелічення <tt class="prettyprint lang-java">ChronoUnit</tt> реалізує інтерфейс <tt class="prettyprint lang-java">TemporalUnit</tt>, в цей конструктор можна передавати значення перелічення <tt class="prettyprint lang-java">ChronoUnit</tt> як другий аргумент:</p>

    <pre id="UsingChronoUnit01" class="prettyprint lang-java">
    System.out.println(Duration.of(1, ChronoUnit.MINUTES).getSeconds()); // друкує: 60
    System.out.println(Duration.of(1, ChronoUnit.HOURS).getSeconds()); // друкує: 3600
    System.out.println(Duration.of(1, ChronoUnit.DAYS).getSeconds()); // друкує: 86400
    </pre>

    <p>Як видно з цього прикладу, <tt class="prettyprint lang-java">ChronoUnit</tt> допомагає працювати із значеннями одиниць виміру часу (секундами, хвилинами, годинами) та дати (днями, місяцями та роками).</p>

    <h2 id="toc0803">Робота з часовими зонами та літнім часом</h2>

    <p>Цілі</p>

    <ul>
        <li>Робота з датами та часом крізь часові зони та керування змінами, що трапляються внаслідок переходу на літній час та назад, включаючи форматування значень дати та часу</li>
    </ul>

    <p>Щойно ми обговорили деякі важливі класи в пакеті <tt class="prettyprint lang-java">java.time</tt>. Зараз поговоримо про те, як працювати з датами та часом в різних часових зонах та з переходом на літній час, а також про форматування значень дати та часу.</p>

    <h3 id="toc080301">Використання класів, пов'язаних з часовою зоною</h3>

    <p>Існує три важливі класи, про які треба знати для роботи з датами та часом в різних часових зонах: <tt class="prettyprint lang-java">ZoneId</tt>, <tt class="prettyprint lang-java">ZoneOffset</tt> та <tt class="prettyprint lang-java">ZonedDateTime</tt>.</p>

    <h4 id="toc08030101">Використання класу <tt class="prettyprint lang-java">ZoneId</tt></h4>

    <p>В пакеті <tt class="prettyprint lang-java">java.time</tt> клас <tt class="prettyprint lang-java">java.time.ZoneId</tt> представляє часові зони. Часові зони зазвичай ідентификуютсья з використанням зсуву від середнього часу Гринвічу (Greenwich Mean Time, GMT, а також UTC/Greenwich).</p>

    <p>Наприклад, ми мешкаємо в Україні, де існує єдина часова зона Europe/Kiev (зони завдаються цим форматом "регіон/місто"). Наступний <a href="TZ01">код</a> друкує часову зону:</p>

    <pre id="TZ01" class="prettyprint lang-java">
    System.out.println("Мій zone id: " + ZoneId.systemDefault());
    </pre>

    <p>Для нашої часової зони:</p>

    <pre id="outTZ01">
    Мій zone id: Europe/Kiev
    </pre>

    <p>Перелік часових зон можна отримати викликом статичного методу <tt class="prettyprint lang-java">getAvailableZoneIds()</tt> класу <tt class="prettyprint lang-java">ZoneId</tt>, який повертає <tt class="prettyprint lang-java">Set&lt;String&gt;</tt>:</p>

    <pre id="TZ02" class="prettyprint lang-java">
    Set&lt;String&gt; zones = ZoneId.getAvailableZoneIds();
    zones.forEach(System.out::println);
    System.out.println("Кількість доступних часових зон: " + zones.size());
    </pre>

    <p>Результат виконання (обмежено):</p>

    <pre>
    ...
    SystemV/EST5EDT
    Pacific/Majuro
    America/Argentina/Buenos_Aires
    Europe/Nicosia
    Pacific/Guadalcanal
    Europe/Athens
    US/Pacific
    Europe/Monaco
    Кількість доступних часових зон: 600
    </pre>

    <p>Для створення об'єкту <tt class="prettyprint lang-java">ZoneId</tt> можна передати відповідний ідентификатор в метод <tt class="prettyprint lang-java">of()</tt>:</p>

    <pre class="prettyprint lang-java">
    ZoneId AsiaKolkataZoneId = ZoneId.of("Asia/Kolkata");
    </pre>

    <h4 id="toc08030102">Використання класу <tt class="prettyprint lang-java">ZoneOffset</tt></h4>

    <p><tt class="prettyprint lang-java">ZoneId</tt> ідентифікує часову зону. Інший клас, <tt class="prettyprint lang-java">ZoneOffset</tt>, представляє зміщення часової зони відносно UTC/Greenwich. Наприклад, зона “Asia/Kolkata” має зміщення +05:30 (плюс 5 годин та 30 хвилин) відносно UTC/Greenwich. Клас <tt class="prettyprint lang-java">ZoneOffset</tt> розширює клас <tt class="prettyprint lang-java">ZoneId</tt>. Далі ми розглянемо приклад використання <tt class="prettyprint lang-java">ZoneOffset</tt>.</p>

    <h4 id="toc08030103">Використання класу <tt class="prettyprint lang-java">ZonedDateTime</tt></h4>

    <p>В Java 8, якщо нам потрібно працювати лише з датою, чи часом, чи часовою зоною, ми можемо використовувати відповідно <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt> чи<tt class="prettyprint lang-java">ZoneId</tt>. А якщо нам потрібні всі три одразу: дата, час та часова зона? Для цього можна використовувати клас <tt class="prettyprint lang-java">ZonedDateTime</tt>:</p>

    <pre id="ZDT01" class="prettyprint lang-java">
    LocalDate currentDate = LocalDate.now();
    LocalTime currentTime = LocalTime.now();
    ZoneId myZone = ZoneId.systemDefault();
    ZonedDateTime zonedDateTime = ZonedDateTime.of(currentDate, currentTime, myZone);
    System.out.println(zonedDateTime);
    </pre>

    <p>Результат:</p>

    <pre id="outZDT01">
    2020-04-15T13:54:13.234091+03:00[Europe/Kiev]
    </pre>

    <p><a href="#ZDT01">Попередній</a> фрагмент коду використовує перевантажений статичний метод <tt class="prettyprint lang-java">ZonedDateTime of(LocalDate, LocalTime, ZoneID)</tt>. Маючи <tt class="prettyprint lang-java">LocalDateTime</tt>, можна використати <tt class="prettyprint lang-java">ZoneId</tt> для отримання об'єкту <tt class="prettyprint lang-java">ZonedDateTime</tt>:</p>

    <pre id="ZDT02" class="prettyprint lang-java">
    LocalDateTime dateTime = LocalDateTime.now();
    ZoneId myZone = ZoneId.systemDefault();
    ZonedDateTime zonedDateTime = dateTime.atZone(myZone);
    </pre>

    <p>Демонстрацію перетворень між цими різними класами, пов'язаними з часовою зоною, наведено в <a href="#ZDT03">наступному</a> фрагменті коду, в якому створюється об'єкт <tt class="prettyprint lang-java">ZoneId</tt>, інформація про зону додається до об'єкта <tt class="prettyprint lang-java">LocalDateTime</tt> для отримання об'єкта <tt class="prettyprint lang-java">ZonedDateTime</tt>, а вже від отримується зміщення зони:</p>

    <pre id="ZDT03" class="prettyprint lang-java">
    ZoneId myZone = ZoneId.of("Asia/Kolkata");
    LocalDateTime dateTime = LocalDateTime.now();
    ZonedDateTime zonedDateTime = dateTime.atZone(myZone);
    ZoneOffset zoneOffset = zonedDateTime.getOffset();
    System.out.println(zoneOffset);
    </pre>

    <p>Він друкує наступне:</p>

    <pre id="outZDT03">
    +05:30
    </pre>

    <p>Припустимо, ми в Києві, зараз 30 березня 2021 року, на годиннику 10:00. Перед спілкуванням із товаришем в Нью-Йорку ми бажаємо з'ясувати різницю в часі між нашими містами. Лістинг <a href="Listing0803">8-3</a> містить програму, яка демонструє сумісне використання класів <tt class="prettyprint lang-java">ZoneId</tt>, <tt class="prettyprint lang-java">ZonedDateTime</tt> та <tt class="prettyprint lang-java">Duration</tt>.</p>

    <pre id="Listing0803" class="prettyprint lang-java">
    // Лістинг 8-3. TimeDifference.java
    import java.time.LocalDateTime;
    import java.time.Month;
    import java.time.ZoneId;
    import java.time.ZonedDateTime;
    import java.time.Duration;

    public class TimeDifference {
        public static void main(String[] args) {
            ZoneId kievZone = ZoneId.of("Europe/Kiev");
            ZonedDateTime dateTimeInKiev = ZonedDateTime.of(
                    LocalDateTime.of(2021, Month.MARCH, 30, 10, 0), kievZone);
            ZoneId nyZone = ZoneId.of("America/New_York");
            ZonedDateTime sameDateTimeInNY =
                    dateTimeInKiev.withZoneSameInstant(nyZone);
            Duration timeDifference = Duration.between(
                    dateTimeInKiev.toLocalTime(),
                    sameDateTimeInNY.toLocalTime());
            System.out.printf("Різниця в часі між зонами %s та %s складає %d годин\n",
                    kievZone, nyZone, timeDifference.toHours());
        }
    }
    </pre>

    <p>Результат виконання:</p>

    <pre id="outListing0803">
    Різниця в часі між зонами Europe/Kiev та America/New_York складає -7 годин
    </pre>

    <p>Ця програма створює два ZoneId: один для Київа та інший для Нью-Йорка. Після створення об'єкта <tt class="prettyprint lang-java">ZonedDateTime</tt> для київської часової зони з наданими датою та часом ми отримуємо такий самий об'єкт <tt class="prettyprint lang-java">ZonedDateTime</tt>для Нью-Йорку, викликаючи метод <tt class="prettyprint lang-java">withZoneSameInstant()</tt> класу <tt class="prettyprint lang-java">ZonedDateTime</tt>. Для знаходження різниці в часі ми використовуємо методи <tt class="prettyprint lang-java">Duration.between()</tt> та <tt class="prettyprint lang-java">toHours()</tt>.</p>

    <h3 id="toc080302">Перехід на літній час</h3>

    <p>Внаслідок сезонних коливань кількість сонячного світла не залишається однаковою протягом року. Влітку його більше, наприклад. Для кращого використання денного світла годинники встановлюються на годину раніше чи пізніше - переводяться на літній час чи з літнього часу (це називається часом збереження денного світла - daylight savings time, DST). Зазвичай ми переводимо годинники на годину вперед весною, а на годину назад восени:</p>

    <pre id="DST01" class="prettyprint lang-java">
    ZoneId kolkataZone = ZoneId.of("Asia/Kolkata");
    Duration kolkataDST = kolkataZone.getRules().getDaylightSavings(Instant.now());
    System.out.printf("Kolkata zone DST is: %d hours %n", kolkataDST.toHours());

    ZoneId nyZone = ZoneId.of("America/New_York");
    Duration nyDST = nyZone.getRules().getDaylightSavings(Instant.now());
    System.out.printf("New York zone DST is: %d hours%n", nyDST.toHours());
    </pre>

    <p>Результат:</p>

    <pre id="outDST01">
    Kolkata zone DST is: 0 hours 
    New York zone DST is: 1 hours
    </pre>

    <p>Виклик <tt class="prettyprint lang-java">zoneId.getRules().getDaylightSavings(Instant.now());</tt> повертає об'єкт <tt class="prettyprint lang-java">Duration</tt>, створений з урахуванням літнього часу: якщо <tt class="prettyprint lang-java">Duration.isZero()</tt> повертає <tt class="prettyprint lang-java">false</tt>, це означає, що в цій зоні діє літній час. В <a href="#outDST01">наведеному прикладі</a> часова зона Калькути не має ефекту літнього часу, а часова зона Нью Йорку має.</p>

    <h2 id="toc0804">Форматування дати та часу</h2>

    <p>При використанні в програмі дат та часу часто потребується друкувати їх в різних форматах. Також в різних форматах може знадобитися зчитувати таку інформацію. Для цих задач можна використовувати клас <tt class="prettyprint lang-java">DateTimeFormatter</tt> в пакеті <tt class="prettyprint lang-java">java.time.format</tt>.</p>

    <p>Клас <tt class="prettyprint lang-java">DateTimeFormatter</tt> пропонує багато наперед визначених констант для форматування значень дати та часу. Приклад таких засобів форматування (із зразками виводу):</p>

    <ul>
        <li>ISO_DATE (2020-04-16)</li>
        <li>ISO_TIME (11:25:47.624)</li>
        <li>RFC_1123_DATE_TIME (Thu, 16 Apr 2020 11:27:22 +0300)</li>
        <li>ISO_ZONED_DATE_TIME (2020-04-16T11:30:33.49+03:00[Europe/Kiev])</li>
    </ul>

    <p>Простий приклад використання наперед визначеного <tt class="prettyprint lang-java">ISO_TIME</tt> типу <tt class="prettyprint lang-java">DateTimeFormatter</tt>:</p>

    <pre id="FDT01" class="prettyprint lang-java">
    LocalTime wakeupTime = LocalTime.of(6, 0, 0);
    System.out.println("Час прокидатися: " + DateTimeFormatter.ISO_TIME.format(wakeupTime));
    </pre>

    <p>Він друкує наступне:</p>

    <pre id="outFDT01">
    Час прокидатися: 06:00:00
    </pre>

    <p>А якщо треба використати власний формат замість наперед визначеного? Для цього використовуйте метод <tt class="prettyprint lang-java">ofPattern()</tt> в класі <tt class="prettyprint lang-java">DateTimeFormatter</tt>:</p>

    <pre id="FDT02" class="prettyprint lang-java">
    DateTimeFormatter customFormat = DateTimeFormatter.ofPattern("dd MMM yyyy");
    System.out.println(customFormat.format(LocalDate.of(2020, Month.MAY, 9)));
    </pre>

    <p>Результат:</p>

    <pre id="outFDT02">
    09 May 2020
    </pre>

    <p>Для формування шаблонного рядку дати чи часу використовуються відповідні форматні літери. Вони можуть повторюватися.</p>

    <hr/>
    При використанні в форматних рядках для дати та часу значення літер в нижньому та верхньому регістрах можуть відрізнятися. Перед їх використанням уважно прочитайте документацію Javadoc для цих шаблонів. Наприклад, в <tt class="prettyprint lang-java">dd-MM-yy</tt>, <tt class="prettyprint lang-java">MM</tt> відповідає місяцю; однак, в <tt class="prettyprint lang-java">dd-mm-yy</tt>, <tt class="prettyprint lang-java">mm</tt> відповідає хвилинам!
    <hr/>

    <p>В <a href="#FDT02">попередньому фрагменті</a> коду наведено простий приклад створення власного формату дати. Схожі літери використовуються для створення власних шаблонних рядків для дат та часу. Нижче наведено перелік важливих літер та їх значень для створення власних шаблонів для дат (з прикладами):</p>

    <ul>
        <li>G (ера: BC, AD)</li>
        <li>y (рік ери: 2015, 15)</li>
        <li>Y (рік з тижнями: 2015, 15)</li>
        <li>M (місяць: 11, Nov, November)</li>
        <li>w (тиждень в році: 13)</li>
        <li>W (тиждень в місяці: 2)</li>
        <li>E (назва дня тижня: Sun, Sunday)</li>
        <li>D (день року: 256)</li>
        <li>d (день місяця: 13)</li>
    </ul>

    <p>Програма в Лістингу <a href="#Listing0804">8-4</a> використовує рядки простого та складного шаблонів для створення власних форматів дати.</p>

    <pre id="Listing0804" class="prettyprint lang-java">
    // Лістинг 8-4. CustomDatePatterns.java
    import java.time.LocalDateTime;
    import java.time.format.DateTimeFormatter;

    public class CustomDatePatterns {
        public static void main(String []args) {
            // шаблони від простого до складного
            String [] dateTimeFormats = {
                    "dd-MM-yyyy", /* d день (в місяці), M місяць, y рік */
                    "d '('E')' MMM, YYYY", /*E назва дня тижня, Y рік*/
                    "w'th week of' YYYY", /* w тиждень року */
                    "EEEE, dd'th' MMMM, YYYY" /*E назва дня тижня */
            };
            LocalDateTime now = LocalDateTime.now();
            for(String dateTimeFormat : dateTimeFormats) {
                System.out.printf("Шаблон : \"%s\"%nрезультат %s %n", dateTimeFormat,
                        DateTimeFormatter.ofPattern(dateTimeFormat).format(now));
            }
        }
    }
    </pre>

    <p>Результат виконання:</p>

    <pre id="outListing0804">
    Шаблон : "dd-MM-yyyy"
    результат 16-04-2020 
    Шаблон : "d '('E')' MMM, YYYY"
    результат 16 (Thu) Apr, 2020 
    Шаблон : "w'th week of' YYYY"
    результат 16th week of 2020 
    Шаблон : "EEEE, dd'th' MMMM, YYYY"
    результат Thursday, 16th April, 2020 
    </pre>

    <p>Як бачите, повторені літери формують більш довгий елемент. Наприклад, при використанні <tt class="prettyprint lang-java">E</tt> (назва дня тижня) результатом є “Thu”, в той час коли використання <tt class="prettyprint lang-java">EEEE</tt> виводить повну назву дня "Thursday".</p>

    <p>Інше важливе зостереження стосується того, як друкувати текст всередині наданої строки шаблону. Для цього використовується текст, відокремлений одинарними лапками, тож <tt class="prettyprint lang-java">DateTimeFormatter</tt> надрукує його як є. Наприклад, <tt class="prettyprint lang-java">'('E')'</tt> друкує <tt class="prettyprint lang-java">"(Wed)"</tt>. Якщо надати неправильний шаблон чи забути про використання одинарних лапок для відокремлення тексту від літер шаблону то виникне <tt class="prettyprint lang-java">DateTimeParseException</tt> внаслідок передачі "Неприпустимого шаблону (Illegal pattern)".</p>

    <p>Розглянемо аналогічний приклад створення власних шаблонів для часу. Нижче наведено перелік важливих літер для визначення шаблону часу:</p>

    <ul>
        <li>a (мітка для тексту "a.m./p.m.")</li>
        <li>H (година: діапазон 0 - 23)</li>
        <li>k (hour: діапазон 1 - 24)</li>
        <li>K (година в a.m./p.m.: діапазон 0 - 11)</li>
        <li>h (година в a.m./p.m.: діапазон 1 - 12)</li>
        <li>m (хіилина)</li>
        <li>s (секунда)</li>
        <li>S (частка секунди)</li>
        <li>z (часова зона: у загальному форматі)</li>
    </ul>

    <p>Для повного переліку літер та їх значень дивіться в Javadoc для класу <tt class="prettyprint lang-java">DateTimeFormatter</tt>. Лістинг <a href="#Listing0805">8-5</a> містить програму, яка використовує прості та складні шаблонні рядки для створення власних форматів часу.</p>

    <pre id="Listing0804" class="prettyprint lang-java">
    // Лістинг 8-5. CustomTimePatterns.java
    import java.time.LocalTime;
    import java.time.format.DateTimeFormatter;

    // Приклади використання шаблонних рядків для створення власних форматів часу
    class CustomTimePatterns {
        public static void main(String []args) {
            // шаблони від простого до складного
            String [] timeFormats = {
                    "h:mm", /* h година в am/pm (1-12), m хвилина */
                    "hh 'o''clock'", /* '' послідовність маскування для друку одинарної лапки */
                    "H:mm a", /* H година дня (0-23), a - це am/pm*/
                    "hh:mm:ss:SS", /* s секунди, S мілісекунди */
                    "K:mm:ss a" /* K година в am/pm (0-11) */
            };
            LocalTime now = LocalTime.now();
            for(String timeFormat : timeFormats) {
                System.out.printf("Час в форматі \"%s\": %s %n", timeFormat,
                        DateTimeFormatter.ofPattern(timeFormat).format(now));
            }
        }
    }
    </pre>

    <p>Результат:</p>

    <pre id="outListing0805">
    Час в форматі "h:mm": 4:02 
    Час в форматі "hh 'o''clock'": 04 o'clock 
    Час в форматі "H:mm a": 16:02 PM 
    Час в форматі "hh:mm:ss:SS": 04:02:46:90 
    Час в форматі "K:mm:ss a": 4:02:46 PM 
    </pre>

    <p>Зверніть увагу на те, як змінюється вивід в залежності від шаблону.</p>


    <h2 id="toc0805">Приклад авіа-подорожі</h2>

    <p>Розглянемо приклад використання багатьох розглянутих нами класів. Припустимо, нам необхідно вилітіти з Сінгапуру 1 липня 2021 в 06:00 ранку. Політ до Окленду в Новій Зеландії триває 10 годин. Як отримати час прибуття? Програма в лістингу <a href="#Listing0806">8-6</a> вирішує цю задачу.</p>

    <pre id="Listing0806" class="prettyprint lang-java">
    // Лістинг 8-6. FlightTravel.java
    import java.time.Month;
    import java.time.ZoneId;
    import java.time.ZonedDateTime;
    import java.time.LocalDateTime;
    import java.time.format.DateTimeFormatter;

    public class FlightTravel {
        public static void main(String[] args) {
            DateTimeFormatter dateTimeFormatter =
                    DateTimeFormatter.ofPattern("dd MMM yyyy hh.mm a");
            // Відправлення 1-го липня 2021, 6:00 вранці з "Singapore"
            ZonedDateTime departure = ZonedDateTime.of(
                    LocalDateTime.of(2021, Month.JULY, 1, 6, 0),
                    ZoneId.of("Asia/Singapore"));
            System.out.println("Виліт: " + dateTimeFormatter.format(departure));
            // Прибуття в "Auckland" в той самий день через 10 годин
            ZonedDateTime arrival =
                    departure.withZoneSameInstant(ZoneId.of("Pacific/Auckland"))
                    .plusHours(10);
            System.out.println("Прибуття: " + dateTimeFormatter.format(arrival));
        }
    }
    </pre>

    <p>Результат:</p>

    <pre id="outListing0806">
    Виліт   : 01 Jul 2021 06.00 AM
    Прибуття: 01 Jul 2021 08.00 PM
    </pre>

    <h2 id="toc0806">Підсумки</h2>

    <p>Коротенько розглянемо ключові моменти кожної з поставлених цілей.</p>

    <p><b>Створення подій, які засновані на даті та часі, та керування ними, в тому числі об'єднання дати та часу до одного об'єкту з використанням <tt class="prettyprint lang-java">LocalDate</tt>, <tt class="prettyprint lang-java">LocalTime</tt>, <tt class="prettyprint lang-java">LocalDateTime</tt>, <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt> та <tt class="prettyprint lang-java">Duration</tt></b></p>

    <ul>
        <li>API для дати та часу в Java 8 по замовчанню використовує календарний формат ISO 8601.</li>
        <li>Клас <tt class="prettyprint lang-java">java.time.LocalDate</tt> представляє дату без часу та без часових зон; клас <tt class="prettyprint lang-java">java.time.LocalTime</tt> представляє час без дат та часових зон; клас <tt class="prettyprint lang-java">java.time.LocalDateTime</tt> представляє дату та час без часових зон.</li>
        <li>Клас <tt class="prettyprint lang-java">java.time.Instant</tt> редставляє мітку часу Unix.</li>
        <li>Клас <tt class="prettyprint lang-java">java.time.Period</tt> використовується для вимірювання кількості часу в термінах років, місяців та днів.</li>
        <li>Клас <tt class="prettyprint lang-java">java.time.Duration</tt> представляє час в термінах годин, хвилин, секунд та часток секунд.</li>
    </ul>

    <p><b>Робота з датами та часом крізь часові зони та керування змінами, що трапляються внаслідок переходу на літній час та назад, включаючи форматування значень дати та часу</b></p>

    <ul>
        <li><tt class="prettyprint lang-java">ZoneId</tt> ідентификує часову зону; <tt class="prettyprint lang-java">ZoneOffset</tt> представляє зміщення часової зони відносно UTC/Greenwich.</li>
        <li><tt class="prettyprint lang-java">ZonedDateTime</tt> пропонує підтримку для всіх трьох складових: дати, часу та часової зони.</li>
        <li>При роботі з різними часовими зонами треба брати до уваги літній час (daylight savings time, DST).</li>
        <li>Клас <tt class="prettyprint lang-java">java.time.format.DateTimeFormatter</tt> надає підтримку для читання та друку значень дати та часу в різних форматах.</li>
        <li>Клас <tt class="prettyprint lang-java">DateTimeFormatter</tt> пропонує наперед задані константи (такі як ISO_DATE та ISO_TIME) для форматування значень дати та часу.</li>
        <li>З класом <tt class="prettyprint lang-java">DateTimeFormatter</tt> можна задати свій формат дати та часу, формуючи літерами шаблонний рядок.</li>
    </ul>

    <p><b>Визначення, створення та управління подіями, які засновані на даті та часі, з використанням <tt class="prettyprint lang-java">Instant</tt>, <tt class="prettyprint lang-java">Period</tt>, <tt class="prettyprint lang-java">Duration</tt> та <tt class="prettyprint lang-java">TemporalUnit</tt></b></p>

    <ul>
        <li>Перелічення <tt class="prettyprint lang-java">java.time.temporal.ChronoUnit</tt> реалізує інтерфейс <tt class="prettyprint lang-java">java.time.temporal.TemporalUnit</tt>.</li>
        <li><tt class="prettyprint lang-java">TemporalUnit</tt> та <tt class="prettyprint lang-java">ChronoUnit</tt> мають справи з такими значеннями одиниць виміру часу як секунди, хвилини, та години і виміру дат як дні, місяці та роки.</li>
    </ul>


    <h1>Лекція 9</h1>
    <h1>Основи вводу-виводу Java</h1>

	<p>Цілі</p>

	<ul>
		 <li>Читати дані з консолі та записувати дані в консоль</li>
		 <li>Використовувати класи <tt>BufferedReader</tt>, <tt>BufferedWriter</tt>, <tt>File</tt>, <tt>FileReader</tt>, <tt>FileWriter</tt>, <tt>FileInputStream</tt>, <tt>FileOutputStream</tt>, <tt>ObjectOutputStream</tt>, <tt>ObjectInputStream</tt> та <tt>PrintWriter</tt> з пакету <tt>java.io</tt></li>
	</ul>

	<p>В цій главі розглянемо основи програмування вводу-виводу в Java. Засередимося на двох темах: як зчитувати дані з консолі та виводити їх на консоль, та як використовувати (файлові) потоки для читання та запису даних.</p>

	<p>Підтримка операцій з файлами запроваджена в пакетах <tt>java.io</tt> та <tt>java.nio</tt>. На початку ми сфокусуємо увагу лише на пакеті<tt>java.io</tt>; а пакет <tt>java.nio</tt>, який пропонує повну підтримку файлового вводу-виводу, стане предметом наступного заняття.</p>

	<h2>Читання з консолі та запис в консоль</h2>

	<p>Для читання з консолі та запису в консоль мжна використовувати стандартниі потоки вводу, виводу та помилок чи використовувати клас<tt>Console</tt>. Обговоримо обидва підходи.</p>

	<h3>Розуміння стандартних потоків</h3>

	<p>Публічні статичні поля <tt>in</tt>, <tt>out</tt> та <tt>err</tt> в класі <tt>java.lang.System</tt> представляють стандартні потоки вводу, виводу та помилок відповідно. <tt>System.in</tt> належить типу <tt>java.io.InputStream</tt>, а <tt>System.out</tt> та <tt>System.err</tt> &ndash; типу <tt>java.io.PrintStream</tt>.</p>

	<p>Приклад читання цілого числа з консолі та його виводу на консоль (лістинг <a href="#c09l01">9-1</a>):</p>

    <pre id="c09l01" class="prettyprint lang-java">
    // Лістинг 9-1. Read.java
    import java.io.IOException;

    class Read {
    	public static void main(String []args) {
    		System.out.print("Надрукуйте ціле: ");
    		int val = 0;
    		try {
    			// результат читання - int, але повернулося значення byte!
    			val = System.in.read();
    		} catch(IOException ioe) {
    			System.err.println("Неможливо зчитати вхід " + ioe);
    			System.exit(-1);
    		}
    		System.out.println("Ви надрукували: " + val);
    	}
    }
    </pre>

    	<p>Приклад виконання програми:</p>

     <pre id="out0901" class="prettyprint lang-bsh">
    $ java Read 
    Надрукуйте ціле: 1
    Ви надрукували: 49
    </pre>

	<p>Тип результату метода <tt>read</tt> це <tt>int</tt>, але він повертає значення <tt>byte</tt> в діапазоні від <tt>0</tt> до <tt>255</tt> (так, це неінтуітивно). Отже, для входу <tt>1</tt> програма друкує його значення ASCII <tt>53</tt>. Метод <tt>read</tt> "блокується" (тобто, очікує) до вводу користувача; якщо при читанні трапляється виняток вводу-виводу, метод викликає <tt>IOException</tt>.</p>

	<p>Ця програма ілюструє використання всіх трьох потоків: <tt>System.in</tt> використовується для отримання вводу з консолі, <tt>System.out</tt> використовується для друку зчитаного цілого значення, а <tt>System.err</tt> використовується для повідомлення про помилку у випадку трапляння винятку вводу-виводу.</p>

	<p>Перевантажений метод <tt>read</tt> за природою низько-рівневий та працює у термінах байтів. Читання вводу інших типів, таких як <tt>Strings</tt>, вимагає його використання з класами <tt>Reader</tt> чи <tt>Scanner</tt>:</p>

    <pre class="prettyprint lang-java">
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String str = br.readLine();

    // чи java.util.Scanner:

    Scanner scanner = new Scanner(System.in);
    String str = scanner.next();
    </pre>

	<p>Згодом поговоримо більше про клаи <tt>Reader</tt> та <tt>Scanner</tt>.</p>

	<h4>Перепризначення стандартних потоків</h4>

	<p>Стандартні потоки ініціалізується при старті JVM. Інколи корисно перенаправити стандартні потоки шляхом їх перепризнаення. Метод <tt>System.setIn</tt> приймає об'єкт <tt>InputStream</tt> , а методи <tt>System.setOut</tt> та <tt>System.setError</tt> приймають об'єкти <tt>PrintStream</tt> в якості аргументів. Нижче наведено фрагмент код, який направляє стандартний вивід в файл шляхом перепризначення потоку <tt>System.out</tt> в текстовий файл:</p>

    <pre id="c09s01" class="prettyprint lang-java">
    import java.io.*;

    class StreamTest {
    	public static void main(String []args ){
    		try{
    			PrintStream ps = new PrintStream("log.txt");
    			System.setOut(ps);
    			System.out.println("Тестовий вивід до System.out");
    		} catch(Exception ee){
    			ee.printStackTrace();
    		}
    	}
    }
    </pre>

	<p>При виконанні програма створить файл "<tt>log.txt</tt>" та надрукує в ньому рядок "<tt>Тестовий вивід до System.out</tt>".</p>

	<p>Перенаправлення потоків корисно в багатьох випадках. Наприклад, замість читання з консолі в цілях тестування можна зчитувати ввід з текстового файлу. Цього можна досягти, перенаправивши потік стандартного вводу до текстового файла. Так само можна перепризначити потік помилок до текстовий файл з метою зберігання всіх повіомлень про помилки в журналі. Цього можна досягти викликом методу <tt>System.setErr</tt>.</p>

	<h3>Розуміння класу <tt>Console</tt></h3>

	<p>Використання класу <tt>Console</tt> допомагає зчитувати дані з консолі та запису даних в консоль. Зверніть увагу на те, що під "консоллю" тут треба розуміти пристрій вводу символів (звичайно &ndash; клавіатура) та пристрій відображення (зазвичай це екран комп'ютера. Можна отримати посилання на консоль, використавш метод <tt>System.console()</tt>; якщо JVM не пов'язана з жодною консоллю, цей метод поверне <tt>null</tt>.</p>

	<p>В якості вправи реалізуйте просту команду <tt>Echo</tt>, яка друкує рядок тексту, який було введено користувачем (лістинг <a href="#c09l02">9-2</a>).</p>

    <pre id="c09l02" class="prettyprint lang-java">
    import java.io.Console;

    // проста реалізація команди Echo
    class Echo {
    	public static void main(String []args) {
    		// отримати об'єкт системної консолі
    		Console console = System.console();
    		if(console == null) {
    			System.err.println("Неможливо отримати консольний об'єкт (програма виконується в IDE?): вихід з програми... ");
    			System.exit(-1); // перервати програму
    		}
    		// зчитати рядок та надрукувати його
    		console.printf(console.readLine());
    	}
    }
    </pre>

	<p>Як програма поводиться при різному вводі:</p>

    <pre class="prettyprint lang-bsh">
    $ java Echo 
    Ich bin so klar wie ein
    Ich bin so klar wie ein$ _

    $ java Echo 
    Рант'є Етьєн:%n
    Рант'є Етьєн:

    $ java Echo
    ^D
    Exception in thread "main" java.lang.NullPointerException
    	at java.base/java.util.regex.Matcher.getTextLength(Matcher.java:1770)
    </pre>

	<p>При звичайному вводі ця програма працює добре. А якщо нічого не ввести, а спробувати перервати виконання комбінацією клавиш <tt>^d</tt> (<tt>Ctrl+D</tt>), тоді програма не отримує вводу, метод <tt>readLine()</tt> поверне <tt>null</tt>; а коли <tt>printf</tt> приймає аргумент <tt>null</tt>, він викликає <tt>NullReferenceException</tt>.</p>

	<p>Зверніть увагу на те, що програму треба запускати з командного рядка. Метод <tt>System.console()</tt> спрацює добре, якщо JVM визивається з командного рядка без перенаправлення потоків вводу чи виводу, а отже JVM буде пов'язана з консоллю (зазвичай клавіатурою та екраном). Якщо JVM викликається опосередковано з IDE, чи JVM викликаєтсья з фонового процесу, тоді виклик метода <tt>System.console()</tt> схибить та поверне <tt>null</tt>. Наприклад, якщо запускати програму з IntelliJ IDEA чи Eclipse IDE, <tt>System.console()</tt> схибить та поверне <tt>null</tt>.</p>

	<p>
		<hr/>
		Якщо JVM викликається опосередковано з IDE чи з фонового процесу, виклик метода <tt>System.console()</tt> поверне <tt>null</tt>.
		<hr/>
	</p>

	<p>Деякі з важливих методів класу <tt>Console</tt> перелічені в таблиці <a href="#c09t01">9-1</a>.</p>

	<table id="c09t01" border="1" cellpadding="2">
		<caption>Таблиця 9-1. Важливі методи класу <tt>Console</tt></caption>
		<tr>
			<th>Метод</th>
			<th>Короткий опис</th>
		</tr>
		<tr>
			<td><tt>Reader reader()</tt></td>
			<td>Повертає об'єкт <tt>Reader</tt>, пов'язаний з об'єктом <tt>Console</tt>; може виконувати операції читання за посиланням, що повернулося.</td>
		</tr>
		<tr>
			<td><tt>PrintWriter writer()</tt></td>
			<td>Повертає об'єкт <tt>PrintWriter</tt>, пов'язаний з об'єктом <tt>Console</tt>; може виконувати операції запису за посиланням, що повернулося.</td>
		</tr>
		<tr>
			<td><tt>String readLine()</tt></td>
			<td>Зчитує рядок тексту <tt>String</tt> (цей об'єкт не включає символи кінця строки); повертає <tt>null</tt> якщо це не вдається (наприклад, користувач натискає в консолі <tt>Ctrl+D</tt>)</td>
		</tr>
		<tr>
			<td><tt>String readLine(String fmt, Object... args)</tt></td>
			<td>Те саме, що метод <tt>readLine()</tt>, але спочатку друкує рядок <tt>fmt</tt>.</td>
		</tr>
		<tr>
			<td><tt>char[] readPassword()</tt></td>
			<td>Зчитує текст пароля та повертаж як масив символів; в цьому методі заборонено відображення при друку, тож при друку пароля користувачем в консолі нічого не відображається.</td>
		</tr>
		<tr>
			<td><tt>char[] readPassword(String fmt, Object... args)</tt></td>
			<td>Те саме, що метод <tt>readPassword()</tt>, але спочатку друкує рядок <tt>fmt</tt>.</td>
		</tr>
		<tr>
			<td><tt>Console format(String fmt, Object... args)</tt></td>
			<td>Записує в консоль відформатований рядок (створений на основі значень строки <tt>fmt</tt> та наданих <tt>args</tt>).</td>
		</tr>
		<tr>
			<td><tt>Console printf(String fmt, Object... args)</tt></td>
			<td>Записує в консоль відформатований рядок (створений на основі значень строки <tt>fmt</tt> та наданих <tt>args</tt>). Цей метод <tt>printf</tt> такий самий, що й метод <tt>format</tt>: його надано для зручності програмістів на <tt>C/C++</tt>.</td>
		</tr>
		<tr>
			<td><tt>void flush()</tt></td>
			<td>Примушує дані, які залишилися в консольному буфері, бути надрукованими.</td>
		</tr>
	</table>

	<h3>Форматований вивід з класом <tt>Console</tt></h3>

	<p>Клас <tt>Console</tt> підтримує форматований ввід-вивід в методах <tt>printf()</tt> та <tt>format()</tt>, а також у перевантажених методах <tt>readPassword()</tt> та <tt>readLine()</tt>. Розглянемо форматований вивід в методі <tt>printf()</tt> (та схожому методі <tt>format()</tt>), а згодом обговоримо методи <tt>readPassword()</tt> та <tt>readLine()</tt>.</p>

	<p>Метод <tt>printf()</tt> використовує прапорці форматування. Це дуже схоже на функцію <tt>printf()</tt> з бібліотеки мови програмування <tt>C</tt>. Перший параметр методу <tt>printf()</tt> це форматний рядок. Форматний рядок може містити строкові літерали та <em>специфікатори форматування</em>. Актуальні аргументи передаються після форматного рядка. Цей метод може викликати <tt>IllegalFormatException</tt> при наданні неправильного формата.</p>

	<p>Специфікатори формату це наріжний камінь концепції форматування стрічок (рядків). Вони визначають місця для заповнення даними окремого типу та їх формат (такий як вирівнювання та ширина). Інші параметри методу <tt>printf()</tt> це змінні (чи літерали), які надають дані для заповнення у визначеній послідовності.</p>

	<p>Розглянемо детальний приклад того, коли та чому треба фвикористовувати специфікатори форматування. Припустимо, треба надрукувати таблицю футбольних гравців: імена, кількість матчів, забитих голів та середню кількість голів за матч. Однак, існують деякі обмеження:</p>

	<ul>
		<li>Імена мають бути вирівняні ліворуч.</li>
		<li>Принаймні 15 символів відводиться на ім'я.</li>
		<li>Кожен стовпець друкується на відстані табуляції.</li>
		<li>Кількість голів за матч вказується з визначеною точністю.</li>
	</ul>

	<p>Лістинг <a href="#c09l03">9-3</a> показує, як це зробити.</p>

    <pre id="c09l03" class="prettyprint lang-java">
    // Лістинг 9-3. FormattedTable.java
    // Демонструє використання специфікаторів форматування в printf
    import java.io.Console;

    class FormattedTable {
    	void line(Console console) {
    		console.printf("------------------------------------------------------------\n");
    	}

    	void printHeader(Console console) {
    		console.printf("%-15s \t %s \t %s \t %s \n", "Гравець", "Матчі", "Голи", "Голів за матч");
    	}

    	void printRow(Console console, String player, int matches, int goals) {
    		console.printf("%-15s \t %5d \t\t %d \t\t %.1f \n", player, matches, goals, ((float)goals/(float)matches));
    	}

    	public static void main(String[] str) {
    		FormattedTable formattedTable = new FormattedTable();
    		Console console = System.console();
    		if(console != null) {
    			formattedTable.line(console);
    			formattedTable.printHeader(console);
    			formattedTable.line(console);
    			formattedTable.printRow(console, "Demando", 100, 122);
    			formattedTable.printRow(console, "Mushi", 80, 100);
    			formattedTable.printRow(console, "Peale", 150, 180);
    			formattedTable.line(console);
    		}
    	}
    }
    </pre>

	<p>Ця програма робить такий вивід:</p>

    <pre id="outc09l03" class="prettyprint lang-bsh">
    ------------------------------------------------------------
    Гравець              Матчі       Голи    Голів за матч 
    ------------------------------------------------------------
    Demando                100       122         1.2
    Mushi                   80       100         1.3
    Peale                  150       180         1.2
    ------------------------------------------------------------
    </pre>

	<p>Проаналізуємо рядок форматування, наданий методу <tt>printRow()</tt>: "<tt>%-15s \t %5d \t\t %d \t\t %.1f \n</tt>"</p>

	<ul>
		<li>Перша частина рядка форматування це рядок "<tt>%-15s</tt>". Тут вираз починається з <tt>%</tt>, якйий показує початок рядка форматування.</li>
		<li>Наступний символ це '<tt>-</tt>', який використовується для вирівнювання рядка вліво. Число "<tt>15</tt>" вказує ширину рядка, та специфікатор типу даних "<tt>s</tt>" вказує, що тип вхідних даних це <tt>String</tt>.</li>
		<li>Наступний рядок-специфікатор формату це "<tt>%5d</tt>", який визначає, що очікується ціле, яке буде відображене мінімум п'ятьма цифрами.</li>
		<li>Останній рядок-специфікатор формату це "<tt>%.1f</tt>", який очікує число з плаваючою крапкою, яку буде відображене з однією цифрою після крапки.</li>
		<li>Всі рядки-специфікатори формату відокремлені одним чи більше "<tt>\t</tt>" (зупинками табуляції) для створення простору між стовпцями.</li>
	</ul>

	<p>Обговоримо шаблони специфікаторів формату для метода <tt>printf()</tt>:</p>

	<pre>%[argument_index][flags][width][.precision]datatype_specifier</pre>

	<ul>
		<li>Як можна бачити, кожен специфікатор формату починається зі знаку <tt>%</tt>, а закінчується специфікатором типу даних. Аргументи індексу, прапорців, ширини та точності не обов'язкові.</li>
		<li><i>Argument index</i> визначає позицію аргумента в списку аргументів; це ціле з наступним знаком <tt>$</tt>, наприклад, <tt>1$</tt> та <tt>2$</tt> для першого та другого аргументів відповідно.</li>
		<li><i>Flags</i> це один символ, який вказує такі характеристики, як вирівнювання та символ-заповнювач. Наприклад, прапорець "<tt>-</tt>" вказує ліве вирівнювання, а "<tt>0"</tt> доповнює число нулями зліва.</li>
		<li>Специікатор <i>width</i> показує мінімальну кількість символів, яку займатиме відформатований рядок. Якщо вхідні дані коротші за вказану ширину, вони доповнюються по замовчанню пробілами. Якщо вхідні ддані більші за вказану ширину, на виводі показуютья повні дані без обрізки.</li>
		<li><i>precision field</i> (поле точності) вказує кількість цифр точності у виводі. Це не обов'язкове поле корисне для чисел з плаваючою крапкою.</li>
		<li><i>data type specifier</i> показує очікуваний тип вхідних даних. Поле є місцем заповнення для вказаних вхідних даних. Таблиця <a href="#c09t02">9-2</a> містить перелік загально вживаних специфікаторів типів даних.</li>
	</ul>

	<table id="c09t02" border="1" cellpadding="2">
		<caption>Таблиця 9-2. Загально вживані специфікатори типів даних</caption>
		<tr><th>Символ</th><th>Опис</th></tr>
		<tr><td>%b</td><td>Булевий</td></tr>
		<tr><td>%c</td><td>Символ</td></tr>
		<tr><td>%d</td><td>Десятичне ціле (зі знаком)</td></tr>
		<tr><td>%e</td><td>Число з плаваючою крапкою в науковому форматі</td></tr>
		<tr><td>%f</td><td>Число з плаваючою крапкою в десятичному форматі</td></tr>
		<tr><td>%g</td><td>Число з плаваючою крапкою в науковому чи десятичному форматі (в залежності від значення аргумента)</td></tr>
		<tr><td>%h</td><td>Hashcode наданого аргумента</td></tr>
		<tr><td>%n</td><td>Кінець строки (символ нового рядка)</td></tr>
		<tr><td>%o</td><td>Ціле як вісімкове значення</td></tr>
		<tr><td>%s</td><td>String</td></tr>
		<tr><td>%t</td><td>Дата/час</td></tr>
		<tr><td>%x</td><td>Ціле як шістнадцяткове значення</td></tr>
	</table>

	<p>Зауважте, що обговорення <tt>printf()</tt> стосується метода <tt>format()</tt> класу <tt>Console</tt>. Фактично, <tt>printf</tt> просто викликає метод <tt>format</tt>:</p>

    <pre class="prettyprint lang-java">
    // code from java.io.Console.java
    public Console printf(String format, Object ... args) {
    	return format(format, args);
    }
    </pre>

	<h3>Пам'ятка</h3>

	<ul>
		<li>Якщо не надати рядок-специфікатор форматування, метод <tt>printf()</tt> нічого не надрукує!</li>
		<li>Прапорці "<tt>-</tt>" та "<tt>0</tt>" мають сенкс лише при указанні ширини з рядком-специфікатором форматування.</li>
		<li>В рядку форматування можна використовувати символ <tt>%</tt> &ndash; з послідовністю маскування. В рядках-специфікаторах форматування символ маскування це <tt>%</tt>, тож для друку одного <tt>%</tt> треба використовувати <tt>%%</tt>.</li>
		<li>Для посилання на аргументи за їх позицією можна використовувати argument index feature (ціле значення з символом <tt>$</tt>). Наприкад, наступний код надрукує "world hello" оскільки порядок аргументів змінено:
            <pre class="prettyprint lang-java">
            console.printf("%2$s %1$s %n", "hello", "world");
            // $2 refers to the second argument ("world") and
            // $1 refers to the first argument ("hello")
            </pre>
		</li>
		<li>Символ <tt>&lt;</tt> підтримує відносний індекс, за допомогою чого можна ще раз використати аргумент з попереднього специфікатора форматування. Наприклад, наступний фрагмент надрукує "10 a 12 true": <tt id="LT.java">console.printf("%d %&lt;x %&lt;o %&lt;b", 10);</tt>
            <pre id="outLT">
            // "10" – десяткове, "a" – шістнадцяткове значення, а "12" – вісімкове значення 10
            </pre>
		</li>
		<li>Якщо не надати вхідні дані в очікуваному форматі, вказаному в рядку форматування, можна отримати <tt>IllegalFormatConversionException</tt>. Наприклад, якщо надати рядок замість очікуваного цілого в реалізації метода <tt>printRow()</tt>, отримаємо наступний виняток:
            <pre>
            Exception in thread "main" java.util.IllegalFormatConversionException:
            	d != java.lang.String
            </pre>
		</li>
	</ul>

	<h3>Отримання вводу з класом <tt>Console</tt></h3>

	<p>За допомогою перевантажених методів <tt>readPassword()</tt> та <tt>readLine()</tt> класу <tt>Console</tt> можна отримати вхід з консолі. В цих методах перший аргумент це рядок-специфікатор форматування, а нступні аргументи це значення, які будуть передані до рядка-специфікатора форматування. Ці два методи повертають дані, зчитані з консолі. Яка різниця між методами <tt>readLine()</tt> та <tt>readPassword()</tt>? Основна різниця полягає в тому, що <tt>readPassword()</tt> не відображає друкования рядок в консолі (за очевидної причини не відображати секретні паролі), в той час як <tt>readLine()</tt> показує вхід, який друкується в консолі. Інша менш значна різниця полягає в тому, що метод <tt>readLine()</tt> повертає <tt>String</tt>, в той час як <tt>readPassword()</tt> повертає масив <tt>char</tt> (див. лістинг <a href="#c09l04">9-4</a>).</p>

    <pre id="c09l04" class="prettyprint lang-java">
    // Лістинг 9-4. Login.java
    import java.io.Console;
    import java.util.Arrays;

    // код для демонстрації використання метода readPassword
    class Login {
    	public static void main(String []args) {
    		Console console = System.console();
    		if(console != null) {
    			String userName = null;
    			char[] password = null;
    			userName = console.readLine("Введіть ім'я користувача: ");
    			// друковані символи пароля не показиватимуться на екрані
    			password = console.readPassword("Введіть пароль: ");
    			// пароль це char[]: спочатку перетворти в String
    			// для порівняння вмісту
    			if(userName.equals("scrat") && new String(password).equals("nuts")) {
    			 // ім'я користувача та пароль не треба зберігати в коді!
    			 console.printf("Вхід успішний!");
    			}
    			else {
    			 console.printf("Ім'я користувача чи пароль невірні");
    			}
    			// "вивільнити" пароль
    			Arrays.fill(password, ' ');
    		}
    	}
    }
    </pre>

	<p>Приклад виконання програми з правильними реквізитами:</p>

    <pre class="prettyprint lang-bsh">
    $ java Login 
    Введіть ім'я користувача: scrat
    Введіть пароль: 
    Вхід успішний!
    </pre>

	<p>Зауважте, що при друкуванні паролю на екрані нічого не відоражається. Навіщо в програмі оператор <tt>Arrays.fill(password, ' ');</tt>? Це рекомендована практика вивільняти рядок зчитаного пароля по закінченню його використання; для цієї мети використовуєтсья метод  класу <tt>Array</tt> <tt>fill()</tt>. Це практика безпечного програмування для запобігання несанкціонованого читання програмних даних для пошуку рядків паролів. На відміну від метода <tt>readLine()</tt>, який повертає <tt>String</tt>, метод <tt>readPassword()</tt> повертає масив символів. Після перевірки пароля можливо опорожнити його та видалити сліди тексту пароля з пам'яті; з об'єктом <tt>String</tt>, видаленням якого керує збірник сміття, це не так просто зробити, як з масивом символів.</p>

	<h2>Використання потоків для читання та запису файлів</h2>

	<p>Що таке потоки? Потоки це впорядковані послідовності даних. Java працює зі вводом та виводом в термінах потоків. Наприклад, при читанні послідовності байтів з двійкоого файла відбувається читання з <i>вхідного потоку</i>; аналогічно, при записі послідовності байтів в двійковий файл відбувається запис до <i>вихідного потоку</i>. Звернять увагу: читання чи запису <i>байтів</i> з/в <i>двійковий файл</i>, а що з читанням чи записом <i>символів</i> з/в <i>текстовий файл</i>? Java, як й інші мови програмування та операційні системи, розрізняє обробку текста та двійкових даних. Перед зануренням в потоки та читання чи запис даних з файлів треба спочатку зрозуміти різницю між символьними та байтовими потоками - це важливо для розуміння подальшого матеріалу.</p>

	<p><hr/>Потоковий API (розглянуто в Главі 6) запроваджений в Java 8, відрізняється від потоків вводу-виводу, які обговорюються в цій главі.<hr/></p>

	<h3>Символьні та байтові потоки</h3>

	<p>Розглянемо різницю між вихідними файлами з програмами на Java та файлами класів, які генеруються компілятором. Вихідні файли Java мають розширення "<tt>.java</tt>" та можуть бути прочитані людьми та програмними засобами, наприклад компіляторами. Файли класів Java мають розширення "<tt>.class</tt>" та не можуть бути прочитані людиною; вважається, що вони опрацьовуватимуться низько-рівневими інструментами накшталт JVM чи дизасемблером Java.</p>

	<i>Текстові файли містять текст та можуть бути прочитані людиною; двійкові файли читаються машиною.</i>

	<p>Способи, якими інтерпретується вміст текстових та двійкових файлів, різняться.</p>

	<!-- Я опустил абзац лишних для подготовленной аудитории разъяснений -->

	<p>Пакет <tt>java.io</tt> містить класи для підтримки символьних та байтових потоків. Для текстового ввод-виводу використовуються символьні потоки; для байтового - байтові. Символьні потоки для читання та запису називаютсья <i>читачами</i> та <i>письменниками</i> відповідно (представлені абстрактними класами <tt>Reader</tt> та <tt>Writer</tt>). Байтові потоки для читання та запису називаються <i>потоками вводу</i> та <i>потоками виводу</i> відповідно (представлені абстрактними класами <tt>InputStream</tt> та <tt>OutputStream</tt>). В таблиці <a href="#c09t03">9-3</a>підсумковано різницю між символьними та байтовими потоками.</p>

	<table id="c09t03" border="1" cellpadding="2">
		<caption>Таблиця 9-3. Різниця між символьними та байтовими потоками</caption>
		<tr><th>Символьні потоки</th><th>Байтові потоки</th></tr>
		<tr>
			<td>Призначені для операцій читання та запису з такими пристроями символьного чи текстового вводу-виводу, як файли, текстові документи, файли XML та HTML.</td>
			<td>Призначені для операцій читання та запису з такими пристроями двійкового вводу-виводу, як скомпільовані програми, файли зображень, архіви тощо.</td>
		</tr>
		<tr>
			<td>Дані як 16-бітові символи Unicode.</td>
			<td>Дані як байти (8-бітові одиниці даних).</td>
		</tr>
		<tr>
			<td>Символьні потоки вводу та виводу називаються <i>читатчами</i> та <i>письменниками</i> відповідно.</td>
			<td>Байтові потоки вводу та виводу називаютсья просто <i>потоками вводу</i> та <i>потоками виводу</i> відповідно.</td>
		</tr>
		<tr>
			<td>Абстрактні класи <tt>Reader</tt> і <tt>Writer</tt> та їх породжені класи в пакеті <tt>java.io</tt> надають підтримку для символьних потоків.</td>
			<td>Абстрактні класи <tt>InputStream</tt> і <tt>OutputStream</tt> та їх породжені класи в пакеті <tt>java.io</tt> pнадають підтримку для байтових потоків.</td>
		</tr>
	</table>

	<p><hr/>При використанні байтового потока там, де потрібен символьний, та напаки загрожує проблемами. Наприклад, файл из зображенням (<tt>.bmp</tt>) повинен опрацьовуватися байтовим потоком; при використанні символьного потоку програма не працюватиме. Не плутайте потоки!<hr/></p>

	<h3>Символьні потоки</h3>

	<p>Дослідимо ввід-вивід з символьними потоками. Навчимося зчитувати дані з текстових файлів та записувати їх, а також таким опціям, як буферизація для прискорення вводу-виводу. Для операцій читання та запису з текстовими файлами можна використовувати класи, породжені від абстрактних класів <tt>Reader</tt> та <tt>Writer</tt> відповідно. Для символьних потоків на рисунку <a href="#c09f01">9-1</a> показані важливі класи <tt>Reader</tt>, а в таблиці <a href="#c09t04">9-4</a> наведено короткий опис цих класів. Рисунок <a href="#c09f02">9-2</a> показує важливі класи <tt>Writer</tt>, а в таблиці <a href="#C09t05">9-5</a> надано короткий опис цих класів. Зауважте, що далі розглядатимуться лише декілька важливих класів цієї ієрархії.</p>

	<p>
		<img id = "c09f01" src="img/c09f01.png" alt="Рисунок 9-1. Важливі класи, породжені від класу Reader"/><br/>
		Рисунок 9-1. Важливі класи, породжені від класу <tt>Reader</tt>
	</p>

	<p>
		<img id = "c09f02" src="img/c09f02.png" alt="Рисунок 9-2. Важливі класи, породжені від класу Writer"/><br/>
		Рисунок 9-2. Важливі класи, породжені від класу <tt>Writer</tt>
	</p>

	<table id="c09t04" border="1" cellpadding="2">
		<caption>Таблиця 9-4. Важливі класи, породжені від класу <tt>Reader</tt></caption>
		<tr>
			<th>Ім'я класу</th>
			<th>Короткий опис</th>
		</tr>
		<tr>
			<td><tt>StringReader</tt></td>
			<td>Символьний потік для роботи з <tt>string</tt>.</td>
		</tr>
		<tr>
			<td><tt>InputStreamReader</tt></td>
			<td>Місток між символьними та байтовими потоками.</td>
		</tr>
		<tr>
			<td><tt>FileReader</tt></td>
			<td>Нащадок <tt>InputStreamReader</tt> для читання символьних файлів.</td>
		</tr>
		<tr>
			<td><tt>PipedReader</tt></td>
			<td>Класи <tt>PipedReader</tt> та <tt>PipedWriter</tt> утворюють пару для "конвейєрного" читання/запису символів.</td>
		</tr>
		<tr>
			<td><tt>FilterReader</tt></td>
			<td>Абстрактний базовий клас пдітримки операцій фільтрації над даними яки символами, які зчитуються з потоку.</td>
		</tr>
		<tr>
			<td><tt>PushbackReader</tt></td>
			<td>Нащадок <tt>FilterReader</tt>, який дозволяє повертати зчитані символи назад в поік.</td>
		</tr>
		<tr>
			<td><tt>BufferedReader</tt></td>
			<td>Додає буферизацію до базового символьного потоку, в результаті чого зникає потреба мати доступ до файлової системи з кожною операцією читання та запису.</td>
		</tr>
		<tr>
			<td><tt>LineNumberReader</tt></td>
			<td>Нащадок <tt>BufferedReader</tt>, який супроводжує номер рядка при читанні символів з базового символьного потоку.</td>
		</tr>
	</table>

	<table id="c09t05" border="1" cellpadding="2">
		<caption>Таблиця 9-5. Важливі класи, породжені від класу <tt>Writer</tt></caption>
		<tr>
			<th>Ім'я класу</th>
			<th>Короткий опис</th>
		</tr>
		<tr>
			<td><tt>StringWriter</tt></td>
			<td>Символьний потік, який збирає вивід до строкового буферу, який можна використати для створення <tt>string</tt>.</td>
		</tr>
		<tr>
			<td><tt>OutputStreamWriter</tt></td>
			<td>Місток між символьними та байтовими потоками.</td>
		</tr>
		<tr>
			<td><tt>FileWriter</tt></td>
			<td>Нащадок <tt>OutputStreamWriter</tt> для підтримки запису до символьних файлів.</td>
		</tr>
		<tr>
			<td><tt>PipedWriter</tt></td>
			<td>Класи <tt>PipedReader</tt> та <tt>PipedWriter</tt> утворюють пару для "конвейєрного" читання/запису символів в символьний потік.</td>
		</tr>
		<tr>
			<td><tt>FilterWriter</tt></td>
			<td>Абстрактний базовий клас для потоків, який підтримує операцію фільтрації даних як символів при їх записі до символьного потоку.</td>
		</tr>
		<tr>
			<td><tt>PrintWriter</tt></td>
			<td>Підтримує форматований друк символів на сомвольний потік виводу.</td>
		</tr>
		<tr>
			<td><tt>BufferedWriter</tt></td>
			<td>Додає буферизацію базовому символьному потоку,  в результаті чого зникає потреба мати доступ до файлової системи з кожною операцією читання та запису.</td>
		</tr>
	</table>

	<h4>Читання текстових файлів</h4>

	<p>Класи <tt>Reader</tt> читають вміст потоку та намагаються трактувати його як символи. Лістинг <a href="#c09l05">9-5</a> реалізує спрощену версію команди <tt>type</tt> в Windows (чи <tt>cat</tt> в Linux/Unix/Mac). Команда <tt>type</tt> відображає вміст файлів, імена яких надані як аргументи командного рядку.</p>

    <pre id="c09l05" class="prettyprint lang-java">
    // Лістинг 9-5. Type.java
    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.IOException;

    // реалізує спрощену версію команди "type" в Windows, приймаючи
    // імена текстових файлів як аргументи, друкує їх вміст на консолі
    class Type {
    	public static void main(String []files) {
    		if(files.length == 0) {
    			System.err.println("надайте ім'я файла як аргумент");
    			System.exit(-1);
    		}
    		// опрацювати кожен файл
    		for(String file : files) {
    			// спробувати відкрити файл з FileReader
    			try (FileReader inputFile = new FileReader(file)) {
    			 int ch = 0;
    			 // доки є символи для вибірки, зчитати та надрукувати символи
    			 // при досягненні EOF read() поверне -1, завершуючи цикл
    			 while( (ch = inputFile.read()) != -1) {
    				// ch типу int - перед друком перетворити назад в char
    				System.out.print( (char)ch );
    			 }
    			} catch (FileNotFoundException fnfe) {
    			 // файл з наданим ім'ям не знайдений
    			 System.err.printf("Не можливо відкрити файл %s ", file);
    			}
    			catch(IOException ioe) {
    			 // при читанні файла трапилася якась помилка вводу-виводу ...
    			 System.err.printf("Помилка при обробці файла %s... пропускаємо його", file);
    			}
    			// try-with-resources автоматично вивільняє об'єкт FileReader
    		}
    	}
    }
    </pre>

	<p>Приклад роботи програми та системної команди:</p>

    <pre class="prettyprint lang-bsh">
    $ date > date.txt
    $ cat date.txt
    Вто апр 21 14:15:21 EEST 2020

    $ javac Type.java
    $ java Type
    Вто апр 21 14:15:21 EEST 2020
    </pre>

	<p>В програмі створюється об'єкт класу <tt>FileReader</tt>, та йому передається ім'я файла для відкриття. Якщо файл не знайдено, конструктор <tt>FileReader</tt> викличе <tt>FileNotFoundException</tt>.</p>

	<p>Після відкриття файла використовується метод <tt>read()</tt> для вибірки з нього символів - одного за одним. А можна використати такі методи як <tt>readLine()</tt> для читання рядка за рядком.</p>

	<p>Зауважте, що метод <tt>read()</tt> повертає <tt>int</tt> замість <tt>char</tt>, це тому, що при досягненні методом <tt>read()</tt> End-Of-File (<tt>EOF</tt>), він повертаж <tt>-1</tt>, який поза межами значень для типу <tt>char</tt>. Отже метод <tt>read()</tt> повертає <tt>int</tt> для вказівки на досягнення кінця файла, тож варто припинити подальші спроби читання символів.</p>

	<p>Доки ми читали текстовий файл; зараз спробуємо ще й записати в текстовий файл.</p>

	<h4>Операції читання та запису з текстовими файлами</h4>

	<p>В попередньому прикладі (лістинг <a href="#c09l05">9-5</a>) читання з текстового файла, було створено символьний потік:</p>

	<pre class="prettyprint lang-java">FileReader inputFile = new FileReader(file);</pre>

	<p>Він використовує небуферизований ввід-вивід, який менш ефективний у порівнянні з буферизованим вводом-виводом. Інакше кажучи, зчитані символи безпосередньо передаються в тимчасовий (внутрішній) буфер, що може прискорити ввід-вивід. Для програмного використання буферизованого вводу-виводу треба передати посилання на <tt>FileReader</tt> в об'єкт <tt>BufferedReader</tt>:</p>

	<pre class="prettyprint lang-java">BufferedReader inputFile = new BufferedReader(new FileReader(file));</pre>

	<p>В такий самий спосіб можна використовувати <tt>BufferedWriter</tt> для буферизованого виводу. Для байтових потоків вкористовуйте <tt>BufferedInputStream</tt> та <tt>BufferedOutputStream</tt>, які будуть розглянуті пізніше.</p>

	<p>Використаємо буферизований ввід-вивід для читання текстового файла та запису до текстового файла. Лістинг <a href="#c09l06">9-6</a> містить спрощену версію команди <tt>copy</tt> в Windows.</p>

    <pre id="c09l06" class="prettyprint lang-java">
    // Лістинг 9-6. Copy.java
    import java.io.BufferedReader;
    import java.io.BufferedWriter;
    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.FileWriter;
    import java.io.IOException;

    // реалізує спрощену версію команди "copy" Windows
    // синтаксис: java Copy SrcFile DstFile
    // копіює ScrFile в DstFile; перезаписує вже існуючий DstFile

    class Copy {
    	public static void main(String []files) {
    		if(files.length != 2) {
    			System.err.println("Помилка синтаксису. Правильно: Copy SrcFile DstFile");
    			System.exit(-1);
    		}
    		String srcFile = files[0];
    		String dstFile = files[1];
    		// спробувати відкрити вихідний та кінцевий файли за допомогою
    		// FileReader та FileWriter
    		try (BufferedReader inputFile = new BufferedReader(new FileReader(srcFile));
    		BufferedWriter outputFile = new BufferedWriter(new FileWriter(dstFile))) {
    			int ch = 0;
    			// доки є символи для вибірки зчитати символи з вихідного потоку
    			// та записати їх до потоку призначення
    			while( (ch = inputFile.read()) != -1) {
    			 // ch належить типу int - перетворити його назад в char перед записом
    			 outputFile.write( (char)ch );
    			}
    		// викликати явно flush для outputFile немає потреби - метод close()
    		// спочатку викличе flush перед закриттям потоку outputFile
    		} catch (FileNotFoundException fnfe) {
    			// файл з наданим ім'ям не знайдено ...
    			System.err.println("Не можливо відкрити файл " + fnfe.getMessage());
    		}
    		catch(IOException ioe) {
    			// при читанні файла трапилася якася помилка вводу-виводу ...
    			System.err.printf("Помилка при обробці файла; вихід ... ");
    		}
    		// try-with-resources автоматично вивільнить об'єкт FileReader
    	}
    }
    </pre>

	<p>Спочатку поглянемо на те, як працює програма. Скопіюємо цей вихідний файл з кодом Java (<tt>Copy.java</tt>) в інший файл (<tt>DuplicateCopy.java</tt>). Можна використати команду <tt>fc</tt> (file compare) в Windows (чи <tt>diff</tt> в Linux/Unix/Mac) для того, щоб впевнитися в тому, що вміст оригінального та скопійованого файлів однаковий, а значить, програма працює коректно.</p>

    <pre class="prettyprint lang-bsh">
    $ java Copy Copy.java DuplicateCopy.java
    $ diff -s Copy.java DuplicateCopy.java 
    Files Copy.java and DuplicateCopy.java are identical
    </pre>

    	<p>Так, вона працює правильно. А якщо надати ім'я не існуючого вихілного файла?</p>

    <pre class="prettyprint lang-bsh">
    $ java Copy Cpy.java DuplicateCopy.java
    Не можливо відкрити файл Cpy.java (No such file or directory)
    </pre>

    	<p>При отриманні <tt>Cpy.java</tt> замість <tt>Copy.java</tt> програма завершується з читабельним повідомленням, як і очікувалося.</p>

    	<p>Поглянемо, як працює програма. В операторі try-with-resources відкриваєтсья <tt>srcFile</tt> для читання та <tt>dstFile</tt> для запису. Бажаємо використовувати буферезований ввід-вивід, тож надаємо посилання на <tt>FileReader</tt> та <tt>FileWriter</tt> до <tt>BufferedReader</tt> та <tt>BufferedWriter</tt> відповідно.</p>

    <pre class="prettyprint lang-java">
    try (BufferedReader inputFile = new BufferedReader(new FileReader(srcFile));
    		BufferedWriter outputFile = new BufferedWriter(new FileWriter(dstFile)))
    </pre>

	<p>Використовується оператор try-with-resources (розглянутий в Главі 7), метод <tt>close()</tt> класу <tt>BufferedWriter</tt> спочатку викличе метод <tt>flush()</tt> перед закриттям потоку.</p>

	<p><hr/>При використанні буферизованого вводу-виводу явний виклик методу <tt>flush()</tt> в місцях, де потрібна гарантія того, що всі відкладені символи чи дані збережені в базовому файлі, є хорошою практикою.<hr/></p>

	<h4>"Токенізація" тексту</h4>

	<p>В останніх двох прикладах (лістинги <a href="#c09l05">9-5</a> та <a href="#c09l06">9-6</a>), проводилися операції читання та запису з текстовими файлами. В реальних програмах може знадобитися якась обробка при читанні чи записі файлів. Наприклад, може знадобитися пошукати якісь шаблони, знайти певний рядок, замінити одну послідовність символів іншою, відфільтрувати окремі слова чи відформатувати вивід певним чином. Для цього можна використовувати існуючі API (регулярні вирази, наприклад) та <tt>Scanner</tt>.</p>

	<p>Для ілюстрації припустимо, що треба перелічити всі слова з наданого файла та вилучити всі небажані пробільні символи, знаки пунктуації і таке інше. Також треба надрукувати отримані слова в алфавітному порядку. Для вирішення цієї задачі можна використати <tt>Scanner</tt> та передати регулярний вираз, за яким встановлювати, чи підходить символ (див. лістинг <a href="#c09l07">9-7</a>).</p>

    <pre id="c09l07" class="prettyprint lang-java">
    // Listing 9-7. Tokenize.java
    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.util.Scanner;
    import java.util.Set;
    import java.util.TreeSet;

    // зчитати файл вводу та перетворити його в елементи слів;
    // перетворити слова до одного регістру (нижнього), видалити дублікати та надрукувати слова

    class Tokenize {
    	public static void main(String []args) {
    		// зчитати файл вводу
    		if(args.length != 1) {
    			System.err.println("надайте як аргумент ім'я файла, який треба зчитати");
    			System.exit(-1);
    		}
    		String fileName = args[0];
    		// використання TreeSet&lt;String&gt;, який автоматично відсортує слова
    		// в алфавітному порядку
    		Set&lt;String&gt; words = new TreeSet&lt;&gt;();
    		try ( Scanner tokenizingScanner = new Scanner(new FileReader(fileName)) ) {
    			// встановити відокремлення для тексту як "не-слова" (спеціальні символи,
    			// пробільні символи), для того, щоб повернулися всі інші слова, які не є
    			// символами пунктуації, пробільними символами
    			tokenizingScanner.useDelimiter("\\s");
    			while(tokenizingScanner.hasNext()) {
    			 String word = tokenizingScanner.next();
    			 if(!word.equals("")) { // обробляти лише не-порожні рядки
    				// перетворити до нижнього регістру та додати до набору
    				words.add(word.toLowerCase());
    			 }
    			}
    			// тепер слова в алфавітному порядку без дублікатів,
    			// надрукуємо слова, розділяючи їх табуляцією
    			for(String word : words) {
    			 System.out.print(word + ' ');
    			}
    		} catch (FileNotFoundException fnfe) {
    			System.err.println("Не можливо зчитати файл вводу - надайте правильне ім'я файла");
    		}
    	}
    }
    </pre>

	<p>Результат виконання:</p>

    <pre class="prettyprint lang-bsh">
    $ cat limerick.txt
    Депутат фолькетинга із Данії
    Знаторів в каббалі та гаданні
    та друзякам з парламенту
    По сторінках регламенту
    Пророкує бюджетні бодання.

    $ java Tokenize limerick.txt 
    бодання	бюджетні	в	гаданні	данії	депутат	друзякам	з	знаторів	каббалі	парламенту	по	пророкує	регламенту	сторінках	та	фолькетинга	із
    </pre>

	<p>Так, все працює вірно. Розберемося з тим, як саме програма працює. Спочатку програма за допомогою <tt>FileReader</tt> відкриває файл та передає його в об'єкт <tt>Scanner</tt>. Програма встановлючє відокремлювачі для <tt>Scanner</tt> використовуючи <tt>useDelimiter("[\\s\\.]");</tt>. Зверніть увагу на те, що встановлюється саме відокремлювач. Програма використовує <tt>TreeSet&lt;String&gt;</tt> для зберігання зчитаних рядків. Програма зчитує слова з потоку, перевіряє, чи не пустий рядок та додає слово в нижньому регістрі до <tt>TreeSet</tt>. Ця структура даних <tt>TreeSet</tt> видаляє дублікати (<tt>TreeSet</tt> це <tt>Set</tt>, який не припускає дублікатів). Більш за те, це також впорядкована структура даних, що означає, що вона виконує впорядкування значень, які додаються, в алфавітному порядку для <tt>Strings</tt>. Отже програма правильно друкує слова з наданого текстового файла з лімеріком.</p>

	<h3>Байтові потоки</h3>

	<p>Тепер дослідимо байтові потоки. Спочатку навчимося операціям читання та запису для файлів даних, також передачі об'єктів в потоки, зберіганню їх в файлах та наступному зчитуванню. Клас <tt>OutputStream</tt> та його нащадки зображені на рисунку <a href="#c09f03">9-3</a>; <tt>InputStream</tt> та його нащадки зображено на рисунку <a href="#c09f04">9-4</a>.</p>

	<p><img id="c09f03" src="img/c09f03.png" alt="Рисунок 9-3. Важливі класи нащадки абстрактного класа OutputStream"/><br/>
	Рисунок 9-4. Важливі класи нащадки абстрактного класа <tt>OutputStream</tt></p>

	<p><img id="c09f04" alt="Рисунок 9-4. Важливі класи нащадки абстрактного класа InputStream" src="img/c09f04.png"/><br/>
	Рисунок 9-4. Важливі класи нащадки абстрактного класа <tt>InputStream</tt></p>

	<p>В таблиці <a href="#c09t06">9-6</a> підсумковано відомості про важливі класи <tt>InputStream</tt> та <tt>OutputStream</tt>.</p>

	<table id="c09t06" border="1" cellpadding="2">
		<caption>Таблиця 9-6. Важливі класи нащадки <tt>InputStream</tt> та <tt>OutputStream</tt></caption>
		<tr><th>Ім'я класи</th><th>Короткий опис</th></tr>
		<tr>
			<td><tt>PipedInputStream, PipedOutputStream</tt></td>
			<td><tt>PipedInputStream</tt> та <tt>PipedOutputStream</tt> створюють комунікаційний канал, в якому можна посилати та отримувати дані. <tt>PipedOutputStream</tt> відправляє дані <tt>PipedInputStream</tt> отримує дані, надіслані в канал.</td>
		</tr>
		<tr>
			<td><tt>FileInputStream, FileOutputStream</tt></td>
			<td><tt>FileInputStream</tt> отримує байтовий потік з файлу, <tt>FileOutputStream</tt> записує байтовий потік в файл.</td>
		</tr>
		<tr>
			<td><tt>FilterInputStream, FilterOutputStream</tt></td>
			<td>Ці отфільтровані потоки використовуються для додавання функціональності до пласких потоків. Вивід <tt>InputStream</tt> можна відфільтрувати за допомогою <tt>FilterInputStream</tt>. Вивід <tt>OutputStream</tt> можна відфільтрувати за допомогою <tt>FilterOutputStream</tt>.</td>
		</tr>
		<tr>
			<td><tt>BufferedInputStream, BufferedOutputStream</tt></td>
			<td><tt>BufferedInputStream</tt> додає можливості буферизації до потоку вводу. <tt>BufferedOutputStream</tt> додає можливості буферизації до потоку виводу.</td>
		</tr>
		<tr>
			<td><tt>PushbackInputStream</tt></td>
			<td>Підклас <tt>FilterInputStream</tt>, додає можливості повернення даних до потоку вводу.</td>
		</tr>
		<tr>
			<td><tt>DataInputStream, DataOutputStream</tt></td>
			<td><tt>DataInputStream</tt> можна використовувати для читання примітивних типів Java з потоку вводу. <tt>DataOutputStream</tt> можна використовувати для запису примітивних типів даних Java до потоку виводу.</td>
		</tr>
	</table>

	<h4>Читання байтового потоку</h4>

	<p>Байтові потоки використовуються для обробки файлів, чкі не містять тексту для читання людиною.</p>
	<!-- For example, a Java source file has human-readable content, but a "<tt>.class</tt>" file does not. A "<tt>.class</tt>" file is meant for processing by the JVM, hence you must use byte streams to process the "<tt>.class</tt>" file.</p>
	<p>The contents of a "<tt>.class</tt>" file are written in a specific file format, described in the specification of the Java Virtual Machine (JVM). Don’t worry; you’re not going to understand this complex file format, but you’ll just check its “magic number.” Each file format has a magic number used to quickly check the file format. For example “<tt>.MZ</tt>” is the magic number (or more properly, magic string) for <tt>.exe</tt> files in Windows. Similarly, the "<tt>.class</tt>" files have the magic number "<tt>0xCAFEBABE</tt>", written as a hexadecimal value. These magic numbers are typically written as first few bytes of a variable length file format.</p>
-->

	<p>Для розуміння того, як працюють байтові потоки, перевіримо, на прикладі файлів з байт-кодом класів Java, чи починається наданий файл з магічної послідовності "<tt>0xCAFEBABE</tt>" (лістинг <a href="#c09l08">9-8</a>). Якщо так, то це валідний файл "<tt>.class</tt>".</p>

    <pre id="c09l08" class="prettyprint lang-java">
    // Лістинг 9-8. ClassFileMagicNumberChecker.java
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.util.Arrays;

    // перевірити, чи є наданий файл валідним файлом .class.
    // це елементарна версія перевірки
    // вона перевіряє лише "магічне число"

    class ClassFileMagicNumberChecker {
    	public static void main(String []args) {
    		if(args.length != 1) {
    			System.err.println("Надайте як аргумент ім'я файла");
    			System.exit(-1);
    		}
    		String fileName = args[0];
    		// створити байтовий масив magicNumber із значеннями чотирьох байтів 0xCAFEBABE
    		// треба робити явне перетворення в byte оскільки
    		// шістнадцяткове значення 0xCA типу int
    		byte []magicNumber = {(byte) 0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE};
    		try (FileInputStream fis = new FileInputStream(fileName)) {
    			// магічне число - чотири байти
    			// використовуємо тимчасовий буфер для читання перших чотирьох байтів
    			byte[] u4buffer = new byte[4];
    			// зчитуємо повний (4 байти) масив даних з файла
    			if(fis.read(u4buffer) != -1) { // якщо читання вдале
    			 // перевантажений метод equals для двох байтових масивів
    			 // перевіряє тотожність вмісту
    			 if(Arrays.equals(magicNumber, u4buffer)) {
    				System.out.printf("Магічне число для наданого файла %s відповідає файлу .class", fileName);
    			 } else {
    				System.out.printf("Магічне число для наданого файла %s не відповідає файлу .class", fileName);
    			 }
    			}
    		} catch(FileNotFoundException fnfe) {
    			System.err.println("не існує файла з наданим ім'ям ");
    		} catch(IOException ioe) {
    			System.err.println("трапилася помилка вводу-виводу при обробці файла");
    		}
    	}
    }
    </pre>

	<p>Перевіримо роботу, надавши ім'я файла з вихідним кодом (<tt>.java</tt>) та ім'я файла "<tt>.class</tt>" цій програмі.</p>

	<pre class="prettyprint lang-bsh">
$ java ClassFileMagicNumberChecker ClassFileMagicNumberChecker.java 
Магічне число для наданого файла ClassFileMagicNumberChecker.java не відповідає файлу .class

$ java ClassFileMagicNumberChecker ClassFileMagicNumberChecker.class
Магічне число для наданого файла ClassFileMagicNumberChecker.class відповідає файлу .class
	</pre>

	<p>Працює. Класи <tt>InputStream</tt> та <tt>OutputStream</tt> утворюють базу ієрархії для байтових потоків. Для виконання файлового вводу-виводу треба відкривати наданий файл як <tt>FileInputStream</tt>. Треба перевірити перші чотири байти, тож зчитуються чотири байти в тимчасовий буфер. Треба порівняти вміст цього буфера з послідовністю байтів <tt>0xCA</tt>, <tt>0xFE</tt>, <tt>0xBA</tt> та <tt>0xBE</tt>. Якщо вміст цих двох масивів не однаковий, тоді наданий файл не є файлом "<tt>.class</tt>".</p>

	<p>В програмі відбувається пряме маніпулювання базовим байтовим потоком з використанням <tt>FileInputStream</tt>. Для прискорення програми для читання великої кількості байтів можна використовувати буферизований байтовий потік вводу:</p>

	<pre class="prettyprint lang-java">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName));</pre>

	<p>Подібно до цих потоків вводу можна використовувати потоки виводу для запису послідовності байтів в файл даних. Для цього можна використовувати <tt>FileOutputStream</tt> та <tt>BufferedOutputStream</tt>.</p>

	<p>Після знайомства з кодом читання масиву з чотирьох байтів та порівняння вмісту двох масивів може здаватися дивним (замість прямого порівняння цілих). Інакше кажучи, <tt>0xCAFEBABE</tt> це ціле значення, його можна зчитати безпосередньо як ціле значення та порівняти з іншим цілим значенням. Для цього потрібно використовувати потоки даних, які пропонують такі методи як <tt>readInt()</tt>, про що зараз й поговоримо.</p>

	<h4>Потоки даних</h4>

	<p>Для розуміння того, як читати та записувати байтові потоки, розглянемо невеличку програму, яка записує, а потім зчитує постійні значення до файлу даних (див. лістинг <a href="#c09l09">9-9</a>). Для спрощення писатимемо тільки значення від <tt>0</tt> до <tt>9</tt> в формі значень наступнх примітивних типів: <tt>byte</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, <tt>float</tt> та <tt>double</tt>.</p>

    <pre id="c09l09" class="prettyprint lang-java">
    // Listing 9-9. DataStreamExample.java
    import java.io.DataInputStream;
    import java.io.DataOutputStream;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;

    // Простий клас для ілюстрації потоків даних; write constants 0 and 1 in different
    // data type values into a file and read the results back and print them

    class DataStreamExample {
    	public static void main(String []args) {
    		// записати дані в файл "temp.data"
    		try (DataOutputStream dos =
    			 new DataOutputStream(new FileOutputStream("temp.data"))) {
    			// записати значення від 1 до 10 як byte, short, int, long, float та double
    			for(int i = 0; i < 10; i++) {
    			 dos.writeByte(i);
    			 dos.writeShort(i);
    			 dos.writeInt(i);
    			 dos.writeLong(i);
    			 dos.writeFloat(i);
    			 dos.writeDouble(i);
    			}
    		} catch(FileNotFoundException fnfe) {
    			System.err.println("не можливо створити файл з наданим ім'ям ");
    			System.exit(-1);
    		} catch(IOException ioe) {
    			System.err.println("трапилася помилка вводу-виводу при обробці файла");
    			System.exit(-1);
    		}
    		// DataOutputStream автоматично закриється
    		// зчитати записані дані та надрукувати їх в консоль
    		try (DataInputStream dis = new DataInputStream(new FileInputStream("temp.data"))) {
    			// порядок значень для читання: byte, short, int, long, float та double
    			for(int i = 0; i < 10; i++) {
    			 // %d для друку byte, short, int чи long
    			 // %f, %g, or %e для друку float чи double
    			 System.out.printf("%d %d %d %d %g %g %n",
    					 dis.readByte(),
    					 dis.readShort(),
    					 dis.readInt(),
    					 dis.readLong(),
    					 dis.readFloat(),
    					 dis.readDouble());
    			}
    		} catch(FileNotFoundException fnfe) {
    			System.err.println("не можливо створити файл з наданим ім'ям ");
    		} catch(IOException ioe) {
    			System.err.println("трапилася помилка вводу-виводу при обробці файла");
    		}
    	}
    }
    </pre>

    	<p>Вивід програми:</p>

    <pre class="prettyprint lang-bsh">
    $ java DataStreamExample 
    0 0 0 0 0.00000 0.00000 
    1 1 1 1 1.00000 1.00000 
    2 2 2 2 2.00000 2.00000 
    3 3 3 3 3.00000 3.00000 
    4 4 4 4 4.00000 4.00000 
    5 5 5 5 5.00000 5.00000 
    6 6 6 6 6.00000 6.00000 
    7 7 7 7 7.00000 7.00000 
    8 8 8 8 8.00000 8.00000 
    9 9 9 9 9.00000 9.00000 
    </pre>

	<p>Програма працює. Тепер, як було зазначено раніше, вміст файла з даними не читабельний для людини. Ми записували значення від <tt>0</tt> до <tt>9</tt> як значення примітивних типів в файл <tt>temp.data</tt>. Якщо спробувати відкрити цей файл даних та подивитися на його вміст, не можна буде його зрозуміти. Приклад вмісту файла:</p>

    <pre class="prettyprint lang-bsh">$ cat temp.data 
    ?�?�@@@@@�@@�@@�@A@ 				A@
    </pre>

	<p>Вміст файла <tt>temp.data</tt> виглядає як сміття оскільки значення примітивних типів такі як цілі значення <tt>0</tt> чи <tt>9</tt> зберігаються в термінах байтів. А команда <tt>type</tt> (в Windows) чи <tt>cat</tt> (в Linux/Unix/Mac) намагається перетворити ці байти в читабельні людиною символи, тому вивід виглядає безглуздим. Дані матимуть сенс лише якщо при читанні відомий їх формат зберігання в файлі.</p>

	<p>Подивимось на те, як працює програма. Програма записує в файл даних з жортко запрограмованим ім'ям <tt>temp.data</tt> в поточному каталозі. Спочатку вона записує дані, для чого відкриває файл як потік виводу. Що означає наступний оператор в вершому блоці <tt>try</tt>?</p>

	<pre class="prettyprint lang-java">DataOutputStream dos = new DataOutputStream(new FileOutputStream("temp.data"))</pre>

	<p>З <tt>OutputStream</tt> та його нащадком <tt>FileOutputStream</tt> можна виконувати прямий двійковий ввід-вивід, але для обробки таких форматів даних, як значення примітивних типів, потрібен <tt>DataOutputStream</tt>, який діє як обгортка над <tt>FileOutputStream</tt>.Тож, ми використовуємо <tt>DataOutputStream</tt>, який пропонує такі методи як <tt>writeByte</tt> та <tt>writeShort</tt>. Ці методи використовуються для запису в файл даних значень примітивних типів від <tt>0</tt> до <tt>9</tt>. Зверніть увагу на те, що не потрібно закривати потоки явно, оскільки <tt>DataOutputStream</tt> був відкритий всередині оператора try-with-resources, отже метод <tt>close()</tt> на об'єкті <tt>dos</tt> буде викликаний автоматично. Метод <tt>close()</tt> також освіжає (flushes) базовий потік; також метод <tt>close()</tt> закриє базове посилання на <tt>FileOutputStream</tt>.</p>

	<p>Після того, як файл записаний, аналогічно проводиться читання файла. Відкривається <tt>FileInputStream</tt>, він обгортається в <tt>DataInputStream</tt>. Зчитуються дані з потоку та друкуються в консолі. Використовуються такі специфікатори як <tt>%d</tt> (загальний специфікатор форматування для друку таких цілих значень, як <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> чи <tt>long</tt>), а також специфікатори <tt>%f</tt>, <tt>%g</tt> чи <tt>%e</tt> для друку значень з плаваючою крапкою <tt>float</tt> чи <tt>double</tt>; <tt>%n</tt> для друку символу нового рядка.</p>

	<p>В цій програмі записуються та зчитуються значення примітивних типів. А що до об'єктів таких посилальних типів, як <tt>Object</tt>, <tt>Map</tt> і таке інше? Читання та запис об'єктів виконується через об'єктні потоки, про що й поговримо зараз.</p>

	<h4>Операції читання та запису з об'єктними потоками</h4>

	<p>Припустимо, що необбхідно створити сайт онлайн-магазину. Можна вирішити зберігати дані, які містяться в таких об'єктах як клієнти та зроблені замовлення, в РСУБД (про JDBC поговоримо в Главі 12). Навпаки, замість збереження даних в РСУБД можна зберігати об'єкти безпосередньо в пласких файлах: в такому разі треба знати, як зчитувати та записувати об'єкти в потоки. Класи <tt>ObjectInputStream</tt> та <tt>ObjectOutputStream</tt> підтримують читання та запис об'єктів Java.</p>

	<p>Лістинг <a href="#c09l10">9-10</a> містить простий приклад запису змісту структури даних <tt>Map</tt> в файл та його читання. Це ілюструю використання класів <tt>ObjectInputStream</tt> та <tt>ObjectOutputStream</tt> для роботи з об'єктами. Ми зберігаємо деталі про трьох останніх президентів США в цій карті.</p>

    <pre id="c09l10" class="prettyprint lang-java">
    // Лістинг 9-10. ObjectStreamExample.java
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.FileOutputStream;
    import java.io.IOException;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.util.HashMap;
    import java.util.Map;

    // Простий клас для демонстрації об'єктних потоків: заповнити структуру даних
    // записати її у тимчасовий файл
    // зчитати та надрукувати

    class ObjectStreamExample {
    	public static void main(String []args) {
    		Map&lt;String, String&gt; presidentsOfUS = new HashMap&lt;&gt;();
    		presidentsOfUS.put("Barack Obama", "2009 to --, Democratic Party, 56th term");
    		presidentsOfUS.put("George W. Bush", "2001 to 2009, Republican Party, 54th and 55th terms");
    		presidentsOfUS.put("Bill Clinton", "1993 to 2001, Democratic Party, 52nd and 53rd terms");
    		try (ObjectOutputStream oos =
    			 new ObjectOutputStream(new FileOutputStream("object.data"))) {
    			oos.writeObject(presidentsOfUS);
    		} catch(FileNotFoundException fnfe) {
    			System.err.println("cannot create a file with the given file name ");
    		} catch(IOException ioe) {
    			System.err.println("an I/O error occurred while processing the file");
    		} // the ObjectOutputStream will auto-close, so don't have to worry about it
    		try (ObjectInputStream ois =
    			 new ObjectInputStream(new FileInputStream("object.data"))) {
    			Object obj = ois.readObject();
    			// first check if obj is of type Map
    			if(obj != null && obj instanceof Map) {
    			 Map<?, ?> presidents = (Map<?, ?>) obj;
    			 System.out.println("President name \t Description");
    			 for(Map.Entry<?, ?> president : presidents.entrySet()) {
    				System.out.printf("%s \t %s %n", president.getKey(), president.getValue());
    			 }
    			}
    		} catch(FileNotFoundException fnfe) {
    			System.err.println("cannot create a file with the given file name ");
    		} catch(IOException ioe) {
    			System.err.println("an I/O error occurred while processing the file");
    		} catch(ClassNotFoundException cnfe) {
    			System.err.println("cannot recognize the class of the object - is the file corrupted?");
    		}
    	}
    }
        </pre>
    <p>Програма надрукує:</p>
    <pre class="prettyprint lang-bsh">
    $ java ObjectStreamExample 
    President name   Description
    Barack Obama	2009 to --, Democratic Party, 56th term 
    George W. Bush   2001 to 2009, Republican Party, 54th and 55th terms 
    Bill Clinton	1993 to 2001, Democratic Party, 52nd and 53rd terms 
    </pre>

	<p>Процес серіалізації перетворює вміст об'єктів в пам'яті разом з описом цього вмісту (відомий як мета-дані). Коли об'єкт має посилання на інший об'єкт, механізм серіалізації акож включає його як частину байтів, що серіалізуються. Якщо спробувати відкрити та прочитати файл зі збереженим у такій спосіб об'єктом, цей серіалізований об'єкт не можна буде зрозуміти. Наприклад, якщо спробувати зчитати файл <tt>object.data</tt>, можна побачити купу нечитабельних символів.</p>

	<p>Подивимось, як працює програма. Контейнер <tt>HashMap</tt> заповнюється деталями про трьох президентів США. Потім відкриваєтся потік виводу:</p>

	<pre>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.data"))</pre>

	<p><tt>FileOutputStream</tt> відкриває тимчасовий файл <tt>object.data</tt> в поточному каталозі. <tt>ObjectOutputStream</tt> це обгортка базового <tt>FileOutputStream</tt>. Всередині цього блоку try-with-resources лише один оператор <tt>oos.writeObject(presidentsOfUS)</tt>, який записує об'єкт в файл <tt>object.data</tt>.</p>

	<p>Читання об'єкту потребує тохи більше роботи. Метод <tt>readObject()</tt> в <tt>ObjectInputStream</tt> повертає тип <tt>Object</tt>. Треба перетворити його назад в <tt>Map&lt;String, String&gt;</tt>. Перед його приведенням до цього окремого типу ми перевіряємо, чи належить <tt>obj</tt> типу <tt>Map</tt>. Зауважте, щ не треба перевіряти його належність до <tt>Map&lt;String, String&gt;</tt>, оскільки ці узагальнені типи губляться в процесі, який відомий як <i>знищення типів</i>. Отже ми використовуємо символи маски для параметрів узагальнених типів: <tt>Map&lt;?, ?&gt; presidents = (Map&lt;?, ?&gt;) obj</tt>. Після успішного приведення типу можна зчитати зміст в цей об'єкт. Дивись обговорення знищення типів та символів маски в Главі 4 "Узагальнення та колекції".</p>

	<h2>Пам'ятка</h2>

	<ul>
		<li>При використання буферизованих потоків треба викликати <tt>flush()</tt> по закінченню передачі даних. При цьому будуть передані по призначенню дані, які могли зберігатися у внутрішньому буфері. Метод <tt>close()</tt> на потоці автоматично викликає <tt>flush()</tt>.</li>
		<li>Можна комбінувати потокові об'єкти. Можна створити об'єкт <tt>BufferedInputStream</tt>, який приймає об'єкт <tt>FileInputStream</tt>. В такий спосіб вивід одного потоку приєднується до потоку, що фільтрується. Це важливий, корисний та чудовий шлях налаштовувати потік у бажаний спосіб.</li>
		<li>Якщо треба налаштувати процес серіалізації, можна реалізувати <tt>readObject()</tt> та <tt>writeObject()</tt>. Зауважте, що обидва методи приватні, що означає, що їх не можна перевантажити чи перевизначити. JVM перевіряє імплементацію цих методів та викликає їх замість звичайних методів. Це виглядає дивно, але саме так реалізовано налаштування процеса серіалізації в JVM.</li>
	</ul>

	<h2>Підсумки</h2>

	<ul>
		<li>
			<b>Операції читання та запису в консолі</b>
			<ul>
			 <li>Публчні статичні поля <tt>in</tt>, <tt>out</tt> та <tt>err</tt> в класі <tt>java.lang.System</tt> представляють стандартні потоки вводу, виводу та помилок відповідно. <tt>System.in</tt> належить типу <tt>java.io.InputStream</tt>,а <tt>System.out</tt> та <tt>System.err</tt> типу <tt>java.io.PrintStream</tt>.</li>
			 <li>Можна перенаправити стандартні потоки, викликавши методи <tt>System.setIn</tt>, <tt>System.setOut</tt> та <tt>System.setError</tt>.</li>
			 <li>Можна отримати посилання на консоль завдяки методу <tt>System.console()</tt>; якщо JVM не асоційована з жодною консоллю, цей метод поверне <tt>null</tt>.</li>
			 <li>В <tt>Console</tt> існує багато методів для підтримки форматованого вводу-виводу. Можна використовувати методи <tt>printf()</tt> та <tt>format()</tt> класу <tt>Console</tt> для друку форматованого тексту; перевантажені методи <tt>readLine()</tt> та <tt>readPassword()</tt> приймають рядки форматування як аргументи.</li>
			 <li>Шаблон специфікаторів форматування: <tt>%[flags][width][.precision]datatype_specifier</tt>. Кожен специфікатор форматування починається зі знаку <tt>%</tt>, потім йдуть прапорці, інформація про ширину та точність, а закінчується він специфікатором типу даних. В рядку форматування прапорці, інформація про ширину та точність не обов'язкові, але знак <tt>%</tt> та специфікатор типа даних обов'язкові.</li>
			 <li>Використовуйт метод <tt>readPassword()</tt>для читання таких секретних рядків як паролі. Рекомендується використовувати метод <tt>fill()</tt> класів <tt>Array</tt> для вивільнення паролів, зчитаних в символьний масив (для запобігання несанкціонованого доступу до них).</li>
			</ul>
		</li>
		<li>
			<b>Використовуйте <tt>BufferedReader</tt>, <tt>BufferedWriter</tt>, <tt>File</tt>, <tt>FileReader</tt>, <tt>FileWriter</tt>, <tt>FileInputStream</tt>, <tt>FileOutputStream</tt>, <tt>ObjectOutputStream</tt>, <tt>ObjectInputStream</tt> та <tt>PrintWriter</tt> в пакеті <tt>java.io</tt> package</b>
			<ul>
			 <li>Пакет <tt>java.io</tt> містить класи для супроводу як символьних так і байтових потоків.</li>
			 <li>Для текстового вводу-виводу можна використовувати символьній потоки. Байтові - для вводу-виводу даних.</li>
			 <li>Символьні потоки для читання та запису називаютсья читачами та письменниками (представлені абстрактними класами <tt>Reader</tt> та <tt>Writer</tt>).</li>
			 <li>Байтові потоки для читання та запису називаются потоками вводу та потоками виводу відповідно (представлені абстрактними класами <tt>InputStream</tt> та <tt>OutputStream</tt>).</li>
			 <li>Символьні потоки треба використовувати лише для обробки текстових файлів (або читабельних людиною), а байтові потоки - для файлів даних.</li>
			 <li>Для байтових та символьних потоків можна використовувати буферизацію. Буферні класи представлені як класи обгортки для базових потоків. Використовуючи буферизацію, можна прискорити ввід-вивід великого об'єму даних.</li>
			 <li>Для обробки даних примітивних типів потрібні потоки даних.</li>
			 <li>Можна використовувати об'єктні потоки (класи <tt>ObjectInputStream</tt> та <tt>ObjectOutputStream</tt>) для читання та запису об'єктів з пам'яті до файлів та навпаки.</li>
			</ul>
		</li>
	</ul>

    <h1>Лекція 10</h1>
    <h1>Файловий ввід-вивід Java (NIO.2)</h1>

    <p>Цілі</p>

    <ul>
    	 <li>Використовувати інтерфейс <tt>Path</tt> для операцій над шляхами до файлів та каталогів</li>
    	 <li>Використовувати клас <tt>Files</tt> для перевірки, читання, видалення, копіювання, переміщення та управлянні мета-даними файла чи каталога</li>
    	 <li>Використовувати API потоків разом з NIO.2</li>
    </ul>

	<p>Java пропонує багатий набір API для маніпулювання файлами та каталогами. В Java 7 було запроваджено набір API для вводу-виводу під назвою NIO.2, в якому були надані зручні способи виконання операцій з файловою системою. В Java 8 можна використовувати API потоків (обговорювалося в Главі 6) разом з NIO.2.</p>

	<p>В попередній главі були розглянуті основи вводу-виводу; ми навчилися читати з консолі та писати в консоль, та використанню потоків для читання та запису файлів. В цій главі навчимося працювати з шляхами до файлів та каталогів, використовуючи інтерфейс <tt>Path</tt>. Також навчимося виконувати такі операції з файлами як створення, переміщення, копіювання та видалення за допомогою класа <tt>Files</tt>. Наприкінці ми побачимо, як використовувати потоковий API разом з NIO.2. В цій главі використовуються функціональні інтерфейси пакету <tt>java.util.function</tt> та потоковий API пакету <tt>java.util.stream</tt>, тож припускається знайомство з вмістом глав 3, 4, 5 та 6.</p>

	<p>Шляхи до файлів та каталогів надаються в припущенні, що використовується машина з Linux чи Mac OS. Якщо ви на машині з Windows, вам знадобиться зробити невеличкі зміни в іменах шляхів для того, щоб програми працювали на вашій машині.</p>

	<h2>Використання інтерфейсу <tt>Path</tt></h2>

	<p>Мета</p>

	<ul>
		 <li>Використовувати інтерфейс <tt>Path</tt> для операцій над шляхами до файлів та каталогів</li>
	</ul>

	<p>Файлові системи зазвичай формують дерево. Файлова система починається з кореневого каталога, який містить файли та каталоги (в Windows каталоги ще називаються папками). Кожен каталог, в свою чергу, може містити під-каталоги чи файли. Для адресування файла потрібно скласти разом - через роздільник - всі каталоги від кореневого до того, який містить файл, та завершити іменем файла. Наприклад, якщо файл <tt>myfile.txt</tt> знаходиться в каталозі <tt>wit</tt>, який міститься в <tt>home</tt>, який лежить в корні <tt>/</tt>, то шлях до файла буде <tt>/home/wit/myfile.txt</tt>. Кожен файл має унікальний шлях для його знаходження (про символічні посилання поговоримо окремо).</p>

	<p>Шлях може бути абсолютним (як <tt>/home/wit/myfile.txt</tt>), коли він починається з кореневого елемента. А може бути вказаний як відносний. При компіляції програми Java ми пишемо щось таке: <tt>javac programFileName.java</tt>; цей приклад вказує шлях до файла з кодом Java як відносний до поточного каталогу, тож це - відносний шлях. Для інтерпретації відносного шляху потрібен опорний шлях (такий як шлях до поточного каталога в даному випадку).</p>

	<p>А тепер - про символічні посилання. Символічне посилання це вказівник на дійсний файл. Взагалі, символічні посилання прозорі для додатків, в тому розумінні, що операції виконуються безпосередньо над файлами, а не над посиланнями (за внятком, звичайно, операцій, специфічних для символічних посилань).</p>

	<p>Інтерфейс <tt>Path</tt> це програмна абстракція для шляху. Об'єкт шляху містить імена каталогів та файлів і таким чином формує повний шлях файла чи каталога, представленого об'єктом <tt>Path</tt>; абстракція <tt>Path</tt> надає методи для отримання елементів шляху, маніпулювання ними та їх додавання. Далі можна побачити, що майже всі методи доступу до файлів/каталогів для отримання інформації про них чи для манцпулювання ними, використовують об'єкти <tt>Path</tt>. В таблиці <a href="#c10t01">10-1</a> наведено важливі методи цього інтерфейса.</p>

	<table id="c10t01" border="1">
		<caption>Таблиця 10-1. Важливі методи інтерфейса <tt>Path</tt></caption>
		<tr>
			<th>Метод</th>
			<th>Опис</th>
		</tr>
		<tr>
			<td><tt>Path getRoot()</tt></td>
			<td>Повертає об'єкт <tt>Path</tt>, який представляє корінь наданого шляху або <tt>null</tt>, якщо шлях не має корня.</td>
		</tr>
		<tr>
			<td><tt>Path getFileName()</tt></td>
			<td>Повертає ім'я файла чи каталога для наданого шляху. Зауважте, що ім'я файла/катаога це останній елемент наданого шляху.</td>
		</tr>
		<tr>
			<td><tt>Path getParent()</tt></td>
			<td>Повертає об'єкт <tt>Path</tt>, який представляє батьківський об'єкт наданого шляху, або <tt>null</tt>, якщо для наданого шляху такого не існу.</td>
		</tr>
		<tr>
			<td><tt>int getNameCount()</tt></td>
			<td>Повертає кількість імен файлів/каталогів в наданому шляху; повертає <tt>0</tt>, якщо наданий шлях представляє корінь.</td>
		</tr>
		<tr>
			<td><tt>Path getName(int index)</tt></td>
			<td>Повертає ім'я файла/каталога за номером <tt>index</tt>; індекс <tt>0</tt> починається з найближчого до кореня імені.</td>
		</tr>
		<tr>
			<td><tt>Path subpath(int beginIndex, int endIndex)</tt></td>
			<td>Повертає об'єкт <tt>Path</tt>, який є частиною цього об'єкта <tt>Path</tt>; об'єкт <tt>Path</tt>, який повертається, містить імена, які починаються з елементу за індексом <tt>beginIndex</tt> та закінчуються елементом за індексом <tt>endIndex - 1</tt>. Цей метод може викликати <tt>IllegalArgumentException</tt>, якщо <tt>beginIndex</tt> не менше кількості елементів, або <tt>endIndex</tt> не більше за <tt>beginIndex</tt>, чи <tt>endIndex</tt> більше за кількість елементів.</td>
		</tr>
		<tr>
			<td><tt>Path normalize()</tt></td>
			<td>Видаляє в шляху такі надлишкові елементи, як <tt>.</tt> (крапка вказує поточний каталог) та <tt>..</tt> (дві крапки вказують на батьківський каталог).</td>
		</tr>
		<tr>
			<td><tt>Path resolve(Path other)</tt><br/>
			<tt>Path resolve(String other)</tt></td>
			<td>Розкладає шлях відносно наданого шляху. Наприклад, цей метод може поєднати даний шлях з іншим шляхом та повернути шлях-результат.</td>
		</tr>
		<tr>
			<td><tt>Boolean isAbsolute()</tt></td>
			<td>Повертає <tt>true</tt>, якщо наданий шлях є абсолютним; повертає <tt>false</tt>, якщо ні (коли наданий шлях відносний, наприклад).</td>
		</tr>
		<tr>
			<td><tt>Path startsWith(String path)</tt><br/>
				<tt>Path startsWith(Path path)</tt></td>
			<td>Повертає <tt>true</tt>, якщо даний об'єкт <tt>Path</tt> починається з наданого шляху, чи <tt>false</tt> в іншому випадку.</td>
		</tr>
		<tr>
			<td><tt>Path toAbsolutePath()</tt></td>
			<td>Повертає абсолютний шлях.</td>
		</tr>
	</table>

	<h3>Отримання інформації про шлях</h3>

	<p>Створимо об'єкт <tt>Path</tt> та отримажмо основну інформацію, пов'язану з цим об'єктом. Лістинг <a href="#c10l01">10-1</a> показує, як створити об'єкт <tt>Path</tt> та отримати інформацію про нього.</p>

    <pre id="c10l01" class="prettyprint lang-java">
    // Лістинг 10-1. PathInfo1.java
    import java.nio.file.Path;
    import java.nio.file.Paths;

    // Клас для демонстрації використання інтерфейсу Path та його методів
    public class PathInfo1 {
    	public static void main(String[] args) {
    		// створити об'єкт Path, викликавши статичний метод get() в класі Paths
    		Path testFilePath = Paths.get("/home/wit/tmp/testfile.txt");
        
    		// отримати основну інформацію про шлях
    		System.out.println("Інформація про файл: ");
    		System.out.println("\t ім'я файла: " + testFilePath.getFileName());
    		System.out.println("\t корінь шляху: " + testFilePath.getRoot());
    		System.out.println("\t батько: " + testFilePath.getParent());

    		// елементи шляху
    		System.out.println("Елементи шляху: ");
    		for(Path element : testFilePath) {
    			System.out.println("\t елемент шляху: " + element);
    		}
    	}
    }
    </pre>

	<p>Ця програма надрукує наступне:</p>

    <pre id="out1001" class="prettyprint lang-bsh">
    $ java PathInfo1 
    Інформація про файл: 
    	 ім'я файла: testfile.txt
    	 корінь шляху: /
    	 батько: /home/wit/tmp
    Елементи шляху: 
    	 елемент шляху: home
    	 елемент шляху: wit
    	 елемент шляху: tmp
    	 елемент шляху: testfile.txt
    </pre>

    <p>Вивід зрозумілий, Розглянемо програму:</p>

    <ul>
    	<li>Спочатку викликом метода <tt>get()</tt> класу <tt>Paths</tt> створюється екземпляр <tt>Path</tt>. Метод <tt>get()</tt> очікує рядок, який представляє шлях. Це найпростіший спосіб створення об'єкта <tt>Path</tt>.</li>
    	<li>Якщо надається шлях в Windows, треба використовувати символ маскування (<tt>\</tt>), наприклад <tt>Paths.get("D:\\test\\testfile.txt")</tt>. В шляху <tt>D:\test</tt> послідовність <tt>\t</tt> трактується як символ табуляції, що викличе <tt>java.nio.file.InvalidPathException</tt> при запуску програми. Впевніться в екрануванні елементів рядків шляху.</li>
    	<li>Методом <tt>getFilename()</tt> об'єкта <tt>Path</tt> мі отримуємо ім'я файла, який представлено цим об'єктом <tt>Path</tt>.</li>
    	<li>Також використовуютсья методи <tt>getRoot()</tt> для отримання кореневого елемента об'єкта <tt>Path</tt> та <tt>getParent()</tt> для отримання батьківського каталогу.</li>
    	<li>Далі ітерація по елементах шляху з використанням циклу <tt>for</tt>. В інший спосіб, можна використовувати <tt>getNameCount()</tt> для отримання кількості елементів або імен в шляху та <tt>getName(index)</tt> для ітерації по ним та доступу до елементів/імен по одному.</li>
    </ul>

    <p>Спробуємо інший приклад. ін досліджує деякі цікаві аспекти об'єкта <tt>Path</tt>, такі як спосіб отримання абсолютного шляху з відносного чи <em>нормалізація</em> шляху. Перед цим треба зрозуміти методи, які в ньому використовуються:</p>

    <ul>
    	<li>Метод <tt>toUri()</tt> повертає URI (шлях, який можна відкрити в браузері) з даного шляху.</li>
    	<li>Метод <tt>toAbsolutePath()</tt> повертає абсолютний шлях з даного відносного. Якщо на вході вже абсолютний шлях, метод поверне той самий об'єкт.</li>
    	<li>Метод <tt>normalize()</tt> виконує нормалізацію даного шляху. Іншими словами, він видаляє з об'єкту <tt>Path</tt> небажані символи (такі як <tt>.</tt> та <tt>..</tt>).</li>
    	<li><tt>toRealPath()</tt> цікавий метод. Він повертає абсолютний шлях з даного об'єкта шляху (як <tt>toAbsolutepath()</tt>). Також він нормалізує шлях (як <tt>normalize()</tt>). Далі, якщо опції для посилань обрані вірно, він розв'язує символічні посилання. Однак, цільовий файл/каталог має існувати в файловій системі, що <em>не є</em> обов'язковим для внших методів <tt>Path</tt>.</li>
    </ul>

    <p>Лістинг <a href="#c10l02">10-2</a> показує цей приклад. Припустимо, що файл з іменем <tt>Test</tt> не існує в нашій файловій системі.</p>

    <pre id="c10l02" class="prettyprint lang-java">
    // Лістинг 10-2. PathInfo2.java
    import java.io.IOException;
    import java.nio.file.LinkOption;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    // Для демонстрації важливих методів normalize(), toAbsolutePath() та toRealPath()
    class PathInfo2 {
    	public static void main(String[] args) throws IOException {
        
    		// отримати об'єкт шляху з відносним шляхом
    		Path testFilePath = Paths.get(".\\Test");
    		System.out.println("Ім''я файла: " + testFilePath.getFileName());
    		System.out.println("Його URI: " + testFilePath.toUri());
    		System.out.println("Його абсолютний шлях: " + testFilePath.toAbsolutePath());
    		System.out.println("Його нормалізований шлях: " + testFilePath.normalize());
        
    		// отримати інший об'єкт шляху з нормалізованим відносним шляхом
    		Path testPathNormalized = Paths.get(testFilePath.normalize().toString());
    		System.out.println("Його нормалізований абсолютний шлях: " +
    				testPathNormalized.toAbsolutePath());
    		System.out.println("Його нормалізований дійсний шлях: " +
    				testFilePath.toRealPath (LinkOption.NOFOLLOW_LINKS));
    	}
    }
    </pre>

    <p>Програма надрукує наступне:</p>

    <pre id="out1002" class="prettyprint lang-bsh">
    $ java PathInfo2
    Ім''я файла: Test
    Його URI: file:///home/wit/tmp/./Test
    Його абсолютний шлях: /home/wit/tmp/./Test
    Його нормалізований шлях: Test
    Його нормалізований абсолютний шлях: /home/wit/tmp/Test
    Exception in thread "main" java.nio.file.NoSuchFileException: /home/wit/tmp/Test
    	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
    	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
    	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
    	at java.base/sun.nio.fs.UnixPath.toRealPath(UnixPath.java:899)
    	at PathInfo2.main(PathInfo2.java:23)

    </pre>

    <p>В залежності від каталогу, в якому запускається програма, шлях до каталогу буде відрізнятися. Ця програма створює об'єкт <tt>Path</tt> з відносним шляхом. Метод <tt>getFileName()</tt> повертає ім'я файла. Метод <tt>getUri()</tt> повертає URI, який можна виористовувати в браузері, а метод <tt>toAbsolutePath()</tt> повертає абсолютний шлях даного відносного шляху. (Зверніть увагу, що програма виконуєтсья в каталозі <tt>\home/wit/tmp</tt>; тож він стає поточним робочим каталогом та з'являється в абсолютному шляху та URI.)</p>

    <p>Для видалення надлишкових символів зі шляху викликається метод <tt>normalize()</tt>, який видаляє крапку з початку. Потім з використанням нормалізованого виводу створюється інший об'єкт <tt>Path</tt> та знову друкується абсолютний шлях. Наприкінці виконується спроба викликати <tt>toRealpath()</tt>, однак, повертається виняток (<tt>NoSuchFileException</tt>). Чому? Оскільки в поточному робочому каталозі не створений каталог <tt>Test</tt>.</p>

    <p>Тепер створимо каталог <tt>Test</tt> в каталозі <tt>/home/wit/tmp</tt> та запустимо програму ще раз. Ми отримаємо наступний вивід:</p>

    <pre id="out100201" class="prettyprint lang-bsh">
    $ mkdir Test
    $ java PathInfo2
    Ім'я файла: Test
    Його URI: file:///home/wit/tmp/./Test
    Його абсолютний шлях: /home/wit/tmp/./Test
    Його нормалізований шлях: Test
    Його нормалізований абсолютний шлях: /home/wit/tmp/Test
    Його нормалізований дійсний шлях: /home/wit/tmp/Test
    </pre>

    <p>Тепер останній виклик <tt>toRealPath()</tt> працює правильно та повертає абсолютний нормалізований шлях.</p>

    <p><tt>Path</tt> пропонує багато інших корисних методів, включаючи перелічені раніше в Таблиці <a href="c10t01">10-1</a>. Наприклад, ось як виористовувати метод <tt>resolve()</tt>:</p>

    <pre id="c10s01" class="prettyprint lang-java">
    Path dirName = Paths.get("/home/wit/tmp");
    Path resolvedPath = dirName.resolve("Test");
    System.out.println(resolvedPath);
    </pre>

    <p>Цей фрагмент коду надрукує наступне:</p>

    <pre id="out10s01" class="prettyprint lang-bsh">
    /home/wit/tmp/Test
    </pre>

    <p>Цей метод <tt>resolve()</tt> вважає, що даний шлях є каталогом та поєднує наданий шлях із ним.</p>

    <hr/>
    Метод <tt>toPath()</tt> класу <tt>java.io.File</tt> повертає об'єкт <tt>Path</tt>; цей метод був доданий в Java 7. Схожим чином можна використовувати метод <tt>toFile()</tt> інтерфейсу <tt>Path</tt> для отримання об'єкта <tt>File</tt>.
    <hr/>

    <h3>Порівняння двох шляхів</h3>

    <p>Інтерфейс <tt>Path</tt> надає два методи для порівняння двох об'єктів <tt>Path</tt>: <tt>equals()</tt> та <tt>compareTo()</tt>. Метод <tt>equals()</tt> перевіряє еквівалентність двох об'єктів <tt>Path</tt> та повертає булеве значення, в той час як метод <tt>compareTo()</tt> порівнює два об'єкти <tt>Path</tt> символ за символом та повертає ціле: <tt>0</tt> якщо обидва об'єкти <tt>Path</tt> рівні; негативне ціле, якщо поточний шлях лексикографічно менший за шлях в параметрів, та позитивне ціле, якщо поточний шлях лексикографічно більший за наданий в параметрі. Лістинг <a href="#c10l03">10-3</a> містить маленьку програму, яка демонструє ці методи.</p>

    <pre class="prettyprint lang-java">
    // Лістинг 10-3. PathCompare1.java
    import java.nio.file.Path;
    import java.nio.file.Paths;

    // ілюструє як використовувати compareTo та equals
    // та різницю між цими двома методами

    class PathCompare1 {
    	public static void main(String[] args) {
    		Path path1 = Paths.get("Test");
    		Path path2 = Paths.get("/home/wit/tmp/Test");
        
    		// порівняння двох шляхів методом compareTo()
    		System.out.println("(path1.compareTo(path2) == 0) is: "
    				+ (path1.compareTo(path2) == 0));
        
    		// порівняння двох шляхів методом equals()
    		System.out.println("path1.equals(path2) is: " + path1.equals(path2));
        
    		// порівняння двох абсолютних шляхів методом equals()
    		System.out.println("path2.equals(path1.toAbsolutePath()) is "
    				+ path2.equals(path1.toAbsolutePath()));
    	}
    }
    </pre>

    <p>Один шлях заданий як відносний, а інший - як асолютний. Припустимо, що програма виконується в каталозі <tt>/home/wit/tmp</tt>. Який буде її вивід?</p>

    <p>Він буде таким:</p>

    <pre id="out1003" class="prettyprint lang-bsh">
    $ java PathCompare1 
    (path1.compareTo(path2) == 0) is: false
    path1.equals(path2) is: false
    path2.equals(path1.toAbsolutePath()) is true
    </pre>

    <p>Розглянемо програму:</p>

    <ul>
    	<li>Спочатку порівнюються два шляхи методом <tt>compareTo()</tt>, який порівнює шляхи символ за символом та повертає ціле. В цьому випадку, оскільки один шлях відносний, а інший абсолютний, цілком очікувано отримати повідомлення про їх нерівність.</li>
    	<li>Потім обидва шляхи порівнюються методом <tt>equals()</tt>. Результат той самий, що означає можливість повернення <tt>false</tt> методом <tt>equals()</tt> навіть, якщо два об'єкти <tt>Path</tt> вказують на один файл/каталог. Треба порівнювати абсолютні шляхи.</li>
    	<li>Наступним кроком відносні шляхи перетворюються в абсолютні, які вже й порівнюються методом <tt>equals()</tt>. Цього разу шляхи співпадають.</li>
    </ul>

    <hr/>
    Навіть якщо два об'єкти <tt>Path</tt> вказують на той самий файл/каталог, немає гарантії того, що метод <tt>equals()</tt> поверне <tt>true</tt>. Для успішного порівняння шляхів треба впевнитися в тому, що обидва шляхи нормалізовані та абсолютні.
    <hr/>

    <h2>Використання класа <tt>Files</tt></h2>

    <p>Мета</p>

    <ul>
    	 <li>Використовувати клас <tt>Files</tt> для перевірки, читання, видалення, копіювання, переміщення, управління мета-даними файла чи каталога</li>
    </ul>

    <p>В попередньому розділі розповідалося про створення екземпляра <tt>Path</tt> та отриманні з нього корисної інформації. В цьому розділі об'єкти <tt>Path</tt> використовуватимуться дял маніпулювання файлами/каталогами. Java 7 пропонує клас <tt>Files</tt> (в пакеті <tt>java.nio.file</tt>), який можна використовувати для виконання різноманітних операцій з файлами та каталогами. Зверніть увагу, клас <tt>Files</tt> це інструментальний клас; це означає, що він константний (final) клас з приватним конструктором, та складається лише зі статичних методів. Отже можна використовувати клас <tt>Files</tt>, викликаючи статичні методи, які він пропонує, такі як <tt>copy()</tt> для копіювання файлів. Цей клас надає широкий діапазон функціональності. Можна створювати каталоги, файли чи символічні посилання; створювати потоки (такі як потоки каталогів, байтові канали та потоки вводу-виводу); аналізувати атрибути файлів; переміщатися деревом файлів; та виконувати такі операціх з файлами, як читання, запис, копіювання та видалення. В таблиці <a href="#c10t02">10-2</a> наведено декілька важливих методів класу <tt>Files</tt>.</p>

    <table id="c10t02" border="1">
    	<caption>Таблиця 10-2. Деякі корисні методи класу <tt>Files</tt></caption>
    	<tr>
    		<th>Метод</th>
    		<th>Опис</th>
    	</tr>
    	<tr>
    		<td><tt>Path createDirectory(Path dirPath, FileAttribute&lt;?&gt;... dirAttrs)<br/>
    		Path createDirectories(Path dir, FileAttribute&lt;?&gt;... attrs)</tt></td>
    		<td>Створює файл <tt>dirPath</tt> та встановлює атрибути <tt>dirAttributes</tt>. Може викликати такий виняток як <tt>FileAlreadyExistsException</tt> чи <tt>UnsupportedOperationException</tt> (наприклад, коли атрибути файла не можна встановити в надані <tt>dirAttrs</tt>). Різниця між <tt>createDirectory</tt> та <tt>createDirectories</tt> в тому, що <tt>createDirectories</tt> створює проміжні каталоги <tt>dirPath</tt>, якщо вони не існують.</td>
    	</tr>
    	<tr>
    		<td><tt>Path createTempFile(Path dir, String prefix, String suffix, FileAttribute&lt;?&gt;... attrs)</tt></td>
    		<td>Створює тимчасовий файл в каталозі <tt>dir</tt>, виходячи з <tt>prefix</tt>, <tt>suffix</tt> та атрибутів.</td>
    	</tr>
    	<tr>
    		<td><tt>Path createTempDirectory(Path dir, String prefix, FileAttribute&lt;?&gt;... attrs)</tt></td>
    		<td>Створює в шляху <tt>dir</tt> тимчасовий каталог з наданих <tt>prefix</tt> та атрибутів каталогу.</td>
    	</tr>
    	<tr>
    		<td><tt>Path copy(Path source, Path target, CopyOption... options)</tt></td>
    		<td>Копіює файл з <tt>source</tt> до <tt>target</tt>. <tt>CopyOption</tt> може бути <tt>REPLACE_EXISTING</tt>, <tt>COPY_ATTRIBUTES</tt> чи <tt>NOFOLLOW_LINKS</tt>. Може викликати такі винятки як <tt>FileAlreadyExistsException</tt>.</td>
    	</tr>
    	<tr>
    		<td><tt>Path move(Path source, Path target, CopyOption... options)</tt></td>
    		<td>Схоже на операцію копіювання, але вихідний файл видаляється. Якщо вихідний та цільовий файли в одному каталозі, то це операція перейменування файлу.</td>
    	</tr>
    	<tr>
    		<td><tt>boolean isSameFile(Path path, Path path2)</tt></td>
    		<td>Перевіряє, чи два об'єкти <tt>Path</tt> вказують на один файл.</td>
    	</tr>
    	<tr>
    		<td><tt>boolean exists(Path path, LinkOption... options)</tt></td>
    		<td>Перевіряє існування файла/каталога в наданому <tt>path</tt>; можна вказати <tt>LinkOption.NOFOLLOW_LINKS</tt> для запобігання переходу за символічними посиланнями.</td>
    	</tr>
    	<tr>
    		<td><tt>Boolean isRegularFile(Path path, LinkOption...)</tt></td>
    		<td>Повертає <tt>true</tt>, якщо файл <tt>path</tt> є звичайним файлом.</td>
    	</tr>
    	<tr>
    		<td><tt>Boolean isSymbolicLink(Path path)</tt></td>
    		<td>Повертає <tt>true</tt>, якщо файл <tt>path</tt> є символічним посиланням.</td>
    	</tr>
    	<tr>
    		<td><tt>Boolean isHidden(Path path)</tt></td>
    		<td>Повертає <tt>true</tt>, якщо файл <tt>path</tt> є прихованим файлом.</td>
    	</tr>
    	<tr>
    		<td><tt>long size(Path path)</tt></td>
    		<td>Повертає розмір файла <tt>path</tt> в байтах.</td>
    	</tr>
    	<tr>
    		<td><tt>UserPrincipal getOwner(Path path, LinkOption...)<br/>
    		Path setOwner(Path path, UserPrincipal owner)</tt></td>
    		<td>Отримує/встановлює власника файла.</td>
    	</tr>
    	<tr>
    		<td><tt>FileTime getLastModifiedTime(Path path, LinkOption...)<br/>
    		Path setLastModifiedTime(Path path, FileTime time)</tt></td>
    		<td>Отримує/встановлює час останнього змінення файла.</td>
    	</tr>
    	<tr>
    		<td><tt>Object getAttribute(Path path, String attribute, LinkOption...)<br/>
    		Path setAttribute(Path path, String attribute, Object value, LinkOption...)</tt></td>
    		<td>Отримує/встановлює вказаний атрибут вказаного файла.</td>
    	</tr>
    </table>

    <h3>Перевірка властивостей та мета-даних файла</h3>

    <p>В попередньому розділі про інтерфейс <tt>Path</tt> ми намагалися з'ясувати, чи вказують два шляхи на один файл (дивись Лістинг <a href="#c10l03">10-3</a>). Ось інший спосіб: можна використати метод <tt>isSameFile()</tt> класу <tt>Files</tt>. Лістинг <a href="c10l04">10-4</a> показує, як це робити.</p>

    <pre id="c10l04" class="prettyprint lang-java">
    // Лістинг 10-4. PathCompare2.java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    // показує використання класу Files для порівняння двох шляхів
    class PathCompare2 {
    	public static void main(String[] args) throws IOException {
    		Path path1 = Paths.get("Test");
    		Path path2 = Paths.get("/home/wit/tmp/Test");
    		System.out.println("Files.isSameFile(path1, path2) is: "
    				+ Files.isSameFile(path1, path2));
    	}
    }
    </pre>

    <p>Припустимо існування каталога <tt>/home/wit/tmp/Test</tt>. Програма надрукує наступне:</p>

    <pre id="out1004" class="prettyprint lang-bsh">
    $ java PathCompare2
    Files.isSameFile(path1, path2) is: true
    </pre>

    <p>В цьому прикладі в нас існує каталог <tt>Test</tt> в шляху <tt>/home/wit/tmp</tt>, тож код працює правильно.</p>

    <p>Якщо каталог/файл <tt>Test</tt> не існує в наданому шляху, ми отримаємо <tt>NoSuchFileException</tt>. Але як можна перевірити існування файла/каталога в наданому шляху? Клас <tt>Files</tt> пропонує метод <tt>exists()</tt> для цього. Також можна розрізняти файл та каталог за допомогою методу класу <tt>Files</tt>. Лістинг <a href="c10l05">10-5</a> використовує ці методи.</p>

    <pre id="c10l05" class="prettyprint lang-java">
    // Лістинг 10-5. PathExists.java
    import java.nio.file.Files;
    import java.nio.file.LinkOption;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    class PathExists {
    	public static void main(String[] args) {
    		Path path = Paths.get(args[0]);

    		if(Files.exists(path, LinkOption.NOFOLLOW_LINKS)) {
    			System.out.println("Файл/каталог " + path.getFileName() + " існує");
    			// перевірити, файл це чи каталог
    			if(Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
    				System.out.println(path.getFileName() + " це каталог");
    			} else {
    				System.out.println(path.getFileName() + " це файл");
    			}
    		} else {
    			System.out.println("Файл/каталог " + path.getFileName()
    					+ " не існує");
    		}
    	}
    }
    </pre>

    <p>Ця програма приймає ім'я файла/каталога з командного рядку та створює об'єкт <tt>Path</tt>. Потім можна використати метод <tt>exists()</tt> класу <tt>Files</tt> для з'ясування існування цього файла/каталога. Другий параметр метода <tt>exists()</tt> це опція посилання, яка використовується для вказівки, чи переходити за символічним посиланням; в нашому прикладі - ні. Якщо файл/каталог існує, ми перевіряємо, вказує він на файл чи на каталог, використовуючи метод <tt>isDirectory()</tt> класу <tt>Files</tt>.</p>

    <p>Запустимо програму з різними аргументами та отримаємо такий вивід (припустимо, що файл <tt>PathExists.java</tt> знаходиться в каталозі <tt>/home/wit/tmp)</tt>:</p>

    <pre id="out1005" class="prettyprint lang-bsh">
    /home/wit/tmp$ java PathExists PathExists.java 
    Файл/каталог PathExists.java існує
    PathExists.java це файл

    /home/wit/tmp$ java PathExists .
    Файл/каталог . існує
    . це каталог

    /home/wit/tmp$ java PathExists /home/wit
    Файл/каталог wit існує
    wit це каталог

    /home/wit/tmp$ java PathExists /
    Файл/каталог null існує
    null це каталог
    </pre>

    <p>Зверніть увагу на результат з кореневим каталогом. Кореневе ім'я це каталог, але <tt>path.getFileName()</tt> повертає <tt>null</tt>, якщо шлях це кореневе ім'я.</p>

    <p>Існуючі файли можуть не дозволяти читання, запис чи виконання - це залежить від повноважень. Можна перевірити здатність програми читати, записувати чи виконувати файл. Клас <tt>Files</tt> надає методи <tt>isReadable()</tt>, <tt>isWritable()</tt> та <tt>isExecutable()</tt>. Лістинг <a href="#c10l06">10-6</a> використовує ці методи: для цієї програми створіть файл <tt>readonly.txt</tt> з повноваженнями на читання, виконання, але не на запис.</p>

    <pre id="prepare06" class="prettyprint lang-bsh">
    $ touch readonly.txt
    $ chmod 555 readonly.txt
    $ ls -la readonly.txt 
    -r-xr-xr-x 1 wit wit 0 апр 28 22:20 readonly.txt
    </pre>

    <pre id="c10l06" class="prettyprint lang-java">
    // Лістинг 10-6. FilePermissions.java
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    class FilePermissions {
    	public static void main(String[] args) {
    		Path path = Paths.get(args[0]);
    		System.out.printf( "Читання: %b, Запис: %b, Виконання: %b \n",
    		Files.isReadable(path), Files.isWritable(path), Files.isExecutable(path));
    	}
    }
    </pre>

    <p>Вконаємо програму з різними даними на вході. Результат:</p>

    <pre id="out1006" class="prettyprint lang-bsh">
    $ java FilePermissions readonly.txt 
    Читання: true, Запис: false, Виконання: true 
    $ java FilePermissions FilePermissions.java 
    Читання: true, Запис: true, Виконання: false 
    $ java FilePermissions Test
    Читання: true, Запис: true, Виконання: true 
    </pre>

    <p>Для отримання властивостей файла можна використовувати багато інших методів. Використаємо метод <tt>getAttribute()</tt> для отримання деяких атрибутів файла. Цей метод приймає різні параметри: об'єкт <tt>Path</tt>, ім'я атрибуту та опцію посилання (дивись Лістинг <a href="#c10l07">10-7</a>).</p>

    <pre id="c10l07" class="prettyprint lang-java">
    // Лістинг 10-7. FileAttributes.java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.LinkOption;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    class FileAttributes {
    	public static void main(String[] args) {
    		Path path = Paths.get(args[0]);
    		try {
    			Object object = Files.getAttribute(path, "creationTime",
    					LinkOption.NOFOLLOW_LINKS);
    			System.out.println("Час створення: " + object);

    			object = Files.getAttribute(path, "lastModifiedTime", LinkOption.NOFOLLOW_LINKS);
    			System.out.println("Час останнього змінення: " + object);
            
    			object = Files.getAttribute(path, "size", LinkOption.NOFOLLOW_LINKS);
    			System.out.println("Розмір: " + object);
            
    			object = Files.getAttribute(path, "dos:hidden", LinkOption.NOFOLLOW_LINKS);
    			System.out.println("чиПрихований: " + object);
            
    			object = Files.getAttribute(path, "isDirectory", LinkOption.NOFOLLOW_LINKS);
    			System.out.println("чиКаталог: " + object);
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    	}
    }
    </pre>

    <p>Приклад виконання програми:</p>

    <pre ic="out1007" class="prettyprint lang-bsh">
    $ java FileAttributes FileAttributes.java 
    Час створення: 2020-04-28T19:32:36.693325Z
    Час останнього змінення: 2020-04-28T19:32:36.693325Z
    Розмір: 1264
    чиПрихований: false
    чиКаталог: false
    </pre>

    <p>Особливу увагу приділяйте другому параметру метода <tt>getAttribute()</tt>. Для отримання відповідного значення треба надати правильне фм'я атрибута. Очікуваний рядок має бути наданий в форматі <tt>view:attribute</tt>, де <tt>view</tt> це тип <tt>FileAttributeView</tt>, а <tt>attribute</tt> це підтримуване <tt>view</tt> ім'я атрибуту. Якщо <tt>view</tt> не вказано, воно вважається за <tt>basic</tt>. В прикладі вказано всі атрибути як такі, що належать до представлення <tt>basic</tt> за виключенням одного атрибута з представлення <tt>dos</tt>. Якщо не вкзати правильне ім'я представлення, отримаємо <tt>UnsupportedOperationException</tt>; а при неправильному імені атрибута - <tt>IllegalArgumentException</tt>.</p>

    <p>Наприклад, якщо надати <b>sized</b> замість <b>size</b>, отримаємо наступний виняток:</p>

    <pre>
    Exception in thread "main" java.lang.IllegalArgumentException: 'sized' not recognized
    [...]
    </pre>

    <p>Тепер нам відомо, як зчитувати мета-дані, пов'язані з файлами, використовуючи метод <tt>getAttribute()</tt>.</p>

    <p>Однак, при потребі зчитати багато атрибутів виклик <tt>getAttribute()</tt> для кожного атрибута може стати поганою ідєю (з міркувань продуктивності). В такому випадку Java 7 пропонує рішення: API &mdash; <tt>readAttributes()</tt> &mdash; для читання атрибутів за один виклик. Цей API буває двох видів:</p>

    <ul>
    	<li><pre>Map&lt;String,Object&gt; readAttributes(Path path, String attributes, LinkOption... options)</pre></li>
    	<li><pre>&lt;A extends BasicFileAttributes&gt; A readAttributes(Path path, Class&lt;A&gt; type, LinkOption... options)</pre></li>
    </ul>

    <p>Перший метод повертає <tt>Map</tt> пар атрибут-значення та приймає параметри змінної довжини. Параметр <tt>attributes</tt> це ключовий параметр, де вказується потрібне. Цей параметр схожий на той, що використовується в методі <tt>getAttribute()</tt>; однак, тут можна вказати перелік атрибутів, а також можна використовувати зірочку (<tt>*</tt>) для вказівки на всі атрибути. Наприклад, використання <tt>*</tt> означає всі атрибути представлення по замовчанню <tt>FileAttributeView</tt>, такі як <tt>BasicFileAttributes</tt> (вказані як базові атрибути файла). Інший приклад: <tt>dos:*</tt>, які посилаються на всі атрибути файлових атрибутів <tt>dos</tt>.</p>

    <p>Другий метод використовує синтаксис узагальнень (Глава 4).Другий параметр приймає клас з ієрархії <tt>BasicFileAttributes</tt>, про яку поговоримо незабаром. Цей метод повертає екземпляр з ієрархії <tt>BasicFileAttributes</tt>.</p>

    <p>Ієрархія файлових атрибутів зображена на Рисунку <a href="#c10f01">10-1</a>. <tt>BasicFileAttributes</tt> це базовий інтерфейс для <tt>DosFileAttributes</tt> та <tt>PosixFileAttributes</tt>. Зауважте, що ці інтерфейси атрибутів пропонуються в пакеті <tt>java.nio.file.attribute</tt>.</p>

    <img id="c10f01" src="img/c10f01.png" alt="Рисунок 10-1. Ієрархія BasicFileAttributes"/>

    <p><b>Рисунок 10-1</b>. Ієрархія <tt>BasicFileAttributes</tt></p>

    <p>Інтерфейс <tt>BasicFileAttributes</tt> визначає базові атрибути, які підтримуються всіма загальними платформами. А специфічні платформи визначають свої власні файлові атрибути, що показується <tt>DosFileAttributes</tt> та <tt>PosixFileAttributes</tt>. Можна вказати один з цих інтерфейсів для отримання відповідних атрибутів файлів. Лістинг <a href="#c10l08">10-8</a> містить програму для отримання всіх атрибутів файла з використанням <tt>BasicFileAttributes</tt>.</p>

    <pre id="c10l08" class="prettyprint lang-java">
    // Лістинг 10-8. FileAttributes2.java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.attribute.BasicFileAttributes;

    class FileAttributes2 {
    	public static void main(String[] args) {
    		Path path = Paths.get(args[0]);
    		try {
    			BasicFileAttributes fileAttributes =
    					Files.readAttributes(path, BasicFileAttributes.class);
    			System.out.println("Розмір файла: " + fileAttributes.size());
    			System.out.println("чиКаталог: " + fileAttributes.isDirectory());
    			System.out.println("чиЗвичайний: " + fileAttributes.isRegularFile());
    			System.out.println("ЧиПосилання: " + fileAttributes.isSymbolicLink());
    			System.out.println("Час останнього доступу: " + fileAttributes.lastAccessTime());
    			System.out.println("Час останнього змінення: " +
    					fileAttributes.lastModifiedTime());
    			System.out.println("Час створення: " + fileAttributes.creationTime());
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    	}
    }
    </pre>

    <p>Приклад виводу програми:</p>

    <pre id="out1008" class="prettyprint lang-bsh">
    $ java FileAttributes2 FileAttributes2.class 
    Розмір файла: 2201
    чиКаталог: false
    чиЗвичайний: true
    ЧиПосилання: false
    Час останнього доступу: 2020-04-28T19:57:32.904624Z
    Час останнього змінення: 2020-04-28T19:57:19.73263Z
    Час створення: 2020-04-28T19:57:19.73263Z
    </pre>

    <p>Тут використовується метод <tt>readAttribute()</tt> з <tt>BasicFileAttributes</tt> для отримання базових властивостей файла. Схожим чином можна отримати атрибути файла в оточенні DOS чи Unix, використовуючи <tt>DosFileAttributes</tt> та <tt>PosixFileAttributes</tt> відповідно.</p>

    <h3>Копіювання файла</h3>

    <p>Тепер спробуємо скопіювати файл/каталог з одного місця в інше. Цю задачу виконати просто: для копіювання файла використовуйте <tt>Files.copy()</tt>. Сигнатура цього метода:</p>

    <pre id="c10s02" class="prettyprint lang-java">
    Path copy(Path source, Path target, CopyOption... options)
    </pre>

    <p>Лістинг <a href="#c10l09">10-9</a> використовує цей метод в простій програмі копіювання файлів.</p>

    <pre id="c10l09" class="prettyprint lang-java">
    // Лістинг 10-9. FileCopy.java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class FileCopy {
    	public static void main(String[] args) {
    		if(args.length != 2){
    			System.out.println("використання: FileCopy &lt;source-path&gt; &lt;destination-path&gt;");
    			System.exit(1);
    		}
    		Path pathSource = Paths.get(args[0]);
    		Path pathDestination = Paths.get(args[1]);
    		try {
    			Files.copy(pathSource, pathDestination);
    			System.out.println("Вихідний файл успішно скопійовано");
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    	}
    }
    </pre>

    <p>Перевіримо її в роботі.</p>

    <pre id="out1009" class="prettyprint lang-bsh">
    $ java FileCopy readonly.txt readonly_copy.txt 
    Вихідний файл успішно скопійовано
    </pre>

    <p>Працює. Запустимо ще раз з тими самими аргументами:</p>

    <pre id="out100901" class="prettyprint lang-bsh">
    $ java FileCopy readonly.txt readonly_copy.txt 
    java.nio.file.FileAlreadyExistsException: readonly_copy.txt
    	[...]
    	at FileCopy.main(FileCopy.java:16)
    </pre>

    <p>При спробі скопіювати файл вдруге ми отримали <tt>FileAlreadyExistsException</tt>, оскільки цільовий файл вже існує. Якщо потрібно перезаписати існуючий файл? Рішення: в Лістингу <a href="#c10l09">10-9</a>, змініть виклик <tt>copy()</tt> таким чином:</p>

    <pre id="c10s03" class="prettyprint lang-java">
    Files.copy(pathSource, pathDestination, StandardCopyOption.REPLACE_EXISTING);
    </pre>

    <p>Ми надали додатковий аргумент (оскільки метод <tt>copy()</tt> підтримує змінні аргументи) для вказівки перезаписати файл, якщо він вже існує. Подивимось на результат роботи програми:</p>

    <pre id="out100902" class="prettyprint lang-bsh">
    $ java FileCopy2 readonly.txt readonly_copy.txt
    Вихідний файл успішно скопійовано
    </pre>

    <p>Працює. Тепер спробуємо скопіювати файл в каталог:</p>

    <pre id="out100903" class="prettyprint lang-bsh">
    java FileCopy2 readonly.txt dst/readonly_copy.txt
    java.nio.file.NoSuchFileException: dst/readonly_copy.txt
    	[...]
    	at FileCopy2.main(FileCopy2.java:17)
    </pre>

    <p>Спроба скопіювати файл в каталог, який не існує. Отримали <tt>NoSuchFileException</tt>. Для успішної роботи метода <tt>copy()</tt> має існувати не лише наданий каталог, а й всі проміжні в шляху до нього.</p>

    <hr/>
    Для запобігання <tt>NoSuchFileException</tt> на вказаному шляху мають існувати всі каталоги (за винятком останнього при копіюванні каталога).
    <hr/>

    <p>Спробуйте скопіювати каталог. Це вийде, але пам'ятайте, що копіюється тільки каталог верхнього рівня, а не ті файликаталоги, що <em>всередині</em> нього.</p>

    <hr/>
    При копіюванні каталога методом <tt>copy()</tt>, не копіюються файликаталоги, які містяться в вихідному каталозі; їх треба копіювати в цільовий каталог явно.
    <hr/>

    <h3>Переміщення файла</h3>

    <p>Переміщення файла схоже на копіювання; для цього використовуєтсья метод <tt>Files.move()</tt>. Сигнатура метода:</p>

    <pre id="c10s04" class="prettyprint lang-java">
    Path move(Path source, Path target, CopyOption... options)
    </pre>

    <p>Лістинг <a href="#c10l10">10-10</a> містить маленьку програму, яка використовує цей метод. Зверніть увагу: при вдалому спрацюванні метода <tt>move()</tt> вихідний файл зникає.</p>

    <pre id="c10l10" class="prettyprint lang-java">
    // Лістинг 10-10. FileMove.java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.nio.file.StandardCopyOption;

    public class FileMove {
    	public static void main(String[] args) {
    		if(args.length != 2){
    			System.out.println("використання: FileMove &lt;source-path&gt; &lt;destination-path&gt;");
    			System.exit(-1);
    		}
    		Path pathSource = Paths.get(args[0]);
    		Path pathDestination = Paths.get(args[1]);
    		try {
    			Files.move(pathSource, pathDestination, StandardCopyOption.REPLACE_EXISTING);
    			System.out.println("Вихідний файл переміщено успішно");
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    	}
    }
    </pre>

    <p>Приклад використання програми (в припущенні існування файла <tt>text.txt</tt> в поточному каталозі):</p>

    <pre id="out1010" class="prettyprint lang-bsh">
    $ java FileMove readonly.txt readonly_new.txt
    Вихідний файл переміщено успішно
    </pre>

    <p>Декілька зауважень щодо метода <tt>move()</tt>:</p>

    <ul>
    	<li>Як і метод <tt>copy()</tt>, метод <tt>move()</tt> не перезаписує існуючий цільовий файл, якщо не указати робити це за допомогою <tt>REPLACE_EXISTING</tt>.</li>
    	<li>При переміщенні символічного посилання переміщується саме посилання, а не його цільовий файл. Важливо зауважити, що в разі <tt>copy()</tt> при наданні символічного посилання копіюється його цільовий файл, а не саме посилання.</li>
    	<li>Не порожній каталог можна перемістити, якщо переміщення каталогу не потребує переміщення файлів/каталогів, які містяться в ньому. Наприклад, переміщення каталогу з одного фізичного носія на інший може не вдатися (викличеться <tt>IOException</tt>). Якщо переміщення каталогу вдалося, то всі файликаталоги, які містилися в ньому, також переміщуються.</li>
    	<li>Можна вказати <tt>move()</tt> як атомарну операцію за допомогою опції копіювання <tt>ATOMIC_MOVE</tt>. При указанні атомарного переміщення гарантується або вдале переміщення, або існування джерела. Якщо <tt>move()</tt> виконується як не-атомарна операція, та вона збоїть під час виконання, то стан обох файлів невідомий та не невизначений.</li>
    </ul>

    <h3>Видалення файла</h3>

    <p>Клас <tt>Files</tt> пропонує метод <tt>delete()</tt> для видалення файла/каталога символічного посилання. Лістинг <a href="#c10l11">10-11</a> містить просту програму для видалення вказаного файла.</p>

    <pre id="c10l11" class="prettyprint lang-java">
    // Лістинг 10-11. FileDelete.java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class FileDelete {
    	public static void main(String[] args) {
    		if(args.length != 1){
    			System.out.println("використання: FileDelete &lt;source-path&gt;");
    			System.exit(1);
    		}
    		Path pathSource = Paths.get(args[0]);
    		try {
    			Files.delete(pathSource);
    			System.out.println("Файл видалено успішно");
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    	}
    }
    </pre>

    <p>При виконанні надрукує:</p>

    <pre id="out011" class="prettyprint lang-bsh">
    $ java FileDelete readonly_copy.txt 
    Файл видалено успішно
    </pre>

    <p>Декілька важливих моментів зодо використання методу <tt>Files.delete()</tt>. Метод <tt>delete()</tt> може видалити лише порожній каталог; інакше він схибить. При наданні символічного посилання видаляється посилання, а не його цільовий файл. Файл, призначений для видалення, має існувати; інакше отримаємо <tt>NoSuchFileException</tt>. Якщо бажаєте не піклуватися через цей виняток, можна використовувати метод <tt>deleteIfExists()</tt>, який не скаржиться на те, що файл не існує, а якщо файл існує, то видаляє його. На деяких платформах видалення файлу тільки для читання може бути заборонено.</p>

    <h3>Пам'ятка</h3>

    <p>Варто запам'ятати.</p>

    <ul>
    	<li>Не плутайте <tt>File</tt> з <tt>Files</tt>, а <tt>Path</tt> з <tt>Paths</tt>: це різні речі. <tt>File</tt> це старий клас (Java 4), який представляє імена шляхів файла/каталога, в той час як <tt>Files</tt> був представлений в Java 7 як інструментальний клас з широкою підтримкою API для вводу-виводу. Інтерфейс <tt>Path</tt> представляє шлях файла/каталога та визначає корисний перелік методів. А клас <tt>Paths</tt> це інструментальний клас, який надає лише два методи (обидва для отримання об'єкта <tt>Path</tt>).</li>
    	<li>Файл чи каталог, представлені об'єктом <tt>Path</tt>, можуть не існувати. Тільки такі методи як <tt>toRealPath()</tt> вимагають існування файла чи каталога для відповідного об'єкта <tt>Path</tt>, інші методи в <tt>Path</tt> - ні.</li>
    	<li>Ми навчилися копіювати файли/каталоги. Однак, не обов'язково виконувати копіювання лише двох файлів/каталогів. Можна приймати ввід від <tt>InputStream</tt> та записувати в файл, чи приймати ввід з файлу та копіювати його в <tt>OutputStream</tt>. Для цього можна використовувати методи <tt>copy(InputStream, Path, CopyOptions...)</tt> та <tt>copy(Path, OutputStream, CopyOptions...)</tt>.</li>
    </ul>

    <h2>Використання Stream API з NIO.2</h2>

    <p>Мета</p>

    <ul>
    	 <li>Використовувати Stream API з NIO.2</li>
    </ul>

    <p>Багато покращень JDK в Java 8 спростили програмування з використанням NIO.2. Цей розділ присвячений деяким важливим покращенням пакету <tt>java.nio</tt> в Java 8.</p>

    <h3>Використання методу <tt>list()</tt> в класі <tt>Files</tt></h3>

    <p>Почнему з використання методу <tt>Files.list()</tt>, який був доданий в 8 для перелічення всіх файлів поточного каталога (дивись Лістинг <a href="#c10l12">10-12</a>). В ньому використовується <tt>DirectoryStream</tt>, тож для вивільнення ресурсу вводу-виводу треба викликати метод <tt>close()</tt>. Ця програма використовує потік в операторі try-with-resources, який закриває потік автоматично.</p>

    <pre id="c10l12" class="prettyprint lang-java">
    // Лістинг 10-12. ListFiles.java
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.io.IOException;
    import java.util.stream.Stream;

    class ListFiles {
    	public static void main(String []args) throws IOException {
    		try(Stream&lt;Path&gt; entries = Files.list(Paths.get("."))) {
    			entries.forEach(System.out::println);
    		}
    	}
    }
    </pre>

    <p>Програма друкує імена файлів в поточному каталозі:</p>

    <pre id="out1012" class="prettyprint lang-bsh">
    ./ListFiles.class
    ./ListFiles.java
    ... (решту випущено)
    </pre>

    <p>Метод <tt>list()</tt> оголошений так:</p>

    <pre id="c10s05" class="prettyprint lang-java">
    static Stream&lt;Path&gt; list(Path dir) throws IOException
    </pre>

    <p>Оскільки метод <tt>list()</tt> повертає <tt>Stream</tt>, то можна використовувати багато методів інтерфейса <tt>Stream</tt>, включаючи <tt>map()</tt>, <tt>filter()</tt>, <tt>findFirst()</tt>, <tt>findAny()</tt>, <tt>distinct()</tt>, <tt>sorted()</tt>, <tt>allMatch()</tt>, <tt>noneMatch()</tt> та <tt>anyMatch()</tt>.</p>

    <p>Цей фрагмент коду - змінена версія Лістингу <a href="#c10l12">10-12</a>, яка друкує абсолютні шляхи файлів:</p>

    <pre id="c10s06" class="prettyprint lang-java">
    Files.list(Paths.get("."))
    		.map(path -&gt; path.toAbsolutePath())
    		.forEach(System.out::println);
    </pre>

    <p>Результат:</p>

    <pre id="out101202" class="prettyprint lang-bsh">
    /home/wit/tmp/./ListFiles.class
    /home/wit/tmp/./ListFiles.java
    ... (решту випущено)
    </pre>

    <p>Зауважте, що метод <tt>list()</tt> не проходить рекурсивно по елементах в наданому <tt>Path</tt>. Для рекурсивного проходу каталогів можна використовувати метод <tt>Files.walk()</tt>:</p>

    <pre class="prettyprint lang-java">
    Files.walk(Paths.get(".")).forEach(System.out::println);
    </pre>

    <p>Метод <tt>Files.walk()</tt> це перевантажений метод:</p>

    <pre class="prettyprint lang-java">
    static Stream&lt;Path&gt; walk(Path path, FileVisitOption... options) throws IOException
    static Stream&lt;Path&gt; walk(Path path, int maxDepth, FileVisitOption... options) throws IOException
    </pre>

    <p><tt>FileVisitOption</tt> має одне значення перелічення: <tt>FileVisitOption.FOLLOW_LINKS</tt>. Його можна передати в метод <tt>walk()</tt>. Також можна вказати <tt>maxDepth</tt>: ліміт рівня вкладеності для рекурсивного проходу по лементах каталогу (дивись Лістинг <a href="#c10l13">10-13</a>).</p>

    <pre id="c10l13" class="prettyprint lang-java">
    // Лістинг 10-13. CountEntriesRecur.java
    import java.nio.file.FileVisitOption;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.io.IOException;
    import java.util.stream.Stream;

    class CountEntriesRecur {
    	public static void main(String []args) throws IOException {
    		try(Stream&lt;Path&gt; entries =
    				Files.walk(Paths.get("."), 4, FileVisitOption.FOLLOW_LINKS)) {
    			long numOfEntries = entries.count();
    			System.out.printf("Знайдено %d елементів в поточному шляху", numOfEntries);
    		}
    	}
    }
    </pre>

    <p>На моїй машині такий результат:</p>

    <pre id="out1014" class="prettyprint lang-bsh">
    $ java CountEntriesRecur 
    Знайдено 35 елементів в поточному шляху
    </pre>

    <p>Цей код задає ліміт для глибини вкладення рівним 4 - другий аргумент метода <tt>Files.walk()</tt>.</p>

    <p>Використаємо метод <tt>Files.find()</tt> для перелічення файлів, які відповідають наданій умові (Лістинг <a href="#c10l14">10-14</a>).</p>

    <pre id="c10l14" class="prettyprint lang-java">
    // Лістинг 10-14. FindFiles.java
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.io.IOException;
    import java.nio.file.attribute.BasicFileAttributes;
    import java.util.function.BiPredicate;
    import java.util.stream.Stream;

    class FindFiles {
    	public static void main(String []args) throws IOException {
    		BiPredicate&lt;Path, BasicFileAttributes&gt; predicate = (path, attrs)
    				-&gt; attrs.isRegularFile() && path.toString().endsWith("class");
    		try(Stream&lt;Path&gt; entries = Files.find(Paths.get("."), 4, predicate)) {
    			entries.limit(100).forEach(System.out::println);
    		}
    	}
    }
    </pre>

    <p>Приклад виводу:</p>

    <pre id="out1014" class="prettyprint lang-bsh">
    $ java FindFiles 
    ./ListFiles.class
    ./FindFiles.class
    </pre>

    <p>Цей приклад використовує метод <tt>limit()</tt> об'єкту <tt>Stream&lt;Path&gt;</tt> для обмеження кількості опрацьованих елементів при поверненні від метода <tt>Files.find()</tt>. Метод <tt>find()</tt> приймає як аргументи шлях для початку пошуку, максимальну глибину пошуку, <tt>BiPredicate</tt> та опціональний <tt>FileVisitOption</tt>:</p>

    <pre id="c10s07" class="prettyprint lang-java">
    static Stream&lt;Path&gt; find(Path path, int maxDepth, BiPredicate&lt;Path,BasicFileAttributes&gt; matcher, FileVisitOption... options) throws IOException
    </pre>

    <p>В цьому прикладі ми шукаємо файли, імена яких закінчуються на <tt>class</tt>, та обмежуємо кількість елементів до 100.</p>

    <h3>Використання методу <tt>lines()</tt> в класі <tt>Files</tt></h3>

    <p><tt>Files.lines()</tt> це дуже зручний метод читання вмісту файлу:</p>

    <pre id="c10s08" class="prettyprint lang-java">
    static Stream&lt;String&gt; lines(Path path)
    </pre>

    <p>Всередині він використовує <tt>Reader</tt>, отже має бути закритий після використання. В Лістингу <a href="#c10l15">10-15</a> для друку вмісту файла, ім'я якого надається як аргумент, ми використовуємо оператор try-with-resources.</p>

    <pre id="c10l15" class="prettyprint lang-java">
    // Лістинг 10-15. Type.java
    import java.io.IOException;
    import java.nio.file.Paths;
    import java.nio.file.Files;
    import java.util.Arrays;
    import java.util.stream.Stream;

    // реалізує спрощену версію команд "cat" (Windows: type );
    // отримує ім'я текстового файла як аргумент, друкує вміст файла(файлів)
    class Type {
    	private static void processFile(String file) {
    		try(Stream&lt;String&gt; lines = Files.lines(Paths.get(file))) {
    			lines.forEach(System.out::println);
    		} catch (IOException ioe) {
    			System.err.println("При читанні файла трапився IOException ... вихід");
    			System.exit(-1);
    		}
    	}

    	public static void main(String[] files) throws IOException {
    		if (files.length == 0) {
    			System.err.println("надайте ім'я файла(файлів) як аргумент");
    			System.exit(-1);
    		}
    		// обробити кожен файл, наданий як аргумент
    		Arrays.stream(files).forEach(Type::processFile);
    	}
    }
    </pre>

    <p>Цей код набагато коротший за версію з глави про базовий ввід-вивід (Лістинг <a href="../09/09-uk.html#c09l05">9-5</a> з Глави 9).</p>

    <h2>Підсумки</h2>

    <p>Коротко оглянемо ключові моменти кожної з поставлених цілей.</p>

    <p><b>Використання інтерфейсу <tt>Path</tt> для операцій над шляхами файлів та каталогів</b></p>

    <ul>
    	<li>Об'єкт <tt>Path</tt> це програмна абстракція для представлення шляху файла/каталога.</li>
    	<li>Можна отрмати екземпляр <tt>Path</tt> за допомогою метода <tt>get()</tt> класа <tt>Paths</tt>.</li>
    	<li><tt>Path</tt> пропонує два методи для порівняння об'єктів <tt>Path</tt>: <tt>equals()</tt> та <tt>compareTo()</tt>. Навіть якщо два об'єкти <tt>Path</tt> вказують на один файл/каталог, метод <tt>equals()</tt> не гарантує повернення <tt>true</tt>.</li>
    </ul>

    <p><b>Використання класу <tt>Files</tt> для перевірки, читання, видалення, копіювання, переміщення, управління мета-даними файла чи каталога</b></p>

    <ul>
    	<li>Можна перевірити існування файла за допомогою метода <tt>exists()</tt> класа <tt>Files</tt>.</li>
    	<li>Клас <tt>Files</tt> пропонує методи <tt>isReadable()</tt>, <tt>isWritable()</tt> та <tt>isExecutable()</tt> для перевірки можливостей програми для читання, звпису та програмного виконання відповідно.</li>
    	<li>Можна отримати атрибути файла за допомогою метода <tt>getAttributes()</tt>.</li>
    	<li>Можна використати метод <tt>readAttributes()</tt> класу <tt>Files</tt> для пакетного читання атрибутів файла.</li>
    	<li>Метод <tt>copy()</tt> можна використовувати для копіювання файла з одного місця в інше. Схоже, метод <tt>move()</tt> переміщує файл з одного місця в інше.</li>
    	<li>При копіюванні всі каталоги (за виключенням останнього, якщо копіюється каталог) мають існувати у вказаному шляху для уникнення <tt>NoSuchFileException</tt>.</li>
    	<li>Для видалення файла використовуйте метод <tt>delete()</tt>; для видалення файла лише за умови його існування використовуйте метод <tt>deleteIfExists()</tt>.</li>
    </ul>

    <p><b>Використання Stream API з NIO.2</b></p>

    <ul>
    	<li>Метод <tt>Files.list()</tt> повертає <tt>Stream&lt;Path&gt;</tt>. Він не робить рекурсивного проходу каталогів в наданому <tt>Path</tt>.</li>
    	<li>Метод <tt>Files.walk()</tt> повертає <tt>Stream&lt;Path&gt;</tt>, проходячи рекурсивно елементи в наданому <tt>Path</tt>; в одній з перевантажених версій можна передавати максимальну глибину для такого проходу та надавати як третю опцію <tt>FileVisitOption.FOLLOW_LINKS</tt>.</li>
    	<li>Метод <tt>Files.find()</tt> повертає <tt>Stream&lt;Path&gt;</tt>, отриманий рекурсивним проходженням елементів в наданому <tt>Path</tt>; він також приймає як аргументи максимальну глибину пошуку, <tt>BiPredicate</tt> та опціональний <tt>FileVisitOption</tt>.</li>
    	<li><tt>Files.lines()</tt> дуже зручний метод читання вмісті файлу. Він повертає <tt>Stream&lt;String&gt;</tt>.</li>
    </ul>

    <h1>Лекція 11</h1>
    <h1>Паралелізм Java</h1>

    <p>Цілі</p>

    <ul>
        <li>Створювати робочі потоки з використанням <tt>Runnable</tt> та <tt>Callable</tt>, а також використовувати <tt>ExecutorService</tt> для одночасного виконання завдань</li>
        <li>Виявляти потенційні проблеми з потоками типу "пасивний тупик" (deadlock), "брак ресурсів" (starvation), "активний тупик" (livelock) та "умови перегонів" (race conditions)</li>
        <li>Використовувати ключове слово <tt>synchronized</tt> та пакет <tt>java.util.concurrent.atomic</tt> для управління порядком виконання потоків</li>
        <li>Використовувати колекції та класи <tt>java.util.concurrent</tt>, включаючи <tt>CyclicBarrier</tt> та <tt>CopyOnWriteArrayList</tt></li>
        <li>Використовувати паралельний каркас <tt>Fork/Join</tt></li>
        <li>Використовувати паралельні потоки даних (<tt>Streams</tt>), включаючи зменшення, декомпозицію, злиття потоків, використання конвеєрів, та питання продуктивності</li>
    </ul>

    <p>Паралелізм набуває важливості з поширенням багатоядерних процесорів. Латинський корінь слова <i>concurrency</i> означає "бігти разом". При програмуванні можна мати багато потоків, які паралельно виконують в програмі різні задачі одночасно. При правильному використанні паралелізм може підвищити продуктивність та чуйність програми, тож це потужна та корисна властивість. Далі ми будемо використовувати терміни "багато-поточність" та "паралелізм" взаємозамінно.</p>

    <p>Спочатку Java підтримувала паралелізм в формі низькорівневого управління потоками, замків, синхронізації та API для паралелізму. Починаючи з версії 5.0, Java також підтримує високорівневі API для паралелізму в пакеті <tt>java.util.concurrent</tt>. Починаючи з версії 8.0, Java має ще кращу підтримку паралелізму завдяки введенню паралельних потоків даних.</p>


    <h2>Створення потоків для одночасного виконання завдань</h2>

    <p>Класи <tt>Thread</tt>, <tt>Object</tt> та інтерфейс <tt>Runnable</tt> надають необхідну підтримку паралелізму в Java. Клас <tt>Thread</tt> має такі методи, як <tt>run()</tt>, <tt>start()</tt> та <tt>sleep()</tt>, які стають у нагоді для забезпечення багато-поточності (в Таблиці <a href="#c11t01">11-1</a> перелічені важливі методи класу <tt>Thread</tt>). Клас <tt>Object</tt> має такі методи, як <tt>wait()</tt> та <tt>notify()</tt>, які підтримують паралелізм. Оскільки в Java кожен клас є потомком <tt>Object</tt>, тож всі об'єкти мають деякі основні багато-потокові можливості. Наприклад, в Java можна отримати блокування на будь-який об'єкт (за допомогою ключового слова <tt>synchronized</tt>, про що поговоримо трохи пізніше). Однак, для створення потоку цього базового рівня підтримки від  <tt>Object</tt> не достатньо. Для цього клас має розширювати клас <tt>Thread</tt>, або реалізувати інтерфейс <tt>Runnable</tt>. <tt>Thread</tt> та <tt>Runnable</tt> містяться в пакеті <tt>java.lang</tt>, тож для написання багато-поточних програм не потрібно імпортувати ці класи явно.</p>

    <table id="c11t01" border="1" cellpadding="2">
        <caption>Таблиця 11-1. Важливі методи класу <tt>Thread</tt></caption>
        <tr>
            <th>Метод</th>
            <th>Тип метода</th>
            <th>Короткий опис</th>
        </tr>
        <tr>
            <td><tt>Thread currentThread()</tt></td>
            <td>Статичний метод</td>
            <td>Повертає посилання на поточний потік.</td>
        </tr>
        <tr>
            <td><tt>String getName()</tt></td>
            <td>Метод екземпляра</td>
            <td>Повертає ім'я поточного потоку.</td>
        </tr>
        <tr>
            <td><tt>int getPriority()</tt></td>
            <td>Метод екземпляра</td>
            <td>Повертає значення пріоритету поточного потоку.</td>
        </tr>
        <tr>
            <td><tt>void join(), void join(long), void join(long, int)</tt></td>
            <td>Перевантажені методи екземпляра</td>
            <td>Поточний метод, який викликає приєднання до іншого потоку, очікує завершення того метода. Не обов'язково можна надати період очікування в мілісекундах (надається як <tt>long</tt>) чи в мілісекундах та наносекундах (надаються як <tt>long</tt> та <tt>int</tt>).</td>
        </tr>
        <tr>
            <td><tt>void run()</tt></td>
            <td>Метод екземпляра</td>
            <td>При запуску потоку (з використанням метода <tt>start()</tt>), метод <tt>run()</tt> буде викликаний, коли потік буде готовий до виконання.</td>
        </tr>
        <tr>
            <td><tt>void setName(String)</tt></td>
            <td>Метод екземпляра</td>
            <td>Змінює ім'я потоку на надане в аргументі.</td>
        </tr>
        <tr>
            <td><tt>void setPriority(int)</tt></td>
            <td>Метод екземпляра</td>
            <td>Встановлює пріоритет потоку в надане аргументом значення.</td>
        </tr>
        <tr>
            <td><tt>void sleep(long)<br/>
            void sleep(long, int)</tt></td>
            <td>Перевантажені статичні методи</td>
            <td>Заморожує поточний потік на завдану кількість мілісекунд (надається як <tt>long</tt>) або мілісекунд та наносекунд (надаються як <tt>long</tt> та <tt>int</tt>).</td>
        </tr>
        <tr>
            <td><tt>void start()</tt></td>
            <td>Метод екземпляра</td>
            <td>Запускає потік; JVM викликає метод <tt>run()</tt> потоку.</td>
        </tr>
        <tr>
            <td><tt>String toString()</tt></td>
            <td>Метод екземпляра</td>
            <td>Повертає строкове представлення потоку; рядок має ім'я, пріоритет та групу потоку.</td>
        </tr>
    </table>

    <h3>Створення потоків</h3>

    <p>Спробуємо створювати потоки з використанням класу <tt>Thread</tt> та інтерфейсу <tt>Runnable</tt>. А потім розглянемо, як створювати робочі потоки з використанням <tt>Callable</tt> та <tt>ExecutorService</tt>.</p>

    <h4>Творення потоків через розширення класу <tt>Thread</tt></h4>

    <p>Для розширення класу <tt>Thread</tt> треба перевизначити метод <tt>run()</tt>. Якщо метод <tt>run()</tt> не перевизначити, буде викликаний метод <tt>run()</tt> класу <tt>Thread</tt> по замовчанню, який не робить нічого. Для пере-визначення метода <tt>run()</tt> треба оголосити його як <tt>public</tt>; він не приймає аргументів та повертає тип <tt>void</tt>; тобто, він має бути оголошений як <tt>public void run()</tt>.</p>

    <p>Створити потік можна, викликавши метод <tt>start()</tt> на об'єкті класа <tt>Thread</tt> (Лістинг <a href="#c11l01">11-1</a>). Коли JVM запланує потік, вона перемістить потік в стан виконання, а потім виконає метод <tt>run()</tt>. По завершенні метода <tt>run()</tt> та поверненні виконання потік завершиться.</p>

    <pre id="c11l01" class="prettyprint lang-java">
    // Лістинг 11-1. MyThread.java
    class MyThread extends Thread {
        public void run() {
            try {
                sleep(1000);
            }
            catch (InterruptedException ex) {
                ex.printStackTrace();
                // ігноруємо InterruptedException - це одне з небагатьох
                // виключень в Java, які можна ігнорувати
            }
            System.out.println("Всередині run(); потік: " + getName());
        }

        public static void main(String args[]) {
            Thread myThread = new MyThread();
            myThread.start();
            System.out.println("Всередині main(); потік: " +
                    Thread.currentThread().getName());
        }
    }
    </pre>

    <p>Ця програма надрукує:</p>

    <pre id="out1101" class="prettyprint lang-bsh">
    Всередині main(); потік: main
    Всередині run(); потік: Thread-0
    </pre>

    <p>В цьому прикладі клас <tt>MyThread</tt> розширює клас <tt>Thread</tt>. Ми перевизначаємо метод <tt>run()</tt> цього класа. Цей метод <tt>run()</tt> буде викликаний при запуску потока. В функції <tt>main()</tt> ми створюємо новий потік та запускаємо його за допомогою метода <tt>start()</tt>. Важливе зауваження: не треба безпосередньо викликати метод <tt>run()</tt>. Замість цього потік запускається за допомогою метода <tt>start()</tt>; метод <tt>run()</tt> викликається автоматично самою JVM.</p>

    <p>Для друку імені потока мжна використовувати метод екземпляра <tt>getName()</tt>, який повертає <tt>String</tt>. Оскільки <tt>main()</tt> це статичний метод, ми не маємо доступу до цього посилання. Тож ми отримуємо ім'я поточного потока за допомогою статичного метода <tt>currentThread()</tt> в класі <tt>Thread</tt> (який повертає об'єкт <tt>Thread</tt>). Тепер можна викликати <tt>getName</tt> на цьому повернутому об'єкті. Як ми побачимо пізніше, метод <tt>main()</tt> також виконується як потік! Однак, всередині метода <tt>run()</tt>, можна викликати метод <tt>getName()</tt> напряму: <tt>MyThread</tt> розширює <tt>Thread</tt>, отже всі члени базового класа доступні також в <tt>MyThread</tt>.</p>

    <h4>Створення потоків через реалізацію інтерфейса <tt>Runnable</tt></h4>

    <p>Інший спосіб створити потік - це реалізувати інтерфейс <tt>Runnable</tt>. Клас <tt>Thread</tt> сам реалізує інтерфейс <tt>Runnable</tt>. Інтерфейс <tt>Runnable</tt> оголошує єдиний метод <tt>run()</tt>. Отже, коли ми реалізуємо інтерфейс <tt>Runnable</tt>, нам потрібно визначити метод <tt>run()</tt>. Пам'ятайте, що <tt>Runnable</tt> не оголошує метод <tt>start()</tt>. Як же створити потік через реалізацію інтерфейса <tt>Runnable</tt>? <tt>Thread</tt> має перевантажений конструктор, який приймає як аргумент об'єкт <tt>Runnable</tt>. Лістинг <a href="#c11l02">11-2</a> реалізує інтерфейс <tt>Runnable</tt> та створює <tt>Thread</tt>.</p>

    <pre id="c11l02" class="prettyprint lang-java">
    // Лістинг 11-2. RunnableImpl.java
    class RunnableImpl implements Runnable {
        public void run() {
            System.out.println("Всередині run(); потік: " +
                    Thread.currentThread().getName());
        }

        public static void main(String args[]) throws Exception {
            Thread myThread = new Thread(new RunnableImpl());
            myThread.start();
            System.out.println("Всередині main(); потік: " +
                    Thread.currentThread().getName());
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre id="out1002" class="prettyprint lang-bsh">
    Всередині main(); потік: main
    Всередині run(); потік: Thread-0
    </pre>

    <p>В цій програмі ми реалізуємо метод <tt>run()</tt>. Однак, для отримання імені потоку треба йти кружним шляхом та отримати його через <tt>Thread.currentThread().getName()</tt>. В методі <tt>main()</tt> для створення потока маємо передати об'єкт класа <tt>RunnableImpl</tt> в конструктор класа <tt>Thread</tt>. Метод <tt>start()</tt> запускає потік, я JVM потім викликає метод <tt>run()</tt> цього потока.</p>

    <h2>Синхронізація потоків з використанням ключового слова <tt>synchronized</tt></h2>

    <p>Ключове слово Java <tt>synchronized</tt> допомагає при синхронізації потоків. Його можна використовувати в двох формах: синхронізованих блоках та синхронізованих методах. Навіщо використовувати ключове слово <tt>synchronized</tt>? Для запобігання проблем з умовами перегонів (race conditions). Обговоримо це.</p>

    <h3>Умови перегонів (Race Conditions)</h3>

    <p>Потоки мають спільні ділянки пам'яті та можуть паралельно змінювати дані. Оскільки можливі одночасні зміни без будь-яких гарантій, це може призвести до непередбачуваних результатів.</p>

    <p>Коли два чи більше потоків намагаються отримати доступ до змінної та один з них хоче змінити її, ми стикаємося з проблемою, відомою як <i>умови перегонів (race condition)</i> (також відома під іменем <i>перегони за даними (data race)</i> чи <i>небезпека перегонів (race hazard)</i>). Лістинг <a href="#c11l03">11-3</a> показує приклад умови перегонів.</p>

    <pre id="c11l03" class="prettyprint lang-java">
    // Лістинг 11-3. RaceCondition.java

    // Цей клас показує публічно доступний лічильник
    // щоб допомогти продемонструвати проблему умови перегонів
    class Counter {
        public static long count = 0;
    }

    // Цей клас реалізує інтерфейс Runnable
    // Його метод run тричі збільшує лічильник на одиницю
    class UseCounter implements Runnable {
        public void increment() {
            // збільшує лічильник та друкує значення
            // лічильника, який розділяють ріжні потоки
            Counter.count++;
            System.out.print(Counter.count + " ");
        }

        public void run() {
            increment();
            increment();
            increment();
        }
    }

    // Цей клас створює три потоки
    public class RaceCondition {
        public static void main(String args[]) {
            UseCounter c = new UseCounter();
            Thread t1 = new Thread(c);
            Thread t2 = new Thread(c);
            Thread t3 = new Thread(c);
            t1.start();
            t2.start();
            t3.start();
        }
    }
    </pre>

    <p>В цій програмі є клас <tt>Counter</tt>, який має статичну змінну <tt>count</tt>. В методі <tt>run()</tt> класа <tt>UseCounter</tt> ми тричі збільшуємо <tt>count</tt>, викликаючи метод <tt>increment()</tt>. Ми створюємо три потоки в функції <tt>main()</tt> всередині класа <tt>RaceCondition</tt> та запускаємо їх. Ми очікуємо, що програма друкуватиме послідовно від <tt>1</tt> до <tt>9</tt> по мірі того, як виконується потоки та збільшується лічильник. Однак, при запуску ця програма друкує дев'ять цілих значень, але вивід виглядає сміттям! Наприклад:</p>

    <pre id="out1003-1" class="prettyprint lang-bsh">3 3 5 6 3 7 8 4 9</pre>

    <p>Зауважте, що значення будуть різними при кожному запуску програми; після двох-трьох виконань отримаємо такий вивід:</p>

    <pre id="out1003-2" class="prettyprint lang-bsh">
    3 3 5 6 3 4 7 8 9
    3 3 3 6 7 5 8 4 9
    </pre>

    <p>Тож в чому проблема?</p>

    <p>Вираз <tt>Counter.count++</tt> - це операція запису, а наступний оператор <tt>System.out.print</tt> має операцію читання <tt>Counter.count</tt>. Коли три потоки виконуються, кожен з них має локальну копію значення <tt>Counter.count</tt>, та коли вони змінюють лічильник через <tt>Counter.count++</tt>, вони можуть не встигнути негайно відобразити це значення в основній пам'яті (дивись Рисунок <a href="#c11f01">11-1</a>). В наступній операції читання <tt>Counter.count</tt> друкується локальне значення <tt>Counter.count</tt>.</p>

    <p><img id="c11f01" alt="Рисунок 11-1. Потоки t1, t2 та t3 намагаються змінити Counter.count, викликаючи умову перегонів" src="img/c11f01.png"/><br/>
    <strong>Рисунок 11-1</strong>. Потоки <tt>t1</tt>, <tt>t2</tt> та <tt>t3</tt> намагаються змінити <tt>Counter.count</tt>, викликаючи умову перегонів</p>

    <p>Отже, ця програма страждає через проблему умови перегонів. Для уникнення цієї проблеми треба гарантувати, що окремий потік виконує операції запису та читання разом (атомарно). Ділянка коду, в якій операції запису загальних даних виконують декілька потоків, називається критичною ділянкою. Для уникнення проблеми умови перегонів треба гарантувати, що критична ділянка виконується лише одним потоком в один момент часу.</p>

    <p>Як це зробити? Шляхом отримання блокування на об'єкті за допомогою ключового слова <tt>synchronized</tt>, про що зараз й поговоримо. Отримати блокування на об'єкт в один момент часу може лише один потік, та лише він може виконувати блок коду (тобто, критичну ділянку), захищений цим блокуванням. Інші потоки мають очікувати.</p>

    <h4>Синхронізовані блоки</h4>

    <p>В синхронізованих блоках ми використовуємо ключове слово <tt>synchronized</tt> для посилальної змінної з наступним блоком коду. Потік має отримати блокування синхронізованої змінної для входження в блок; при завершенні виконання блоку потік вивільніє блокування. Наприклад, можна отримати блокування на посилання <tt>this</tt>, якщо блок коду знаходиться всередині не-статичного метода:</p>

    <pre id="c11s01" class="prettyprint lang-java">
    synchronized(this) {
        // фрагмент коду, захищений замком
    }
    </pre>

    <p>А якщо всередині синхронізованого блока виникне виняток? Чи вивільниться блокування? Так, поза залежністю від того, чи виконався блок повністю, чи виник виняток, блокування автоматично вивільниться самою JVM. За допомогою синхронізованих блоків можна отримувати блокування лише на посилальні змінні. При використанні примітивних типів отримаємо помилку компіляції.</p>

    <p>Тож виправимо проблему умови перегонів в лістингу <a href="#c11l03">11-3</a>, додавши синхронізований блок в метод <tt>increment()</tt>:</p>

    <pre id="c11s02" class="prettyprint lang-java">
    // всередині класа UseCounter
    public void increment() {
        // збільшує лічильник та друкує значення
        // лічильника, який розділяють різні потоки
        synchronized(this) {
            Counter.count++;
            System.out.print(Counter.count + " ");
        }
    }
    </pre>

    <p>З цими змінами програма друкує значення лічильника правильно:</p>

    <pre id="out1103-1" class="prettyprint lang-bsh">1 2 3 4 5 6 7 8 9</pre>

    <p>В методі <tt>increment()</tt> ми отримуємо блокування на посилання <tt>this</tt> перед читанням та записом <tt>Counter.count</tt>. Отже, не можливо, щоб більше одного потоку виконувало ці оператори одночасно. Оскільки лише один потік може отримати блокування та виконувати блок коду "критичної ділянки", лічильник збільшується лише одним потоком в один момент часу; в результаті програма друкує значення від <tt>1</tt> до <tt>9</tt> правильно. Без синхронізованих блоків три різні потоки можуть вільно змінювати змінну, тож ми не отримаємо правильний вивід значень від <tt>1</tt> до <tt>9</tt> (внаслідок згаданої раніше проблеми <i>умови перегонів</i>).</p>

    <h4>Синхронізовані методи</h4>

    <p>Можна оголосити синхронізованим цілий метод. В такому випадку - коли викликається метод, оголошений як синхронізований, - отримується блокування на об'єкті, метод якого викликається, а вивільняється блокування, коли метод повертає виконання в місце виклику. Приклад:</p>

    <pre id="c11s03" class="prettyprint lang-java">
    public synchronized void assign(int i) {
        val = i;
    }
    </pre>

    <p>Тепер метод <tt>assign()</tt> є синхронізованим методом. Якщо викликати метод <tt>assign()</tt>, він неявно отримає блокування на посилання <tt>this</tt> та виконає оператор <tt>val = i;</tt>. Що трапиться, якщо інший потік вже отримав блокування? Як у випадку з синхронізованими блоками, якщо потік не може отримати блокування, від сам буде <em>заблокований</em> та очікуватиме, доки блокування стане доступним.</p>

    <p>Синхронізований метод еквівалентний до синхронізованого блоку, якщо в блок <tt>synchronized(this)</tt> вкласти все тіло метода. Тобто, еквівалент метода <tt>assign()</tt> з використанням синхронізованого блоку це</p>

    <pre id="c11s04" class="prettyprint lang-java">
    public void assign(int i) {
        synchronized(this) {
            val = i;
        }
    }
    </pre>

    <p>Можна оголосити синхронізованими статичні методи. А на яке посилання має бути отримане блокування? Статичні методи не мають неявного посилання <tt>this</tt>. Статичні синхронізовані методи отримують блокування на класовий об'єкт. Кожен клас асоційований з об'єктом типу <tt>Class</tt>, до якого можна отримати доступ за допомогою синтаксиса <tt>ClassName.class</tt>. Наприклад,</p>

    <pre id="c11s05" class="prettyprint lang-java">
    class SomeClass {
        private static int val;
        public static synchronized void assign(int i) {
            val = i;
        }
        // інші члени ...
    }
    </pre>

    <p>Тут метод <tt>assign</tt> при виклику отримує блокування на об'єкті <tt>SomeClass.class</tt>. Тепер еквівалент метода <tt>assign()</tt> з використанням синхронізованих блоків може бути записаний як</p>

    <pre id="c11s06" class="prettyprint lang-java">
    class SomeClass {
        private static int val;
        public static void assign(int i) {
            synchronized(SomeClass.class) {
                val = i;
            }
        }
        // інші члени ...
    }
    </pre>

    <p>Не можна оголошувати синхронізованими конструктори; це призведе до помилки компіляції. Наприклад</p>

    <pre id="c11s07" class="prettyprint lang-java">
    class Synchronize {
        public synchronized Synchronize() { /* constructor body */}
        // інші члени
    }
    </pre>

    <p>призведе до помилки:</p>

    <pre id="c11s07out" class="prettyprint lang-bsh">
    Synchronize.java:2: modifier synchronized not allowed here
            public synchronized Synchronize() { /* constructor body */}     
    </pre>

    <p>Чому не можливо оголосити конструктор синхронізованим? JVM гарантує, що лише один потік може викликати конструктор (окремий конструктор) в один момент часу. Отже, немає потреби оголошувати конструктор синхронізованим. Однак, за бажанням, можна використовувати синхронізовані блоки всередині конструкторів.</p>

    <p>Повернемося до прикладу <tt>RaceCondition</tt> в лістингу <a href="#c11l03">11-3</a>. Метод <tt>increment()</tt> в класі <tt>UseCounter</tt> також можна переписати як синхронізований метод:</p>

    <pre id="c11s08" class="prettyprint lang-java">
    // оголошення синхронізованого increment замість використання
    // оператора synchronized в блоці коду всередині метода
    public synchronized void increment() {
        Counter.count++;
        System.out.print(Counter.count + " ");
    }       
    </pre>

    <p>Ця програма друкує:</p>

    <pre id="c11s08out" class="prettyprint lang-bsh">1 2 3 4 5 6 7 8 9</pre>

    <p>Програма коректно друкує очікуваний вивід.</p>

    <p><hr/>Початківці зазвичай хибно вважають, що синхронізований блок отримує блокування на блок коду. Насправді блокування отримується на об'єкт, а не на фрагмент коду. Отримане блокування утримується доки всі оператори в тому блоці завершать виконання.<hr/></p>

    <h2>Проблеми з потоками</h2>

    <p>Паралельне програмування потоків супроводжується проблемами. Ми вже обговорили умови перегонів, які трапляються, коли не використовуються блокування. Тепер обговоримо ще три проблеми з потоками: пасивний тупик, брак ресурсів та активний тупик.</p>

    <h3>Пасивні тупики</h3>

    <p>Отримання та використання блокувань може призвести до багатьох проблем. Одна з найскладніших та загальних) проблем відома як <i>пасивний тупик (deadlock)</i>. <i>Пасивний тупик виникає, коли блокуючий потік потрапляє в ситуацію, в якій він не може продовжувати виконання, та вимушений невизначено довго очікувати завершення інших</i>. Припустимо, один потік отримує блокування на ресурс <tt>r1</tt> та очікує отримання блокування на інший ресурс <tt>r2</tt>. В той самий час інший потік вже отримав <tt>r2</tt> та чекає отримання блокування на <tt>r1</tt>. Жоден з потоків не може продовжувати доки інший не вивільнить блокування, що не трапиться ніколи - отже вони потрапили в пасивний тупик. Лістинг <a href="#c11l04">11-4</a> показує, як така ситуація може трапитися (з використанням прикладу гри Cricket).</p>

    <pre id="c11l04" class="prettyprint lang-java">
    // Лістинг 11-4. DeadLock.java

    // Клас Balls має глобально доступний член даних для збереження кількості м'ячів
    class Balls {
        public static long balls = 0;
    }

    // Клас має глобально доступний член даних для збереження кількості зарахованих спроб
    class Runs {
        public static long runs = 0;
    }

    // Клас Counter має два методи - IncrementBallAfterRun та IncrementRunAfterBall.
    // Для демонстрації пасивного тупика викликаємо ці два методи в методі run, таким чином, 
    // щоб блокування запрошувалося в цих методах в зворотньому порядку
    class Counter implements Runnable {
        // цей метод збільшує спочатку змінну runs, а потім - змінну balls
        // оскільки ці змінні доступні з інших потоків,
        // перед їх обробкою треба отримати блокування
        public void IncrementBallAfterRun() {
            // оскільки спочатку змінюється змінна runs, спочатку заблокуємо Runs.class
            synchronized(Runs.class) {
                // блокування на Balls.class перед зміненням змінної balls
                synchronized(Balls.class) {
                    Runs.runs++;
                    Balls.balls++;
                }
            }
        }

        public void IncrementRunAfterBall() {
            // оскільки спочатку змінна balls, то спочатку блокується Balls.class
            synchronized(Balls.class) {
                // отримати блокування на Runs.class перед зміненням змінної runs
                synchronized(Runs.class) {
                    Balls.balls++;
                    Runs.runs++;
                }
            }
        }

        public void run() {
            // виклик цих двох методів, які отримують блокування в різному порядку
            // в залежності від планування потоків та порядку блокування
            // пасивний тупик може трапитися, а може й ні
            IncrementBallAfterRun();
            IncrementRunAfterBall();
        }
    }

    public class DeadLock {
        public static void main(String args[]) throws InterruptedException {
            Counter c = new Counter();
            // створити два потоки та запустити їх одночасно
            Thread t1 = new Thread(c);
            Thread t2 = new Thread(c);
            t1.start();
            t2.start();
            System.out.println("Чекаємо завершення виконання потоків...");
            t1.join();
            t2.join();
            System.out.println("Done.");
        }
    }
    </pre>

    <p>Якщо запустити цю програму, вона може виконатися добре, а може трапитися пасивний тупик, та вони ніколи не завершиться (поява пасивного тупика в цій програмі залежить від того, як плануються потоки).</p>

    <pre id="c11l04out" class="prettyprint lang-bsh">
    $ java DeadLock
    Чекаємо завершення виконання потоків...
    Done.
        
    $ java DeadLock
    Чекаємо завершення виконання потоків...
    [deadlock – user pressed ctrl + c to terminate the program]
        
    $ java DeadLock
    Чекаємо завершення виконання потоків...
    Done.
    </pre>

    <p>В цьому прикладі два класи: <tt>Balls</tt> та <tt>Runs</tt> зі статичними членами <tt>balls</tt> та <tt>runs</tt>. Клас <tt>Counter</tt> має два методи: <tt>IncrementBallAfterRun()</tt> та <tt>IncrementRunAfterBall()</tt>. Вони отримують блокування на <tt>Balls.class</tt> та <tt>Runs.class</tt> у зворотньому порядку. Метод <tt>run()</tt> послідовно викликає ці два методи. Метод <tt>main()</tt> в класі <tt>Dead</tt> сворює два потоки та запускає їх.</p>

    <p>Коли потоки <tt>t1</tt> та <tt>t2</tt> виконуються, вони викликають методи <tt>IncrementBallAfterRun</tt> та <tt>IncrementRunAfterBall</tt>. В цих методах блокування отримуються у зворотньому порядку. Може трапитися, що <tt>t1</tt> отримає блокування на <tt>Runs.class</tt>, та потім стане очікувати отримання блокування на <tt>Balls.class</tt>. В той час, <tt>t2</tt> може мати отриманий <tt>Balls.class</tt> та тепер очікувати отримання блокування на <tt>Runs.class</tt>. Таким чином, ця програма може призвести до пасивного тупика (Рисунок <a href="#c11f02">11-2</a>).</p>

    <p><img id="c11f02" src="img/c11f02.png" alt="Рисунок 11-2. Пасивний тупик між потоками t1 та t2"/><br/>
    <strong>Рисунок 11-2</strong>. Пасивний тупик між потоками <tt>t1</tt> та <tt>t2</tt></p>

    <p>Не можна гарантувати, що програма призводитиме до пасивного тупику кожного разу. Чому? Послідовність виконання потоків ніколи не відома, як і порядок, в якому вони отримують та вивільняють блокування. За цієї причини такі проблеми, як кажуть, не-детерміністичні, їх не можна відтворювати послідовно.</p>

    <p>Існують різні стратегії боротьби з пасивними тупиками: запобігання, уникнення або виявлення. Що корисно знати про пасивні тупики:</p>

    <ul>
        <li>Пасивні тупики виникають в контексті багатьох блокувань.</li>
        <li>Ящо багато блокувань отримані в одному порядку, то пасивний тупик не трапиться; а якщо блокування отримувати в різному порядку, пасивний тупик трапитися може.</li>
        <li>Паивні тупики (як і інші багато-потокові проблеми) не-детерміністичні; не можна послідовно відтворювати пасивні тупики.</li>
    </ul>

    <p><hr/>Уникайте отримання багатьох блокувань. Якщо потрібно отримати багато блокувань, упевніться, що вони всюди отримуються в однаковому порядку.<hr/></p>

    <h3>Активні тупики</h3>

    <p>Для допомоги у розумінні активних тупиків звернемося до аналогії. Є два безпілотні автомобілі по різі кінці вузького мосту, запрограмовані таким чином, щоб пропускати інше авто. При спробі обох автомобілів заїхати на міст може траитися ситуація: кожне авто починає рух на міст, помічає аналогічну спробу іншого авто та повертає! Зауважте, що автомобілі рухаються вперед та назад, складаючи враження виконання роботи, хоча у жодного немає прогреса. Така ситуація називається <i>активним тупиком (livelock)</i>.</p>

    <p>Розглянемо два потоки <tt>t1</tt> та <tt>t2</tt>. Припустимо, що потік <tt>t1</tt> робить якесь змінення, а потік <tt>t2</tt> відміняє це змінення. Коли обидва потоки <tt>t1</tt> та <tt>t2</tt> працюють, це виглядає як виконання роботи, але насправді прогресу немає. Ця ситуація називається <i>активним тупиком в потоках (livelock in threads)</i>.</p>

    <p>Схожість між активними та пасивними потоками полягає в тому, що процес "підвисає" та програма ніколи не закінчується. Однак, при пасивному тупику потоки застрягають в одному стані, очікуючи вивільнення спільного ресурса іншим потоком, а при активному тупику потоки продовжують виконувати завдання, постійно змінюючи стани процеса, але програма в цілому не рухається з місця.</p>

    <h3>Брак блокувань</h3>

    <p>Розглянемо ситуацію, в якій багато потоків мають різні призначені їм пріоритети (в діапазоні від найнижчого 1 до найвищого 10 - це діапазон припустимих пріоритетів в Java). Коли блокування доступне, планувальник потоків надасть перевагу потокам з вищими пріоритетами. Якщо є багато високо-пріоритетних потоків, які хочуть отримати блокування та тримати його довго, то коли низько-пріоритетні потоки матимуть шанс отримати блокування? Іншими словами, ситуація, коли низько-пріоритетні потоки "голодують" протягом довгого часу, намагаючись отримати блокування, відома як <i>брак блокувань (lock starvation)</i>.</p>

    <p>Для виявлення чи уникнення таких проблем з потоками, як активні тупики та брак блокувань, існує багато технік, розгляд яких лежить поза межами нашої уваги.</p>

    <h2>Використання пакета <tt>java.util.concurrent.atomic</tt></h2>

    <p>Пакет <tt>java.util.concurrent</tt> має два під-пакети: <tt>java.util.concurrent.atomic</tt> та <tt>java.util.concurrent.locks</tt>. В цьому розділі обговоримо атомарні змінні в пакеті<tt>java.util.concurrent.atomic</tt>.</p>

    <p>Чи часто доводилося бачити код, який отримує та вивільняє блокування для реалізації таких примітивних/простих операцій, як інкремент чи декремент змінної? (Ми вже бачили приклад інкременту цілої змінної при обговоренні ключового слова <tt>synchronized</tt> раніше в цій главі). Отримання та вивільнення блокувань для таких примітивних операцій не ефективне. Для таких випадків Java пропонує ефективну альтернативу у вигляді атомарних змінних.</p>

    <p>Нижче наведено перелік декількох класів цього пакета та їх короткі описи:</p>

    <ul>
        <li><tt>AtomicBoolean</tt>: Атомарно змінюване значення <tt>Boolean</tt>.</li>
        <li><tt>AtomicInteger</tt>: Атомарно змінюване значення <tt>int</tt>; породжене від класа <tt>Number</tt>.</li>
        <li><tt>AtomicIntegerArray</tt>: Масив <tt>int</tt>, елементи якого можуть бути змінені атомарно.</li>
        <li><tt>AtomicLong</tt>: Атомарно змінюване значення <tt>long</tt>; породжене від класа <tt>Number</tt>.</li>
        <li><tt>AtomicLongArray</tt>: Масив <tt>long</tt>, елементи якого можуть бути змінені атомарно.</li>
        <li><tt>AtomicReference&lt;V&gt;</tt>: Атомарно змінюване об'єктне посилання типу <tt>V</tt>.</li>
        <li><tt>AtomicReferenceArray&lt;E&gt;</tt>: Атомарно змінюваний масив, який може містити об'єктні посилання типу <tt>E</tt> (<tt>E</tt> означає базовий тип елементів).</li>
    </ul>

    <p><hr/>Лише <tt>AtomicInteger</tt> та <tt>AtomicLong</tt> розширюють клас <tt>Number</tt>, але не <tt>AtomicBoolean</tt>. Всі інші класи під-пакета <tt>java.util.concurrent.atomic</tt>, аслідують прямо від класу <tt>Object</tt>.<hr/></p>

    <p>Серед класів під-пакета <tt>java.util.concurrency.atomic</tt> <tt>AtomicInteger</tt> та <tt>AtomicLong</tt> найбільш важливі. В таблиці <a href="#c11t02">11-2</a> перелічені важливі методи класа <tt>AtomicInteger</tt>. (Методи <tt>AtomicLong</tt> аналогічні.)</p>

    <table id="c11t02" border="1" cellpadding="2">
        <caption>Таблиця 11-2. Важливі методи класа <tt>AtomicInteger</tt></caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
        </tr>
        <tr>
            <td><tt>AtomicInteger()</tt></td>
            <td>Створює екземпляр <tt>AtomicInteger</tt> з початковим значенням <tt>0</tt>.</td>
        </tr>
        <tr>
            <td><tt>AtomicInteger(int initVal)</tt></td>
            <td>Створює екземпляр <tt>AtomicInteger</tt> з початковим значенням <tt>initVal</tt>.</td>
        </tr>
        <tr>
            <td><tt>int get()</tt></td>
            <td>Повертає ціле значення, яке зберігається в цьому об'єкті.</td>
        </tr>
        <tr>
            <td><tt>void set(int newVal)</tt></td>
            <td>Встановлює ціле значення об'єкта в <tt>newVal</tt>.</td>
        </tr>
        <tr>
            <td><tt>int getAndSet(int newValue)</tt></td>
            <td>Повертає поточне значення <tt>int</tt> об'єкта та встановлює значення об'єкта в <tt>newVal</tt>.</td>
        </tr>
        <tr>
            <td><tt>boolean compareAndSet(int expect, int update)</tt></td>
            <td>Порівнює значення <tt>int</tt> об'єкта із значенням <tt>expect</tt> та, якщо вони рівні, встановлює значення <tt>int</tt> цього об'єкта в значення <tt>update</tt>.</td>
        </tr>
        <tr>
            <td><tt>int getAndIncrement()</tt></td>
            <td>Повертає поточне ціле значення об'єкта та інкрементує ціле значення об'єкта. Схожий за поведінкою на <tt>i++</tt>, де <tt>i</tt> це <tt>int</tt>.</td>
        </tr>
        <tr>
            <td><tt>int getAndDecrement()</tt></td>
            <td>Повертає поточне ціле значення об'єкта та декрементує ціле значення об'єкта. Схожий за поведінкою на <tt>i--</tt>, де <tt>i</tt> це <tt>int</tt>.</td>
        </tr>
        <tr>
            <td><tt>int getAndAdd(int delta)</tt></td>
            <td>Повертає ціле значення об'єкта та додає значення <tt>delta</tt> до цілого значення об'єкта.</td>
        </tr>
        <tr>
            <td><tt>int incrementAndGet()</tt></td>
            <td>Інкрементує поточне значення цілого в об'єкті та повертає це значення. Схожий за поведінкою на <tt>++i</tt>, де <tt>i</tt> це <tt>int</tt>.</td>
        </tr>
        <tr>
            <td><tt>int decrementAndGet()</tt></td>
            <td>Декрементує поточне значення цілого в об'єкті та повертає це значення. Схожий за поведінкою на <tt>--i</tt>, де <tt>i</tt> це <tt>int</tt>.</td>
        </tr>
        <tr>
            <td><tt>int addAndGet(int delta)</tt></td>
            <td>Додає значення <tt>delta</tt> до поточного цілого значення об'єкта та повертає це значення.</td>
        </tr>
        <tr>
            <td><tt>int intValue()<br/>
                long longValue()<br/>
                float floatValue()<br/>
                double doubleValue()</tt></td>
            <td>Приводить тип цілого значення об'єкта <tt>int</tt> та повертає його як значення <tt>int</tt>, <tt>long</tt>, <tt>float</tt> чи <tt>double</tt> values.</td>
        </tr>
    </table>

    <p>Розглянемо на прикладі, як використовувати <tt>AtomicInteger</tt> чи <tt>AtomicLong</tt>. Припустимо, в нас є значення лічильника, яке публічне та доступне всім потокам. Як безпечно без потрапляння в умови перегонів (обговорювалося вище в цій главі) змінювати чи отримувати значення цього спільного лічильника? Очевидно, можна використовувати ключове слово <tt>synchronized</tt> для забезпечення того, що критична ділянка (код, який змінює значення лічильника) виконується лише одним потоком в один момент часу. Критична ділянка має бути дуже малою:</p>

    <pre>   
    public void run() {
        synchronized(SharedCounter.class) {
            SharedCounter.count++;
        }
    }
    </pre>

    <p>Цей код не ефективний оскільки він отримую та вивільняє блокування кожен раз лише для інкременту значення лічильника. Натомість можна оголосити лічильник як <tt>AtomicInteger</tt> чи <tt>AtomicLong</tt> (що більш підходить). Такі класи як <tt>AtomicInteger</tt> не використовують блокування; натомість вони використовують змінні та низькорівневий механізм, відомий як <em>Порівняй-та-Встанови (Compare-And-Set, CAS)</em>. З цієї причини використання класа <tt>AtomicInteger</tt> та відповідних класів є більш швидким у порівнянні з використанням блокувань за допомогою ключового слова <tt>synchronized</tt>.</p>

    <p>Лістинг <a href="#c11l05">11-5</a> показує використання <tt>AtomicLong</tt> на практиці.</p>

    <pre id="c11l05" class="prettyprint lang-java">
    // Лістинг 11-5. AtomicVariableTest.java
    import java.util.concurrent.atomic.AtomicInteger;

    // Клас для демонстрації того, що змінення "звичайних" (тобто, небезпечних в потоках)
    // та змінення "атомарних" (тобто, безпечних в потоках) цілих відрізняється:
    // Змінення спільного об'єкта Integer без блокувань може привести до умови перегонів;
    // а змінення спільного AtomicInteger не призведе до цього.
    class Counter {
        public static Integer integer = Integer.valueOf(0);
        public static AtomicInteger atomicInteger = new AtomicInteger(0);
    }

    class AtomicVariableTest {
        static class Incrementer extends Thread {
            public void run() {
                Counter.integer++;
                Counter.atomicInteger.incrementAndGet();
            }
        }

        static class Decrementer extends Thread {
            public void run() {
                Counter.integer--;
                Counter.atomicInteger.decrementAndGet();
            }
        }

        public static void main(String []args) throws InterruptedException {
            Thread incremeterThread[] = new Incrementer[1000];
            Thread decrementerThread[] = new Decrementer[1000];
            for(int i = 0; i < 1000; i++) {
                incremeterThread[i] = new Incrementer();
                decrementerThread[i] = new Decrementer();
                incremeterThread[i].start();
                decrementerThread[i].start();
            }
            for(int i = 0; i < 1000; i++) {
                incremeterThread[i].join();
                decrementerThread[i].join();
            }
            System.out.printf("Integer = %d AtomicInteger = %d ",
            Counter.integer, Counter.atomicInteger.get());
        }
    }
    </pre>

    <p>Вивід залежить від планування потоків. Різні запуски надрукують наступне:</p>

    <pre id="c11l05out" class="prettyprint lang-bsh">
    Integer = 0 AtomicInteger = 0 
    Integer = 0 AtomicInteger = 0 
    Integer = -1 AtomicInteger = 0 
    Integer = 2 AtomicInteger = 0 
    Integer = 2 AtomicInteger = 0 
    Integer = -1 AtomicInteger = 0
    </pre>

    <p>Проаналізуємо програму. Клас <tt>Counter</tt> має два члени даних: один типу <tt>Integer</tt>, та інший типу <tt>AtomicInteger</tt> - обидва з однаковим початковим значенням <tt>0</tt>.</p>

    <p>Існує два класи <tt>Thread</tt>. Клас <tt>Incrementer</tt> має метод <tt>run()</tt>, який інкрементує значення <tt>Integer</tt> та <tt>AtomicInteger</tt>. З ішої сторони клас <tt>Decrementer</tt> має метод <tt>run()</tt>, який декременту значення <tt>Integer</tt> та <tt>AtomicInteger</tt>.</p>

    <p>В цьому виводі зверніть увагу на те, що інкрементування об'єкта <tt>Integer</tt> може призвести до умови перегонів: остаточні значення <tt>Integer</tt> чи <tt>AtomicInteger</tt> після інкрементування після однакового числа інкрементувань та декрементувань мають дорівнювати <tt>0</tt> - якщо умови перегонів не трапилося. Як можна бачити у виводі, іноді об'єкт <tt>Integer</tt> дорівнює <tt>0</tt> (умови перегонів немає), але більшість разів він не дорівнює <tt>0</tt> (що означає існування умови перегонів). Однак, для <tt>AtomicInteger</tt> результат завжди нуль (умови перегонів немає). Іншими словами, ця програма демонструє, що маніпулювати значенням <tt>AtomicInteger</tt> без жодних блокувань безпечно.</p>

    <h2>Використання колекцій <tt>java.util.concurrent</tt></h2>

    <p>В пакеті <tt>java.util.concurrent</tt> є багато класів та інтерфейсів, які пропонують високорівневі API для паралельного програмування. В цьому розділі ми, в основному, поговоримо про класи-синхронізатори, представлені в цьому пакеті. Потім коротенько оглянемо класи паралельних колекцій в пакеті <tt>java.util.concurrent</tt>.</p>

    <p>Ми вже розуміємо такі низько-рівневі конструкції для створення потоків, як використання ключового слова <tt>synchronized</tt> та використання інтерфейсів <tt>Runnable</tt>. Треба забезпечувати захист доступу до спільних ресурсів та їх модифікації з боку багатьох потоків.</p>

    <p>При використанні ключового слова <tt>synchronized</tt> для синхронізації між потоками для безпечного спільного доступу застосовуються так звані мьютекси (mutexes). Для виконання великих високорівневих завдань потоками їх також часто треба координувати. Для потокової синхронізації можлива побудова високорівневих абстракцій. Ці високо-рівневі абстракції для синхронізації діяльності двох чи більше потоків відомі як <i>синхронізатори (synchronizers)</i>. Синхронізатори всередині для координації потоків використовують наявні низько-рівневі API.</p>

    <p>Синхронізатори, представлені в бібліотеці <tt>java.util.concurrent</tt>:</p>

    <ul>
        <li><tt>Semaphore</tt> управляє доступом до спільних ресурсів. Семафор супроводжує лічильник для указання кількості ресурсів, які він контролює.</li>
        <li><tt>CountDownLatch</tt> дозволяє одному чи більше потоку очікувати сплину лічильника зворотнього відрахунку.</li>
        <li>Клас <tt>Exchanger</tt> призначений для обміну даними між двома потоками. Цей клас корисний у випадку, коли два потоки потребують взаємної синхронізації та постійно обмінюються даними.</li>
        <li><tt>CyclicBarrier</tt> допомагає запровадити точку синхронізації, в якій потоки мають очікувати досягнення іншими потоками певної точки виконання.</li>
        <li><tt>Phaser</tt> корисний, коли декілька незалежних потоків для виконання роботи мають працювати по-фазно.</li>
    </ul>

    <p>Далі обговоримо лише <tt>CyclicBarrier</tt>; інші синхронізатори розгляньте самостійно.</p>

    <h3><tt>CyclicBarrier</tt></h3>

    <p>В паралельному програмуванні існує багато ситуацій, коли потоки мають очікувати, доки інші потоки не досягнуть певної точки виконання. <tt>CyclicBarrier</tt> допомагає запровадити таку точку синхронізації; в Таблиці <a href="#c11t03">11-3</a> наведені важливі методи цього класа.</p>

    <table id="c11t03" border="1" cellpadding="2">
        <caption>Таблиця 11-3. Важливі методи класа <tt>CyclicBarrier</tt></caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
        </tr>
        <tr>
            <td><tt>CyclicBarrier(int numThreads)</tt></td>
            <td>Створює об'єкт <tt>CyclicBarrier</tt> з вказаною кількістю потоків, які чекають на нього. Викликає <tt>IllegalArgumentException</tt>, якщо <tt>numThreads</tt> від'ємне чи нуль.</td>
        </tr>
        <tr>
            <td><tt>CyclicBarrier(int parties, Runnable barrierAction)</tt></td>
            <td>Те саме, що й попередній конструктор; цей конструктор додатково приймає потік, який треба викликати при досягненні бар'єру.</td>
        </tr>
        <tr>
            <td><tt>int await()<br/>
            int await(long timeout, TimeUnit unit)</tt></td>
            <td>Блокує, доки вказана кількість потоків не викличе на цьому бар'єрі <tt>await()</tt>. Метод повертає індекс досягнення (arrival index) цього потока. Цей метод може викликати <tt>InterruptedException</tt>, якщо потік перериваєтсья при очікуванні інших потоків, чи <tt>BrokenBarrierException</tt>, якщо бар'єр за якихось причин пошкоджується (наприклад, інший потік був завершений за вичерпанням часу очікування чи перерваний). Перевантажений метод як додаткову опцію приймає період очікування; це перевантажена версія викликає <tt>TimeoutException</tt>, якщо всі інші потоки перевищили період очікування.</td>
        </tr>
        <tr>
            <td><tt>boolean isBroken()</tt></td>
            <td>Повертає <tt>true</tt>, якщо бар'єр пошкоджений. Барє'р пошкоджується, якщо принаймні один його потік був перерваний чи запізнився, або якщо дія бар'єра схибила з викликом винятка.</td>
        </tr>
        <tr>
            <td><tt>void reset()</tt></td>
            <td>Встановлює бар'єр в початковий стан. Якщо існують потоки, які очікують, вони викличуть виняток <tt>BrokenBarrier</tt>.</td>
        </tr>
    </table>

    <p>Лістинг <a href="#c11l06">11-6</a> це приклад іикористання класа <tt>CyclicBarrier</tt>.</p>

    <pre id="c11l06" class="prettyprint lang-java">
    // Лістинг 11-6. CyclicBarrierTest.java
    import java.util.concurrent.CyclicBarrier;
    import java.util.concurrent.BrokenBarrierException;

    // Метод run() в цьому потоці треба викликати лише коли
    // чотири гравці готові почати гру
    class MixedDoubleTennisGame extends Thread {
        public void run() {
            System.out.println("Всі чотири гравці готові, гра починається \n З любов'ю...");
        }
    }

    // Цей потік симулює прибуття гравця.
    // Коли гравець прибуває, він має чекати прибуття інших гравців
    class Player extends Thread {
        CyclicBarrier waitPoint;
        public Player(CyclicBarrier barrier, String name) {
            this.setName(name);
            waitPoint = barrier;
            this.start();
        }
        public void run() {
            System.out.println("Гравець " + getName() + " готовий ");
            try {
                waitPoint.await(); // зачекати прибуття всіх чотирьох гравців
            } catch(BrokenBarrierException | InterruptedException exception) {
                System.out.println("При очікуванні трапився виняток... "
                        + exception);
            }
        }
    }

    // Створює об'єкт CyclicBarrier, надаючи кількість потоків та потік для запуску
    // по досягненні бар'єра всіма потоками
    class CyclicBarrierTest {
        public static void main(String []args) {
            // тенісний мікс потребує чотирьох гравців
            // тож чекаємо, коли чотири гравці
            // (тобто, чотири потоки) приєднаються для початку гри
            System.out.println("Тенісний корт зарезервовано\n"
                    + "Гра почнеться, коли прибудуть чотири гравці");
            CyclicBarrier barrier = new CyclicBarrier(4, new MixedDoubleTennisGame());
            new Player(barrier, "Арчибальд");
            new Player(barrier, "Дора");
            new Player(barrier, "Вася");
            new Player(barrier, "Люся");
        }
    }
    </pre>

    <p>Програма друкує наступне:</p>

    <pre id="c11l06out">
    Тенісний корт зарезервовано
    Гра почнеться, коли прибудуть чотири гравці
    Гравець Арчибальд готовий 
    Гравець Вася готовий 
    Гравець Дора готовий 
    Гравець Люся готовий 
    Всі чотири гравці готові, гра починається 
     З любов'ю...
    </pre>

    <p>Поглянемо на те, як програма працює. В методі <tt>main()</tt> ми створюємо об'єкт <tt>CyclicBarrier</tt>. Конструктор приймає два аргументи: кількість потоків, які чекати, та потік для виклику по досягненні всіх потоків бар'єру. В нашому випадку маємо чекати чотирьох гравців, тож створюємо чотири потоки, кожен з яких представляє гравця. Другий аргумент конструктора <tt>CyclicBarrier</tt> це об'єкт <tt>MixedDoubleTennisGame</tt>, оскільки цей об'єкт представляє гру, яка починається по готовності всіх чотирьох гравців.</p>

    <p>Всередині метода <tt>run()</tt> для кожного потока <tt>Player</tt> ми викликаємо метод <tt>await()</tt> об'єкта <tt>CyclicBarrier</tt>. Як тільки кількість очікуючих потоків для об'єкта <tt>CyclicBarrier</tt> сягне чотирьох, викликається метод <tt>run()</tt> об'єкта <tt>MixedDoubleTennisGame</tt>.</p>

    <h3>Паралельні колекції</h3>

    <p>В пакеті <tt>java.util.concurrent</tt> представлені класи, які є потоко-безпечними еквівалентами класів з фреймворку колекцій пакета <tt>java.util</tt>. Наприклад, <tt>java.util.concurrent.ConcurrentHashMap</tt> це паралельний еквівалент <tt>java.util.HashMap</tt>. Головна різниця між цими двома контейнерами полягає в тому, що вставки та видалення в <tt>HashMap</tt> треба явно синхронізувати, в той час як в <tt>ConcurrentHashMap</tt> синхронізація вбудована. Якщо ви вмієте використовувати <tt>HashMap</tt>, ви вмієте використовувати <tt>ConcurrentHashMap</tt>. Ви маєте розуміти класи, наведені в Таблиці <a href="#c11t04">11-4</a>. Зосередимось на детальному прикладі використання <tt>CopyOnWriteArrayList</tt>.</p>

    <table id="c11t04" border="1" cellpadding="2">
        <caption>Таблиця 11-4. Деякі класи та інтерфейси паралельних колекцій пакета <tt>java.util.concurrent</tt></caption>
        <tr>
            <th>Клас/Інтерфейс</th>
            <th>Короткий опис</th>
        </tr>
        <tr>
            <td><tt>BlockingQueue</tt></td>
            <td>Цей інтерфейс розширює інтерфейс <tt>Queue</tt>. В <tt>BlockingQueue</tt>, якщо черга порожня, він очікує (тобто, блокує) елемент для вставки, а якщо черга повна, він чекає елемент для видалення з черги.</td>
        </tr>
        <tr>
            <td><tt>ArrayBlockingQueue</tt></td>
            <td>Цей клас надає реалізацію інтерфейса <tt>BlockingQueue</tt>, побудовану на базі масиву постійної довжини.</td>
        </tr>
        <tr>
            <td><tt>LinkedBlockingQueue</tt></td>
            <td>Цей клас надає реалізацію інтерфейса <tt>BlockingQueue</tt>, побудовану на базі зв'язаного списка.</td>
        </tr>
        <tr>
            <td><tt>DelayQueue</tt></td>
            <td>Цей клас реалізує <tt>BlockingQueue</tt> та складається з елементів типу <tt>Delayed</tt>. Елемент може бути отриманий з цієї черги лише після періоду затримки.</td>
        </tr>
        <tr>
            <td><tt>PriorityBlockingQueue</tt></td>
            <td>Еквівалент <tt>java.util.PriorityQueue</tt>, але реалізує інтерфейс <tt>BlockingQueue</tt>.</td>
        </tr>
        <tr>
            <td><tt>SynchronousQueue</tt></td>
            <td>Цей клас реалізує <tt>BlockingQueue</tt>. В цьому контейнерікожен <tt>insert()</tt> з боку потока очікує (блокує) відповідного <tt>remove()</tt> з боку іншого потоку та навпаки.</td>
        </tr>
        <tr>
            <td><tt>LinkedBlockingDeque</tt></td>
            <td>Цей клас реалізує <tt>BlockingDeque</tt>, де операції вставки та видалення можуть блокувати; для реалізації використовує зв'язаний список.</td>
        </tr>
        <tr>
            <td><tt>ConcurrentHashMap</tt></td>
            <td>Аналог <tt>Hashtable</tt>, але з безпечними доступом та змінами.</td>
        </tr>
        <tr>
            <td><tt>ConcurrentSkipListMap</tt></td>
            <td>Аналог <tt>TreeMap</tt>, але надає безпечні паралельні доступ та зміни.</td>
        </tr>
        <tr>
            <td><tt>ConcurrentSkipListSet</tt></td>
            <td>Аналог <tt>TreeSet</tt>, але надає безпечні паралельні доступ та зміни.</td>
        </tr>
        <tr>
            <td><tt>CopyOnWriteArrayList</tt></td>
            <td>Схожий на <tt>ArrayList</tt>, але надає безпечний паралельний доступ. При модифікації контейнера створюється свіжа копія базового масива.</td>
        </tr>
        <tr>
            <td><tt>CopyOnWriteArraySet</tt></td>
            <td>Реалізація <tt>Set</tt>, але надає безпечний паралельний доступ та реалізований з використанням <tt>CopyOnWriteArrayList</tt>. При модифікації контейнера створюється свіжа копія базового масива.</td>
        </tr>
    </table>

    <h4>Клас <tt>CopyOnWriteArrayList</tt></h4>

    <p>Обидва <tt>ArrayList</tt> та <tt>CopyOnWriteArrayList</tt> реалізують інтерфейс <tt>List</tt>. Між <tt>ArrayList</tt> та <tt>CopyOnWriteArrayList</tt> існують три головні відмінності:</p>

    <ul>
        <li><tt>ArrayList</tt> не є потоко-безпечним, а <tt>CopyOnWriteArrayList</tt> є таким. Це означає що небезпечно використовувати <tt>ArrayList</tt> в контексті, де виконується багато потоків (особливо коли деякі потоки змінюють контейнер), а <tt>CopyOnWriteArrayList</tt> в такому контексті використовувати безпечно.</li>
        <li>Методи <tt>ArrayList</tt>, такі як <tt>remove()</tt>, <tt>add()</tt> та <tt>set()</tt> можуть викликати <tt>java.util.ConcurrentModificationException</tt>, якщо інший потік змінює <tt>ArrayList</tt> в той час, як перший читає його. Однак, виконувати ці операції з різних потоків з <tt>CopyOnWriteArrayList</tt> безпечно, оскільки такі методи як <tt>remove()</tt>, <tt>add()</tt> та <tt>set()</tt> не викликають цього винятку. Як? Всі активні ітератори матимуть доступ до незміненої версії контейнера, а отже залишаться без впливу; якщо створити ітератор після модифікації, отримаємо ітератор для зміненого контейнера.</li>
        <li>Можна отримати ітератор шляхом виклику метода <tt>Iterator()</tt> об'єкта <tt>List</tt>. Якщо викликати метод <tt>remove()</tt>, коли базовий контейнер змінюється, можна отримати <tt>ConcurrentModificationException</tt>. Не можна викликати метод <tt>remove()</tt> в <tt>Iterator</tt> об'єкта <tt>CopyOnWriteArrayList</tt> - він завжди викликатиме <tt>UnsupportedOperationException</tt>.</li>
    </ul>

    <p>Поведінка <tt>CopyOnWriteArrayList</tt> інколи корисна навіть в контекстах без використання багато-поточності. Наприклад, Лістинг <a href="#c11l07">11-7</a> показує <tt>ArrayList</tt>, який змінюється при виконанні ітератора.</p>

    <pre id="c11l07" class="prettyprint lang-java">
    // Лістинг 11-7. ModifyingList.java
    import java.util.ArrayList;
    import java.util.Iterator;
    import java.util.List;

    public class ModifyingList {
        public static void main(String []args) {
            List&lt;String&gt; aList = new ArrayList&lt;&gt;();
            aList.add("one");
            aList.add("two");
            aList.add("three");
            Iterator listIter = aList.iterator();
            while(listIter.hasNext()) {
                System.out.println(listIter.next());
                aList.add("four");
            }
        }
    }
    </pre>

    <p>Ця програма збоїть з викликом <tt>java.util.ConcurrentModificationException</tt>. Чому? Тому що ітератори <tt>ArrayList</tt> є швидкими-на-падіння (fail-fast); він хибить, викликаючи <tt>ConcurrentModificationException</tt>, якщо виявляє, що базовий контейнер змінився в той час, як він переходив по елементах контейнера. Така поведінка корисна в паралельних контекстах, коли один потік змінює базовий контейнер коли інший потік проходить по елементах контейнера.</p>

    <p>Для того, щоб робити такі зміни в базовому контейнері під час проходу по ньому, можна використовувати <tt>CopyOnWriteArrayList</tt>. Лістинг <a href="#c11l08">11-8</a> це модифікована версія Лістинга <a href="#c11l07">11-7</a>. Ця версія використовує <tt>CopyOnWriteArrayList</tt>.</p>

    <pre id="c11l08" class="prettyprint lang-java">
    // Лістинг 11-8. COWList.java
    import java.util.Iterator;
    import java.util.List;
    import java.util.concurrent.CopyOnWriteArrayList;

    public class COWList {
        public static void main(String []args) {
            List&lt;String&gt; aList = new CopyOnWriteArrayList&lt;&gt;();
            aList.add("один");
            aList.add("два");
            aList.add("три");
            Iterator listIter = aList.iterator();
            while(listIter.hasNext()) {
                System.out.println(listIter.next());
                aList.add("чотири");
            }
        }
    }
    </pre>

    <p>Тепер програма не валиться, а друкує:</p>

    <pre id="c11lo08out" class="prettyprint lang-bsh">
    один
    два
    три
    </pre>

    <p>Зауважте, що елемент "<tt>four</tt>", доданий тричі, не друкується. Це - тому, що ітератор досі має доступ до оригінального (не модифікованого) контейнера, в якому три елементи. Якщо створити новий ітератор та прочитати ним елементи, можна побачити й нові елементи, додані до <tt>aList</tt>.</p>

    <h2>Використання інтерфейсів <tt>Callable</tt> та <tt>ExecutorService</tt></h2>

    <p>В програмі можна напряму створювати потоки та управляти ними, створюючи об'єкти <tt>Thread</tt>. Однак, при бажанні абстрагуватися від низькорівневих деталей багато-потокового програмування можна використовувати інтерфейс <tt>Executor</tt>.</p>

    <p>Рисунок <a href="#c11f03">11-3</a> показує важливі класи та інтерфейси ієрархії <tt>Executor</tt>. В цьому розділі розглянемо використання інтерфейсів <tt>Executor</tt> та <tt>ExecutorService</tt>. Про <tt>ForkJoinPool</tt> поговоримо трохи пізніше.</p>

    <p><img id="c11f03" alt="Рисунок 11-3. Важливі класи та інтерфейси ієрархії Executor" src="img/c11f03.png"/><br/>
    <strong>Рисунок 11-3</strong>. Важливі класи та інтерфейси ієрархії <tt>Executor</tt></p>

    <h3><tt>Executor</tt></h3>

    <p><tt>Executor</tt> це інтерфейс, який оголошує лише один метод: <tt>void execute(Runnable)</tt>. Сам по собі він не виглядає дуже значущим, але породжені від нього класи (або інтерфейси), такі як <tt>ExecutorService</tt>, <tt>ThreadPoolExecutor</tt> та <tt>ForkJoinPool</tt> надають корисну функціональність. Обговоримо деякі з породжених класів <tt>Executor</tt> більш детально трохи пізніше в цій главі. А зараз подивіться на Лістинг <a href="#c11l09">11-9</a> - простий приклад інтерфейса <tt>Executor</tt> - для розуміння того, як реалізувати цей інтерфейс та використовувати його на практиці.</p>

    <pre id="c11l09" class="prettyprint lang-java">
    // Лістинг 11-9. ExecutorTest.java
    import java.util.concurrent.Executor;

    // Цей клас Task реалізує Runnable, отже він об'єкт Thread
    class Task implements Runnable {
        public void run() {
            System.out.println("Виклик Task.run() ");
        }
    }
    // Цей клас реалізує інтерфейс Executor та має перевизначити метод execute(Runnable).
    // Ми надаємо перевантажений метод execute з додатковим аргументом 'times' для створення
    // та запуску потоків надау кількість разів
    class RepeatedExecutor implements Executor {
        public void execute(Runnable runnable) {
            new Thread(runnable).start();
        }
        public void execute(Runnable runnable, int times) {
            System.out.printf("Виклик Task.run() %d разів через Executor.execute() %n", times);
            for(int i = 0; i &lt; times; i++) {
                execute(runnable);
            }
        }
    }
    // Цей клас породжує потік Task та явно викликає метод start().
    // Він також показує, як виконувати Thread за допомогою Executor
    class ExecutorTest {
        public static void main(String []args) {
            Runnable runnable = new Task();
            System.out.println("Виклик Task.run() шляхом прямого створення Thread");
            Thread thread = new Thread(runnable);
            thread.start();
            RepeatedExecutor executor = new RepeatedExecutor();
            executor.execute(runnable, 3);
        }
    }
    </pre>

    <p>вивід програми:</p>

    <pre id="c11l09out" class="prettyprint lang-bsh">
    Виклик Task.run() шляхом прямого створення Thread
    Виклик Task.run() 
    Виклик Task.run() 3 разів через Executor.execute() 
    Виклик Task.run() 
    Виклик Task.run() 
    Виклик Task.run() 
    </pre>

    <p>В цій програмі у нас є клас <tt>Task</tt>, який реалізує <tt>Runnable</tt>, надаючи визначення метода <tt>run()</tt>. Клас <tt>RepeatedExecutor</tt> реалізує інтерфейс <tt>Executor</tt>, надаючи визначення метода <tt>execute(Runnable)</tt>.</p>

    <p>Обидва <tt>Runnable</tt> та <tt>Executor</tt> схожі в сенсі того, що пропонують один метод дял реалізації. В цьому визначенні можна помітити, що <tt>Executor</tt> сам по собі не потік, і нам потрібно створювати об'єкт <tt>Thread</tt> для виконання о'єкта <tt>Runnable</tt>, наданого в метод <tt>execute()</tt>. Однак, головна різниця між <tt>Runnable</tt> та <tt>Executor</tt> полягає в тому, що <tt>Executor</tt> це абстракція того, як виконується потік. Наприклад, в залежності від реалізації <tt>Executor</tt>, він -  <tt>Executor</tt> - може запланувати виконання потока в певний час або виконати потік після певного періоду затримки.</p>

    <p>В цій програмі ми перевантажили метод <tt>execute()</tt> додатковим аргументом для створення та виконання потоків певну кількість разів. В методі <tt>main()</tt> ми спочатку створюємо об'єкт та плануємо його для виконання. Після цього ми створюємо класовий об'єкт <tt>RepeatedExecutor</tt> для виконання потоку три рази.</p>

    <h3><tt>Callable</tt> та <tt>ExecutorService</tt></h3>

    <p><tt>Callable</tt> це інтерфейс, який оголошує лише один метод: <tt>call()</tt>. Його повна сигнатура: <tt>V call() throws Exception</tt>. Він представляє завдання, яке має виконати потік. Коли завдання виконане, він повертає значення. Якщо за деяких причин метод <tt>call()</tt> не може бути виконаний чи хибить, він викликає <tt>Exception</tt>.</p>

    <p>Для виконання завдання з використанням об'єкта <tt>Callable</tt>, спочатку ми створюємо <em>пул потоків</em>. Полу потоків це колекція потоків, які можуть виконувати завдання. Ми створюємо пол потоків за допомогою інструментального класа <tt>Executors</tt>. Цей клас пропонує методи для отримання екземплярів полів потоків, фабрик потоків і т.і.</p>

    <p>Інтерфейс <tt>ExecutorService</tt> розширює інтерфейс <tt>Executor</tt> та пропонує такі сервіси як припинення потоків та створення об'єктів <tt>Future</tt>. Виконання деяких завдань можуть займати деякий час. Тож при розміщенні завдання через службу виконання ми отримуємо об'єкт<tt>Future</tt>.</p>

    <p><tt>Future</tt> представляє обє'кти, які містять значення, яке поверне потік в майбутньому (тобто, він поверне значення як тільки потік закінчить виконання "в майбутньому"). Для перевірки, чи закінчилося виконання завдання, можна використовувати метод <tt>isDone()</tt> класа <tt>Future</tt>, а потім використати метод <tt>get()</tt> для отримання результата завдання. Якщо викликати метод <tt>get()</tt> до закінчення завдання, метод блокує до завершення та повертає значення як тільки воно стає доступним.</p>

    <p>Нижче - простий приклад того, як ці класи працюють разом (Лістинг<a href="#c11l10">11-10</a>).</p>

    <pre id="c11l10">
    // Лістинг 11-10. CallableTest.java
    import java.util.concurrent.Callable;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Future;
    import java.util.concurrent.Executors;

    // Factorial реалізує Callable, отже може бути переданий в ExecutorService
    // та бути виконаний як завдання.
    class Factorial implements Callable&lt;Long&gt; {
        long n;
        public Factorial(long n) {
            this.n = n;
        }
        public Long call() throws Exception {
            if(n &lt;= 0) {
                throw new Exception("для пошуку факторіалу N має бути &gt; 0");
            }
            long fact = 1;
            for(long longVal = 1; longVal &lt;= n; longVal++) {
                fact *= longVal;
            }
            return fact;
        }
    }
    // Демонструє зв'язок між Callable, Executors, ExecutorService та Future;
    // а також їх спільну роботу для виконання завдання
    class CallableTest {
        public static void main(String []args) throws Exception {
            // Значення, факторіал якого ми бажаємо знайти
            long N = 20;
            // отримати завдання для виклику для надання службі виконання
            Callable&lt;Long&gt; task = new Factorial(N);
            // створити ExecutorService з фіксованим пулом потоків в один потік
            ExecutorService es = Executors.newSingleThreadExecutor();
            // надати завдання службі виконання та зберегти об'єкт Future
            Future&lt;Long&gt; future = es.submit(task);
            // чекати метод get(), який блокує до завершення обчислень.
            System.out.printf("факторіал %d це %d", N, future.get());
            // готово. погасити службу виконання, вона більше не потрібна
            es.shutdown();
        }
    }
    </pre>

    <p>Програма друкує наступне:</p>

    <pre id="c11l10out" class="prettyprint lang-bsh">
    факторіал 20 це 2432902008176640000
    </pre>

    <p>В цій програмі у нас є клас <tt>Factorial</tt>, який реалізує <tt>Callable</tt>. Оскільки завдання - обчислити факторіа числа <tt>N</tt>, завдання має повернути результат. Ми використовуємо тип <tt>Long</tt> для значення факторіалу, тож реалізуємо <tt>Callable&lt;Long&gt;</tt>. Всередині класа <tt>Factorial</tt> можна визначити метод <tt>call()</tt>, який виконує завдання. Якщо надане значення <tt>N</tt> від'ємне, або дорівнює нулю, ми завдання не виконуємо, а викликаємо виняток. Інакше проводимо обчислення в циклі від <tt>1</tt> до <tt>N</tt>.</p>

    <p>В класі <tt>CallableTest</tt> спочатку ми створюємо екземпляр класа <tt>Factorial</tt>. Потім треба виконати це завдання. Для спрощення ми отримуємо одно-поточного виконавця через виклик метода <tt>newSingleThreadExecutor()</tt> класа <tt>Executors</tt>. Зауважте, що для створення пулу потоків з багатьма потоками можна використовувати інші методи, такі як <tt>newFixedThreadPool(nThreads)</tt>.</p>

    <p>Після отримання <tt>ExecutorService</tt>, ми передаємо завдання на виконання. <tt>ExecutorService</tt> абстрагує такі деталі, як коли виконується завдання та як завдання призначається потокам. Ми отримуємо посилання на <tt>Future&lt;Long&gt;</tt> при виклику метода <tt>submit(task)</tt>. З цього "майбутнього" посилання ми викликаємо метод <tt>get()</tt> для вибірки результата після закінчення завдання. Якщо при виклику <tt>future.get()</tt> завдання ще виконується, цей метод <tt>get()</tt> заблокує до завершення виконання завдання. Після завершення виконання нам треба вручну звільнити <tt>ExecutorService</tt> шляхом виклику метода <tt>shutdown()</tt>.</p>

    <h2>Використання паралельного фреймворку Fork/Join</h2>

    <p>Фреймворк Fork/Join пакета <tt>java.util.concurrent</tt> допомагає спростити написання паралельного коду. Цей фреймворк це реалізація інтерфейса <tt>ExecutorService</tt>, яка пропонує легку у використанні паралельну платформу для використання багатьох процесорів. Цей фреймворк дуже корисний для моделювання проблем класу "розділяй-та-володарюй". Цей підхід широко застосовується для завдань, які можуть бути розділені та обчислені в меншому масштабі; результаті обчислень потім об'єднуютсья. Розбиття завдання на менші - це розгалуження (forking), а злиття результатів маленьких завдань - з'єднання (joining).</p>

    <p>Фреймворк Fork/Join використовує алгоритм <em>крадіжки роботи</em>: коли робочий потік завершує роботу та стає вільним, він бере (або "краде") роботу від інших потоків, які досі зайняті. Спочатку використання фреймворка Fork/Join виглядає кладною задачею. По мірі знайомства з нею відкриється її концептуальна простота, яка здатна значно полегшити вашу роботу. Ключ полягає в рекурсивному розділенні завдання на маленькі шматки, які можуть бути опрацьовані окремими потоками.</p>

    <p>Коротко алгоритм Fork/Join спроектований так:</p>

    <pre id="c11s09" class="prettyprint lang-java">
    forkJoinAlgorithm() {
        fork (split) the tasks;
        join the tasks;
        compose the results;
    }       
    </pre>

    <p>Псевдо-код для демонстрації того, як працюють ці кроки:</p>

    <pre>
    doRecursiveTask(input) {
        if (завдання доволі замале для опрацювання потоком) {
            обчислити маленьке завдання;
            якщо є результат, повернути його
        }
        else {
            розділити (тобто, fork-нути) завдання на дві частини
            викликати compute() на першій, join() на другій, повернути об'єднаний результат
        }
    }       
    </pre>

    <p>Рисунок <a href="#c11f04">11-4</a> показує, як завдання рекурсивно поділяється на менші завдання, та як об'єднуються проміжні результати. Завдання розділяється на два під-завдання, потім кожне під-завдання знову розділяється на два під-завдання і так далі доки кожне під-завдання не стає таким, яке може обчислити кожен потік. Коли потік завершує обчислення, він повертає результат для об'єднання з іншими результатами; так об'єднуються всі обчислені результати.</p>

    <p><img id="c11f04" alt="Рисунок 11-4. Фреймворк Fork/Join використовує Divide-and-Conquer для виконання завдання" src="img/c11f04.jpg"/><br/>
    <strong>Рисунок 11-4</strong>. Фреймворк Fork/Join використовує Divide-and-Conquer для виконання завдання</p>

    <h3>Корисні класи фреймворка Fork/Join</h3>

    <p>Наступні класи грають ключову роль в фреймворку Fork/Join: <tt>ForkJoinPool</tt>, <tt>ForkJoinTask</tt>, <tt>RecursiveTask</tt> та <tt>RecursiveAction</tt>. Розглянемо їх більш детально.</p>

    <ul>
        <li><tt>ForkJoinPool</tt> це найважливіший клас фреймворка Fork/Join. Це пул потоків для запуску завдань fork/join; він виконує екземпляр <tt>ForkJoinTask</tt>. Він виконує завдання та управляє їх життєвим циклом. В таблиці <a href="#c11t05">11-5</a> перелічені важливі методи цього абстрактного класа.</li>
    </ul>

    <table id="c11t05" border="1" cellpadding="2">
        <caption>Таблиця 11-5. Важливі методи класа ForkJoinPool</caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
        </tr>
        <tr>
            <td><tt>void execute(ForkJoinTask&lt;?&gt; task)</tt></td>
            <td>Асинхронно виконує надане завдання.</td>
        </tr>
        <tr>
            <td><tt>&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)</tt></td>
            <td>Виконує надане завдання та повертає обчислений результат.</td>
        </tr>
        <tr>
            <td><tt>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</tt></td>
            <td>Виконує всі надані завдання та повертає список майбутніх об'єктів, коли всі завдання виконані.</td>
        </tr>
        <tr>
            <td><tt>boolean isTerminated()</tt></td>
            <td>Повертає <tt>true</tt> якщо виконані всі завдання.</td>
        </tr>
        <tr>
            <td><tt>int getParallelism()<br/>
            int getPoolSize()<br/>
            long getStealCount()<br/>
            int getActiveThreadCount()</tt></td>
            <td>Методи перевірки статусів.</td>
        </tr>
        <tr>
            <td><tt>&lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task)<br/>
&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)<br/>
ForkJoinTask&lt;?&gt; submit(Runnable task)<br/>
&lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result)</tt></td>
            <td>Ці методи виконують надане завдання. Перевантажені версії приймають різні типи завдань; повертають об'єкт <tt>Task</tt> або об'єкт <tt>Future</tt> object.</td>
        </tr>
    </table>

    <ul>
        <li><tt>ForkJoinTask&lt;V&gt;</tt> це полегшена сутність, схожа на потік, для представлення завдання; визначає такі методи як <tt>fork()</tt> та <tt>join()</tt>. Таблиця <a href="#c11t06">11-6</a> містить перелік важливих методів цього класа.</li>
    </ul>

    <table id="c11t06" border="1" cellpadding="2">
        <caption>Таблиця 11-6. Важливі методи класа ForkJoinTask</caption>
        <tr>
            <th>Метод</th>
            <th>Короткий опис</th>
        </tr>
        <tr>
            <td><tt>boolean cancel(boolean mayInterruptIfRunning)</tt></td>
            <td>Намагається відмінити виконання завдання.</td>
        </tr>
        <tr>
            <td><tt>ForkJoinTask&lt;V&gt; fork()</tt></td>
            <td>Асинхронно виконує завдання.</td>
        </tr>
        <tr>
            <td><tt>V join()</tt></td>
            <td>Повертає результат обчислень по закінченні.</td>
        </tr>
        <tr>
            <td><tt>V get()</tt></td>
            <td>Повертає результат очислень; чекає, доки обчислення не завершаться.</td>
        </tr>
        <tr>
            <td><tt>V invoke()<br/>
static &lt;T extends ForkJoinTask&lt;?&gt;&gt; Collection&lt;T&gt; invokeAll(Collection&lt;T&gt; tasks)</tt></td>
            <td>Починає виконання наданих завдань; очікує завершення обчислень та повертає результати.</td>
        </tr>
        <tr>
            <td><tt>boolean isCancelled()</tt></td>
            <td>Повертає <tt>true</tt>, якщо завдання відмінено.</td>
        </tr>
        <tr>
            <td><tt>boolean isDone()</tt></td>
            <td>Повертає <tt>true</tt>, якщо завдання виконано.</td>
        </tr>
    </table>

    <ul>
        <li><tt>RecursiveTask&lt;V&gt;</tt> це завдання, яке може бути запущене в <tt>ForkJoinPool</tt>; метод <tt>compute()</tt> повертає значення типу <tt>V</tt>. Наслідує від <tt>ForkJoinTask</tt>.</li>
        <li><tt>RecursiveAction</tt> це завдання, яке може бути запущене в <tt>ForkJoinPool</tt>; його метод <tt>compute()</tt> виконує реальні кроки по обчисленню завдання. Схожий на <tt>RecursiveTask</tt>, але не повертає значення.</li>
    </ul>

    <h3>Використання фреймворка Fork/Join</h3>

    <p>Розглянемо, як фреймворк Fork/Join розв'язує проблеми. Кроки по використанню фреймворка:</p>

    <ul>
        <li>
            Спочатку з'ясуйте, чи підходить проблема для фреймворка Fork/Join. Пам'ятайте: фреймворк Fork/Join не підходить для всіх класів завдань. Цей фреймворк підходить, якщо ваша проблема може бути описана так:
            <ul>
                <li>Проблема може бути спроектована як рекурсивне завдання, де завдання може бути розділено на менші одиниці, а результати - об'єднані.</li>
                <li>Розділені завдання незалежні та можуть бути обчислені окремо без потреби в комунікації між завданнями в ході обчислень.</li>
            </ul>
        </li>
        <li>Якщо проблема може бути змодельована рекурсивно, визначте клас, який розширює <tt>RecursiveTask</tt> або <tt>RecursiveAction</tt>. Якщо завдання повертає результат, розширюйте від <tt>RecursiveTask</tt>; інакше - від <tt>RecursiveAction</tt>.</li>
        <li>Перевизначте метод <tt>compute()</tt> в ново-визначеному класі завдання. Метод <tt>compute()</tt> дійсно виконує завдання, якщо воно доволі мале для того, щоб бути виконаним; інакше розділяє завдання на під-завдання та викликає їх. Під-завдання можна викликати методами <tt>invokeAll()</tt> або <tt>fork()</tt> (використовуйте <tt>fork()</tt>, коли під-завдання повертає значення). Використовуйте метод <tt>join()</tt> для отримання обчислених результатів (якщо використовували метод <tt>fork()</tt>).</li>
        <li>Об'єднайте результати від під-завдань.</li>
        <li>Потім інстанціюйте <tt>ForkJoinPool</tt>, створіть екземпляр класа <tt>task</tt> та запустіть виконання завдання за допомогою метода <tt>invoke()</tt> екземпляра <tt>ForkJoinPool</tt>.</li>
        <li>Все.</li>
    </ul>

    <p>Спробуємо обчислити суму <tt>1..N</tt>, де <tt>N</tt> це велике число. Це можна зробити рекурсивно за допомогою фреймворка Fork/Join (Лістинг <a href="#c11l11">11-11</a>).</p>

    <pre id="c11l11" class="prettyprint lang-java">
    // Лістинг 11-11. SumOfNUsingForkJoin.java
    import java.util.concurrent.RecursiveTask;
    import java.util.concurrent.ForkJoinPool;

    // Цей клас показує, як можна обчислити суму 1..N з використанням фреймворка fork/join.
    // Діапазон чисел поділяється навпіл доки він не зможе бути опрацьований потоком.
    // Як тільки сумування діапазона завершується, результати також сумуються.
    class SumOfNUsingForkJoin {
        private static long N = 1000_000;
        private static final int NUM_THREADS = 10;
        // кількість створюваних потоків
        // для розподілення зусиль
        // Це рекурсивна реалізація алогритма; наслідувати від RecursiveTask
        // а не від  RecursiveAction, оскільки є значення, що повертаються.

        static class RecursiveSumOfN extends RecursiveTask&lt;Long&gt; {
            long from, to;
            public RecursiveSumOfN(long from, long to) {
                this.from = from;
                this.to = to;
            }
            // метод виконує розділення та об'єднання для обчислення суми діапазона значень 
            // пам'ятайте, що ми хочемо розділити завдання сумування порівну між NUM_THREADS
            // тож, отримати суму чисел from..to в циклі;
            // чи розділити діапазон та поєднати результати
            public Long compute() {
                if( (to - from) &lt;= N/NUM_THREADS) {
                    // діапазон може бути опрацьований потоком
                    // тож, виконуємо пошук суми
                    long localSum = 0;
                    // обидва кінці діапазону мають бути включені
                    for(long i = from; i &lt;= to; i++) {
                        localSum += i;
                    }
                    System.out.printf("\tСума значень в діапазоні від %d до %d: %d %n",
                            from, to, localSum);
                    return localSum;
                }
                else {
                    // діапазон дуже великий для опрацювання одним потоком
                    // тож, розділити обчислення
                    // знайти середину діапазона
                    long mid = (from + to)/2;
                    System.out.printf("Розділення обчислення на два діапазони: " +
                            "від %d до %d та від %d до %d %n", from, mid, mid, to);
                    // визначити обчислення для першої половини
                    // як діапазон from..mid
                    RecursiveSumOfN firstHalf = new RecursiveSumOfN(from, mid);
                    // тепер відділити це завдання
                    firstHalf.fork();
                    // визначити обчислення для другої половини
                    // як діапазон  mid+1..to
                    RecursiveSumOfN secondHalf = new RecursiveSumOfN(mid + 1, to);
                    long resultSecond = secondHalf.compute();
                    // тепер дочекатися результатів обчислення першої половини
                    // а по завершенні додати їх до залишків
                    return firstHalf.join() + resultSecond;
                }
            }
        }

        public static void main(String []args) {
            // Створити пул fork-join, який містить NUM_THREADS потоків
            ForkJoinPool pool = new ForkJoinPool(NUM_THREADS);
            // призначити завдання пулу
            long computedSum = pool.invoke(new RecursiveSumOfN(0, N));
            // це - формула для  суми діапазона 1..N
            long formulaSum = (N * (N + 1)) / 2;
            // Порявняти обчислену суму з отриманою по формулі
            System.out.printf("Сума діапазона 1..%d; обчислена сума = %d, " +
                    "сума по формулі = %d %n", N, computedSum, formulaSum);
        }
    }
    </pre>

    <p>Програма друкує наступне:</p>

    <pre id="c11l11out" class="prettyprint lang-bsh">
    Розділення обчислення на два діапазони: від 0 до 500000 та від 500000 до 1000000 
    Розділення обчислення на два діапазони: від 500001 до 750000 та від 750000 до 1000000 
    Розділення обчислення на два діапазони: від 0 до 250000 та від 250000 до 500000 
    Розділення обчислення на два діапазони: від 500001 до 625000 та від 625000 до 750000 
    Розділення обчислення на два діапазони: від 750001 до 875000 та від 875000 до 1000000 
    Розділення обчислення на два діапазони: від 500001 до 562500 та від 562500 до 625000 
    Розділення обчислення на два діапазони: від 625001 до 687500 та від 687500 до 750000 
    Розділення обчислення на два діапазони: від 0 до 125000 та від 125000 до 250000 
    Розділення обчислення на два діапазони: від 250001 до 375000 та від 375000 до 500000 
        Сума значень в діапазоні від 687501 до 750000: 44921906250 
        Сума значень в діапазоні від 562501 до 625000: 37109406250 
    Розділення обчислення на два діапазони: від 0 до 62500 та від 62500 до 125000 
    Розділення обчислення на два діапазони: від 125001 до 187500 та від 187500 до 250000 
    Розділення обчислення на два діапазони: від 750001 до 812500 та від 812500 до 875000 
    Розділення обчислення на два діапазони: від 875001 до 937500 та від 937500 до 1000000 
        Сума значень в діапазоні від 812501 до 875000: 52734406250 
        Сума значень в діапазоні від 187501 до 250000: 13671906250 
        Сума значень в діапазоні від 62501 до 125000: 5859406250 
        Сума значень в діапазоні від 625001 до 687500: 41015656250 
    Розділення обчислення на два діапазони: від 250001 до 312500 та від 312500 до 375000 
    Розділення обчислення на два діапазони: від 375001 до 437500 та від 437500 до 500000 
        Сума значень в діапазоні від 500001 до 562500: 33203156250 
        Сума значень в діапазоні від 437501 до 500000: 29296906250 
        Сума значень в діапазоні від 312501 до 375000: 21484406250 
        Сума значень в діапазоні від 875001 до 937500: 56640656250 
        Сума значень в діапазоні від 0 до 62500: 1953156250 
        Сума значень в діапазоні від 125001 до 187500: 9765656250 
        Сума значень в діапазоні від 750001 до 812500: 48828156250 
        Сума значень в діапазоні від 937501 до 1000000: 60546906250 
        Сума значень в діапазоні від 375001 до 437500: 25390656250 
        Сума значень в діапазоні від 250001 до 312500: 17578156250 
    Сума діапазона 1..1000000; обчислена сума = 500000500000, сума по формулі = 500000500000 
    </pre>

    <p>Проаналізуємо, як працює ця програма. Для спрощення ми вирішили виокристовувати десять потоків для виконання завдання. Клас <tt>RecursiveSumOfN</tt> розширює <tt>RecursiveTask&lt;Long&gt;</tt>. В <tt>RecursiveTask&lt;Long&gt;</tt> ми бачимо <tt>&lt;Long&gt;</tt>, оскільки сума чисел в кожному під-діапазоні це значення <tt>Long</tt>. Також ми обрали <tt>RecursiveTask&lt;Long&gt;</tt> замість плаского <tt>RecursiveAction</tt>, оскільки кожне під-завдання повертає значення. Якщо під-завдання не повертає значення, можна використовувати <tt>RecursiveAction</tt>.</p>

    <p>В методі <tt>compute()</tt> ми приймаємо рішення: обчислювати суму для діапазона, чи далі поділити діапазон. Приймається до уваги наступна умова:</p>

    <pre id="c11s10" class="prettyprint lang-java">(to - from) &lt;= N/NUM_THREADS)</pre>

    <p>Ми використовуємо це порогове значення: якщо довжина діапазона менша за це значення, тоді можна впоратися із завданням, інакше - рекурсивно розділити завдання на дві частини. Ми використовуємо простий цикл <tt>for</tt> для знаходження суми значень в діапазоні. В іншому випадку ми поділяємо діапазон <tt>from .. to</tt>: знаходимо його середину та утворюємо два нові діапазони <tt>from .. mid</tt> та <tt>mid + 1 .. to</tt>. Після виклику <tt>fork()</tt> ми очікуємо завершення першого завдання та породжуємо інше завдання для другої половини обчислень.</p>

    <p>В методі <tt>main()</tt>ми створюємо <tt>ForkJoinPool</tt> з кількістю потоків <tt>NUM_THREADS</tt>. Призначаємо завдання пулу fork/join та отримуємо обчислену суму для <tt>1..1,000,000</tt>. Потім обчислюємо суму за формулою.</p>

    <p>За виводом програми видно, як завдання розбивається на під-завдання.</p>

    <p>В цій програмі ми довільно встановили, що нам вистачить десять потоків длі виконання завдань. Це було зроблено для спрощення логіки програми. На практиці кращий спосіб - брати до уваги кількість доступних процесорів (ядер). Наприклад, для встановлення порогового значення:</p>

    <pre id="c11s11" class="prettyprint lang-java">
    threshold value = (data length size) / (number of available processors);
    </pre>

    <p>Як програмно отримати кількість доступних процесорів? Для цього можна використовувати метод <tt>Runtime.getRuntime().availableProcessors())</tt>.</p>

    <p>В Лістингу <a href="#c11l11">11-11</a> ми використовували <tt>RecursiveTask</tt>; однак, якщо завдання не повертає значення, треба використовувати <tt>RecursiveAction</tt>. Це обумовить декілька відмінностей в програмі з <tt>RecursiveAction</tt> у порівнянні з програмою з <tt>RecursiveTask</tt>. По-перше, треба розширювати клас завдання від <tt>RecursiveAction</tt>. По-друге, метод <tt>compute()</tt> нічого не повертає. Далі, для розміщення під-завдань на виконання треба буде використовувати метод <tt>invokeAll()</tt>. Наприкінці, очевидна відмінність полягатиме в самому методі <tt>compute()</tt>.</p>

    <h2>Пам'ятка</h2>

    <p>Варто запам'ятати:</p>

    <ul>
        <li>Те, що пропонує фреймворк Fork/Join, можна реалізувати, використовуючи такі базові паралельні конструкції, як <tt>start()</tt> та <tt>join()</tt>. Однак, фреймворк Fork/Join абстрагує багато деталей низького рівня, спрощуючи використання. Крім того, використання фреймворка Fork/Join значно ефективніше у порівнянні з управлінням потоками на низькому рівні. Більш за те, використання <tt>ForkJoinPool</tt> ефективно управляє потоками та робить це більш продуктивніше за традиційні пули потоків. Всі ці причини спонукають до використання фреймворка Fork/Join.</li>
        <li>Кожен потік <tt>worker</tt> у фреймворку Fork/Join має робочу чергу, яка реалізована з використанням <tt>Deque</tt>. Кожного разу при створенні нового завдання (чи під-завдання) воно розміщується в голові власної черги. При завершенні завдання та його з'єднанні із завданням, яке ще не завершилося, це робиться розумно. Потік отримує нове завання з голови своєї черги та починає його виконувати, а не засинає (для очікування завершення іншого завдання). Фактично, якщо черга потока порожня, потік отримую завдання з хвосту черги, яка належить іншому потоку. Це й є алгоритм крадіжки завдань.</li>
        <li>Очевидним виглядає виклик <tt>fork()</tt> для обох під-завдань (якщо ви розбиваєте навпіл) та виклик <tt>join()</tt> два рази. Це вірно, але не ефективно. Чому? Взагалі-то так створюється паралельних завдань більше, ніж треба. В такому випадку початковий потік уде очікувати завершення двох інших завдань, що не ефективно з урахуванням вартості створення завдання. Ось чому робиться виклик <tt>fork()</tt> лише один раз, та для другого завдання викликається <tt>compute()</tt>.</li>
        <li>
            Місце розташування викликів <tt>fork()</tt> та <tt>join()</tt> дуже важливе. Наприклад, припустимо, що ми розташували виклики в такому порядку:
            <pre>first.fork();
resultFirst = first.join();
resultSecond = second.compute();</pre>
            Таке використання - послідовне виконання двох завдань, оскільки друге завдання розпочнеться лише після завершення першого. Таким чином воно стає навіть менш ефективним у порівнянні з послідовною версією, оскільки включає витрати на створення завдань. Обережно ставтеся до місць викликів fork/join.
        </li>
        <li>При використанні фреймворка Fork/Join висока продуктивність не гарантуєтся. Одна з причин згадана вище - розміщення викликів fork/join.</li>
    </ul>

    <h2>Використання паралельних потоків даних (<tt>Streams</tt>)</h2>

    <p>Потоки даних (<tt>Streams</tt>) можуть бути послідовними або паралельними. При обговоренні потоків даних (Глава 6) ми розглядали лише послідовні. Тепер поговоримо про паралельні потоки даних.</p>

    <p>Що таке паралельні потоки даних? Паралельні потоки даних розбивають елементи на декуілька частин, обробляють кожну частину окремим потоком та (при необхідності) об'єднують результати від тих потоків для отримання кінцевого результата.</p>

    <p>В останньому розділі обговорювався фреймворк fork/join: завдання виконується шляхом його рекурсивного розбиття на під-завдання, які виконуються паралельно. Паралельні потоки даних всередині використовують цей фреймворк fork/join. Кроки процеса мають складатися з самостійних завдань без залежності від стану.</p>

    <p>Нижче наведено приклад обчислення простих чисел від <tt>1</tt> до <tt>N</tt>. Використана логіка доволі проста: ми перевіряємо, чи ділиться число на інше з діапазону від <tt>2</tt> до <tt>N/2</tt>. Звісно, її можна ще спростити для підвищення швидкості, але наша ціль - показати, як працюють паралельні потоки даних. Спочатку подивимось на послідовну версію цієї програми (Лістинг <a href="#c11l12">11-12</a>).</p>

    <pre id="c11l12" class="prettyprint lang-java">
    // Лістинг 11-12. PrimeNumbers.java
    import java.util.stream.LongStream;

    class PrimeNumbers {
        private static boolean isPrime(long val) {
            for(long i = 2; i &lt;= val/2; i++) {
                if((val % i) == 0) {
                    return false;
                }
            }
            return true;
        }

        public static void main(String []args) {
            long numOfPrimes = LongStream.rangeClosed(2, 100_000)
                    .filter(PrimeNumbers::isPrime)
                    .count();
            System.out.println(numOfPrimes);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre id="c11l12out" class="prettyprint lang-bsh">9592</pre>

    <p>Ця програма правильно звітує про <tt>9592</tt> простих числах від <tt>1</tt> до <tt>100,000</tt>. На моєму комп'ютері виконання цієї програми займає 1.762 секунди (Intel® Core™ i5-8400H CPU @ 2.50GHz × 8).</p>

    <p>Зробити обчислення паралельним дуже просто: треба викликати метод <tt>parallel()</tt> інтерфейса <tt>LongStream</tt>. Фрагмент кода зі змінами:</p>

    <pre id="c11s12" class="prettyprint lang-java">
    long numOfPrimes = LongStream.rangeClosed(2, 100_000)
            .parallel()
            .filter(PrimeNumbers::isPrime)
            .count();
    System.out.println(numOfPrimes);
    </pre>

    <p>Завдяки виклику <tt>parallel()</tt> потік даних стає паралельним, а робота з ним розбивається та розподіляється між потоками, доступними в пулі fork/join. При паралельному обчисленні кількості простих чисел час скорочується до 0.476 секунди. Це практично в чотири рази швидше у порівнянні з обчисленнями над послідовним потоком даних.</p>

    <pre id="c11l12-2out" class="prettyprint lang-bsh">
    $ time java PrimeNumbers; time java PrimeNumbersParallel 
    9592

    real    0m1,762s
    user    0m1,664s
    sys 0m0,138s
    9592

    real    0m0,476s
    user    0m2,417s
    sys 0m0,128s
    </pre>

    <p>На Рисунку <a href="#c11f05">11.5</a> можна побачити приклад вікна системного монітора під час роботи обох програм. Зверніть увагу на долучення ядер процесорів до паралельних обчислень (діапазон пошуку збільшено вдесятеро).</p>

    <p><img id="c11f05" src="img/c11f05.png" alt="Рисунок 11.5. Долучення ядер процесорів до паралельних обчислень."/><br/><strong>Рисунок 11.5</strong>. Долучення ядер процесорів до паралельних обчислень.</p>

    <p>Можна побачити, що код, який використовує паралельні потоки даних, дуже простий (порівняйте з Лістингом <a href="#c11l09">11-9</a>): все, що треба зробити - просто викликати на потоці даних метод <tt>parallel()</tt>!</p>

    <p><hr/>При виклику метода <tt>stream()</tt> класа <tt>Collection</tt> отримуємо послідовний потік даних. При виклику метода <tt>parallelStream()</tt> класа <tt>Collection</tt> отримуємо паралельний потік даних.<hr/></p>

    <p>Викликавши метод <tt>isParallel()</tt>, можна перевірити, паралельний чи послідовний потік даних. Фрагмент коду для ілюстрації цього метода в потоці:</p>

    <pre id="c11s13" class="prettyprint lang-java">
    System.out.println(IntStream.range(1, 10).filter(i -&gt; (i % 2) == 0).isParallel());
    </pre>

    <p>Чому цей фрагмент коду друкує: <tt>false</tt>? Тому що базовий потік даних - по замовчанню - послідовний. Як на рахунок цього фрагмента?</p>

    <pre id="c11s14" class="prettyprint lang-java">
List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3, 4, 5);
System.out.println(ints.parallelStream().filter(i -&gt; (i % 2) == 0).isParallel());
    </pre>

    <p>Оскільки базовий потік даних паралельний (завдяки виклику метода <tt>parallelStream()</tt>), метод <tt>isParallel()</tt> повертає <tt>true</tt>.</p>

    <p><hr/>Можна перетворити послідовний потік даних в паралельний, викликавши метод <tt>parallel()</tt>; аналогічно, можна перетворити паралельний потік даних в послідовний, Викликавши метод <tt>sequential()</tt>.<hr/></p>

    <p>Що надрукує наступний фрагмент кода?</p>

    <pre id="c11s14" class="prettyprint lang-java">
List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3, 4, 5);
System.out.println(ints.parallelStream().filter(i -&gt; (i % 2) == 0).sequential().isParallel());
    </pre>

    <p>Цей фрагмент надрукує: <tt>false</tt>. Чому? Хоча створений потік даних паралельний, виклик метода <tt>sequential()</tt> зробив його послідовним.</p>

    <h3>Правильні перетворення</h3>

    <p>Для правильного використання паралельних потоків даних важливо не залежати від глобального стану. Іншими словами, обчислення не потрібні мати сторонніх ефектів. Нижче наведено приклад неправильного використання потоків (Лістинг <a href="#c11l13">11-13</a>).</p>

    <pre id="c11l13" class="prettyprint lang-java">
    // Лістинг 11-13. StringSplitAndConcatenate.java
    import java.util.Arrays;

    class StringConcatenator {
        public static String result = "";

        public static void concatStr(String str) {
            result = result + " " + str;
        }
    }

    class StringSplitAndConcatenate {
        public static void main(String []args) {
            String words[] = "the quick brown fox jumps over the lazy dog".split(" ");
            Arrays.stream(words).forEach(StringConcatenator::concatStr);
            System.out.println(StringConcatenator.result);
        }
    }
    </pre>

    <p>Ця програма друкує:</p>

    <pre id="c11l13out" class="prettyprint lang-bsh">
the quick brown fox jumps over the lazy dog
    </pre>

    <p>В цій програмі ми розбиваємо рядок "<tt>the quick brown fox jumps over the lazy dog</tt>" на слова та знов поєднуємо їх. Для поєднання слів ми використовуємо глобальну змінну <tt>result</tt> та змінюємо її, передаючи посилання на метод <tt>StringConcatenator::concatStr()</tt> в метод потока даних <tt>forEach()</tt>. Оскільки базовий потік даних послідовний, оригінальний рядок відтворюється без проблем. Перетворимо потік даних з послідовного на паралельний, викликавши <tt>parallel()</tt>.</p>

    <pre id="c11s15" class="prettyprint lang-java">
    Arrays.stream(words).parallel().forEach(StringConcatenator::concatStr);</pre>

    <p>Після такої простої модифікації програма надрукує щось подібне:</p>

    <pre id="c11l13-2out" class="prettyprint lang-bsh">
    quick the fox brown lazy dog the jumps</pre>

    <p>Щось пішло не так з використанням метода <tt>parallel()</tt>. Що ж трапилось?</p>

    <p>Коли потік даних паралельний, завдання розбивається на декілька під-завдань, які виконуються різними потоками. Виклики <tt>forEach(StringConcatenator::concatStr)</tt> тепер маєть доступ до глобально доступної змінної в класі <tt>StringConcatenator</tt>. Отже, програма страждає через проблему умови перегонів (обговорювалася раніше в цій главі). Як можна виправити цю проблему? Треба позбавитися від змінення глобального стану та локалізувати перетворення. Можна використовувати метод <tt>reduce()</tt>, як в Лістингу <a href="#c11l14">11-14</a>. Запам'ятайте: метода <tt>reduce()</tt> можна використовувати на потоці даних при потребі у виконанні повторюваних операцій над елементами потока даних для обчислення результата.</p>

    <pre id="c11l14" class="prettyprint lang-java">
    // Лістинг 11-14. CorrectStringSplitAndConcatenate.java
    import java.util.Arrays;
    import java.util.Optional;

    class CorrectStringSplitAndConcatenate {
        public static void main(String []args) {
            String words[] = "the quick brown fox jumps over the lazy dog".split(" ");
            Optional&lt;String&gt; originalString =
                    (Arrays.stream(words).parallel().reduce((a, b) -&gt; a + " " + b));
            System.out.println(originalString.get());
        }
    }
    </pre>

    <p>Програма друкує правильно:</p>

    <pre id="c11l14out" class="prettyprint lang-bsh">
    the quick brown fox jumps over the lazy dog</pre>

    <p>Можна видалити виклик метода <tt>parallel()</tt>, чи залишити його - це не має значення, ц програма завди правильно робитиме конкатенацію, оскільки операція <tt>reduce</tt> не залежить від змін глобального стану.</p>

    <h3>Паралельні потоки даних та продуктивність</h3>

    <p>Важливе зауваження щодо використання паралельних потоків даних: не обов'язково продуктивність паралельних потоків вища за продуктивність послідовних. Тільки якщо в операціях задіяно велику кількість елементів, вони обчислювально складні, а структури даних допускають ефективне розділення, можливо побачити значні покращення в продуктивності при використання паралельних потоків даних; за інших обставин виконання в паралельних потоках даних може бути повільнішим у порівнянні з послідовними!</p>

    <p>По замовчанню, пул потоків fork/join має стільки потоків, скільки процесорів доступно в системі (отримати кількість процесорів можна викликом: <tt>Runtime.getRuntime().availableProcessors()</tt>). Ця конфігурація по замовчанню добре підходть до більшості випадків використання паралельних потоків даних. Паралелізм по замовчанню можна перевірити ще завдяки методу <tt>getParallelism()</tt> в <tt>ForkJoinPool</tt>:</p>

    <pre id="c11s16" class="prettyprint lang-java">
System.out.println(ForkJoinPool.commonPool().getParallelism());
// друкує 7 на моїй машині
    </pre>

    <p>Метод <tt>getParallelism()</tt> отримує значення від системної властивості <tt>java.util.concurrent.ForkJoinPool.common.parallelism</tt>. Можна використати метод <tt>System.setProperty</tt> для змінення її значення (Лістинг <a href="#c11l15">11-15</a>).</p>

    <pre id="#c11l15" class="prettyprint lang-java">
// Лістинг 11-15. Parallelism.java
import java.util.concurrent.ForkJoinPool;

public class Parallelism {
    public static void main(String []args) {
        System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "8");
        System.out.println(ForkJoinPool.commonPool().getParallelism());
    }
}
    </pre>

    <p>При виконанні програма надрукує: <tt>8</tt>. Альтернатива використанню <tt>System.setProperty()</tt> - встановлення цієї властивості через надання параметра при виклику JVM:</p>

    <pre>java -Djava.util.concurrent.ForkJoinPool.common.parallelism=8 GetParallelism</pre>

    <h2>Підсумки</h2>

    <p>Оглянемо ключові моменти для кожної з поставлених цілей.</p>

    <p><b>Створення робочих потоків за допомогою <tt>Runnable</tt> і <tt>Callable</tt>, та використання <tt>ExecutorService</tt> для паралельного виконання завдань</b></p>

    <ul>
        <li>Можна створювати класи, здатні до багато-поточності, шляхом реалізації інтерфейса <tt>Runnable</tt> або розширення класа <tt>Thread</tt>.</li>
        <li>Завжди реалізуйте метод <tt>run()</tt>. Метод <tt>run()</tt> по замовчанню в <tt>Thread</tt> не робить нічого.</li>
        <li>Викликайте метод <tt>start()</tt>, а не прямо <tt>run()</tt> (залиште виклик <tt>run()</tt> самій JVM).</li>
        <li>Інтерфейс <tt>Callable</tt> представляє завдання, яке має виконати потік. Коли завдання завершується, метод <tt>call()</tt> реалізації <tt>Callable</tt> повертає значення.</li>
        <li>Ієрархія <tt>Executor</tt> абстрагує низько-рівневі деталі багато-поточного програмування та пропонує високо-рівневі паралельні конструкції, дружні до користувача.</li>
    </ul>

    <p><b>Виявлення потенційних проблем з потоками - таких як пасивні тупики, брак блокувань, активні тупики та умови перегонів</b></p>

    <ul>
        <li>Паралельні читання та записи в ресурси можуть привести до проблеми <i>умови перегонів (race condition)</i>.</li>
        <li>Для уникнення умови перегонів потрібно використовувати синхронізацію потоків (тобто, блокування) при доступі до спільних значень. Java пропонує властивості для синхронізації потоків для надання захищеного доступу до спільних ресурсів, зокрема, синхронізовані блоки та синхронізовані методи.</li>
        <li>Використання блокувань може викликати такі проблеми, як пасивні тупики. Коли трапляється пасивний тупик, процес підвисає та не може закінчитися.</li>
        <li>Пасивний тупик зазвичай трапляється коли два потоки отримують блокування у протилежному порядку. Коли один потік отримав одне блокування та чекає на інше, другий потік отримав те інше блокування та чекає звільнення першого блокування. Отже немає ніякого прогреса, а програма знаходиться в пасивному тупику.</li>
        <li>Коли зроблене одним потоком змінення постійно відміняється іншим потоком, обидва потоки зайняті, але програма в цілому не виконує свої задачі; така ситуація - активний тупик.</li>
        <li>Ситуація, в якій потоки з низьким пріоритетом "голодують" довгий час в спробах отримати блокування, називається браком блокувань.</li>
    </ul>

    <p><b>Використання ключового слова <tt>synchronized</tt> та пакета <tt>java.util.concurrent.atomic</tt> для управління порядком виконання потоків</b></p>

    <ul>
        <li>В синхронізованих блоках використовується ключове слово <tt>synchronized</tt> для посилальної змінної, за яким розміщується блок коду. Потік має отримати блокування на синхронізовану змінну для входження в блок; коли вконання блоку закінчується, потік вивільняє блокування.</li>
        <li>Java надає ефективну альтернативу в формі атомарних змінних, коли є потреба отримувати та вивільняти блокування лише для виконання примітивних операцій над змінними.</li>
        <li>Блокування гарантує, що до спільного ресурса в один момент часу матиме доступ лише один потік.</li>
        <li>Блокування та розблокування для виконання операцій над примітивними типами не ефективні. Краще використовувати атомарні змінні, представлені в пакеті <tt>java.util.concurrent.atomic</tt>, включаючи такі як<tt>AtomicBoolean</tt>, <tt>AtomicInteger</tt>, <tt>AtomicIntegerArray</tt>, <tt>AtomicLong</tt>, <tt>AtomicLongArray</tt>, <tt>AtomicReference&lt;V&gt;</tt> та <tt>AtomicReferenceArray&lt;E&gt;</tt>.</li>
    </ul>

    <p><b>Використання колекцій та класів <tt>java.util.concurrent</tt>, включаючи <tt>CyclicBarrier</tt> та <tt>CopyOnWriteArrayList</tt></b></p>

    <ul>
        <li><tt>Semaphore</tt> управляє доступом до одного чи більше спільних ресурсів.</li>
        <li><tt>CountDownLatch</tt> дозволяє потокам очікувати на завершення зворотнього відліку.</li>
        <li><tt>Exchanger</tt> підтримує обмін даними між двома потоками.</li>
        <li><tt>Phaser</tt> використовується для підтримки бар'єра синхронізації.</li>
        <li><tt>CyclicBarrier</tt> enables threads to wait at a predefined execution point.</li>
        <li>Пакет <tt>java.util.concurrent</tt> пропонує багато класів, які є поточно-безпечними еквівалентами класів фрейсворку колекцій пакета <tt>java.util</tt>; наприклад, <tt>java.util.concurrent.ConcurrentHashMap</tt> це паралельний еквівалент <tt>java.util.HashMap</tt>.</li>
        <li><tt>CopyOnWriteArrayList</tt> схожий на <tt>ArrayList</tt>, але пропонує безпечний паралельний доступ. Коли <tt>CopyOnWriteArrayList</tt> змінюється, створюється свіжа копія базового масива.</li>
    </ul>

    <p><b>Використання фреймворка Parallel Fork/Join</b></p>

    <ul>
        <li>Фреймворк Fork/Join це портативний засіб виконання програм з доволі добрим паралелізмом.</li>
        <li>Цей фреймворк є реалізацією інтерфейса <tt>ExecutorService</tt>, він пропонує легку у використанні платформу для використання багатьох процесорів.</li>
        <li>Цей фреймворк дуже корисний для моделювання проблем класу розділяй-та-володарюй.</li>
        <li>Фреймворк Fork/Join використовує алгоритм крадіжки роботи: коли робочий потік завершує виконання та вивільняється, він бере (або "краде") роботу інших потоків, які ще зайняті.</li>
        <li>Техніка крадіжки роботи призводить до доволі хорошого балансування навантаження при управлінні потоками з мінімальною вартістю синхронізації.</li>
        <li><tt>ForkJoinPool</tt> - це найважливіший клас у фреймворку Fork/Join. Це пул потоків для виконання завдань fork/join, він виконує екземпляр <tt>ForkJoinTask</tt>. Він виконує завдання та управляє їхніми життєвими циклами.</li>
        <li><tt>ForkJoinTask&lt;V&gt;</tt> - це легка схожа на потік сутність для представлення завдання, яка визначає такі методи як <tt>fork()</tt> та <tt>join()</tt>.</li>
    </ul>

    <p><b>Використання паралельних потоків даних, зокрема, остаточні обчислення, декомпозиція та злиття процесів, конвеєри та продуктивність</b></p>

    <ul>
        <li>Паралельні потоки даних розділяють елементи на декілька частин, оброблюють кожну частину окремим потоком та - при необхідності - комбінують результати від цих потоків для обчислення остаточного результата.</li>
        <li>Коли викликається метод <tt>stream()</tt> класа <tt>Collection</tt>, отримується послідовний потік даних. При виклику метода <tt>parallelStream()</tt> класа <tt>Collection</tt> отримується паралельний потік даних.</li>
        <li>Паралельні потоки даних всередині використовують фреймворк fork/join. Для правильного використання паралельних потоків кроки процеса мають складатися з незалежних від стану завдань.</li>
        <li>Викликом метода <tt>parallel()</tt> можна перетворити послідовний потік даних в паралельний; аналогічно, для перетворення паралельного потоку даних в послідовний можна викликати метод <tt>sequential()</tt>.</li>
        <li>Перевірити, паралельний потік даних чи послідовний, можна викликом метода <tt>isParallel()</tt>.</li>
    </ul>


    <h1>Лекція 12</h1>
    <h1>Побудова застосунків для роботи з БД з використанням JDBC</h1>

    <p>Мета</p>

    <ul>
        <li>Описати інтерфейси, які складають ядро JDBC API, включаючи інтерфейси <tt class="prettyprint lang-java">Driver</tt>, <tt class="prettyprint lang-java">Connection</tt>, <tt class="prettyprint lang-java">Statement</tt> та <tt class="prettyprint lang-java">ResultSet</tt>, а також їх відношення до реалізацій від постачальника</li>
        <li>Ідентифікувати компоненти, необхідні для з'єднання з базою даних з використанням класа <tt class="prettyprint lang-java">DriverManager</tt>, включаючи JDBC URL</li>
        <li>Відправляти запити та зчитувати результати з бази даних, включаючи створення операторів, повернення наборів результатів, проходження по результатах та правильно закривати набори результатів, оператори та з'єднання</li>
    </ul>

    <p>JDBC (Java Database Connectivity) це важливий Java API, який визначає, яким чином клієнт має доступ до бази даних. Отже, він є критичним для побудови рішень на Java масштабу підприємства.</p>

    <p>Взагалі взаємодія з БД включає наступні кроки:</p>

    <ol>
        <li>Встановити з'єднання з БД.</li>
        <li>Виконати запити SQL для отримання, створення чи змінення змісту таблиць в БД.</li>
        <li>Закрити з'єднання з БД.</li>
    </ol>

    <p>Для виконання такої активності з БД Java пропонує набір API (JDBC). JDBC можна використовувати для встановлення з'єднання з БД, виконання запитів SQL та закриття з'єднання. Перевага JDBC полягає в тому, що не потрібно писати програму для окремої БД. JDBC робить зв'язок між програмою на Java та типом БД слабким. Наприклад, бази даних можуть відрізнятися у спосіб встановлення з'єднання (може відрізнятися назва API і т.д.). JDBC приховує всі відмінності цих баз даних та надає один набір API, який можна використовувати для взаємодії з цими типами БД. Треба зауважити, що JDBC підтримує лише реляційні БД, такі як MySQL, Oracle, Microsoft SQL та DB2. Він не підтримує БД нового покоління (відомі як NoSQL), такі як MongoDB and Neo4j.</p>

    <p>Класи та інтерфейси JDBC входять до пакетів <tt class="prettyprint lang-java">java.sql.*</tt> та <tt class="prettyprint lang-java">javax.sql.*</tt>. Ця глава припускає знайомство з базовими концепціями БД. В ній описується JDBC 4.2, який входить до Java SE 8.</p>

    <h2>Введення до JDBC</h2>

    <p>Поглянемо на важливі компоненти JDBC, як вони працюють разом для досягнення інтеграції з базами даних. Спрощена архітектура JDBC зображена на Рисунку <a href="#c12f01">12-1</a>. Застосунок Java використовує JDBC API для взаємодії з базами даних. JDBC API взаємодіють з менеджером драйверів JDBC для прозорого з'єднання та виконання різної активності з БД різних типів. Менеджер драйверів JDBC використовує різні драйвери JDBC для з'єднання зі своїми специфічними СУБД.</p>

    <p>
        <img id="c12f01" src="img/c12f01.png"/><br/>
        <em><strong>Рисунок 12-1.</strong> Архітектура JDBC</em>
    </p>

    <p>Драйвери JDBC та менеджер драйверів грають ключову роль в реалізації призначення JDBC. Драйвери JDBC спеціально спроектовані для взаємодії з відповідними СУБД. Менеджер драйверів працює як каталог драйверів JDBC - він супроводжує список доступних джерел даних та їх драйверів. Менеджер драйверів обирає відповідний драйвер для комунікації з відповідною СУБД. Він може управляти багатьма одночасно підключеними до їх відповідних джерел даних драйверами.</p>

    <p>З рисунку видно, що складність гетерогенних взаємодій делегована менеджеру драйверів JDBC та драйверам JDBC. Низько-рівневі деталі та відповідна складність схована від розробника застосунків цим JDBC API.</p>

    <h3>Налаштування бази даних</h3>

    <p>Перед тим, як почати дослідження та використання JDBC API, необхідно налаштувати БД для роботи. Для написання JDBC програм треба правильно сконфігурувати БД. Можна використовувати будь-яку БД. Для пояснення різних аспектів JDBC API використовується SQLite. JDBC драйвер можна скачати з <a href="https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc" target="_blank">цієї</a> сторінки. Для створення БД треба виконати команду:</p>

    <pre class="prettyprint lang-bash">
    $ sqlite test.db
    SQLite version 3.33.0 2020-08-14 13:23:32
    Enter ".help" for usage hints.
    sqlite>
    </pre>

    <p>Після створення БД наповнимо її:</p>

    <pre class="prettyprint lang-bash">
    sqlite&gt; create table contact (id integer primary key autoincrement, firstName varchar(30) Not null,
       ...&gt; lastName varchar(30), email varchar(30), phoneNo varchar(13));
    sqlite&gt; insert into contact(firstName, lastName, email, phoneNo)
       ...&gt; values('Петро', 'Кравчук', 'petro.k@mail.ua', '+380987654321');
    sqlite&gt; insert into contact(firstName, lastName, email, phoneNo)
       ...&gt; values('Василь', 'Пекар', 'p.vasyl@mail.ua', '+380123456789');
    sqlite&gt; .mode table
    sqlite&gt; select * from contact ;
    +-----------------+-----------+----------+-----------------+---------------+
    |       id        | firstName | lastName |      email      |    phoneNo    |
    +-----------------+-----------+----------+-----------------+---------------+
    | 1               | Петро     | Кравчук  | petro.k@mail.ua | +380987654321 |
    | 2               | Василь    | Пекар    | p.vasyl@mail.ua | +380123456789 |
    +-----------------+-----------+----------+-----------------+---------------+
    </pre>

    <h2>З'єднання з базою даних</h2>

    <p>В цьому розділі розглядається програмне підключення до БД. Спочатку стисло оглянемо інтерфейс <tt class="prettyprint lang-java">Connection</tt>.</p>

    <h3>Інтерфейс <tt class="prettyprint lang-java">Connection</tt></h3>

    <p>Інтерфейс <tt class="prettyprint lang-java">Connection</tt> пакету <tt class="prettyprint lang-java">java.sql</tt> представляє підключення програми до бази даних. Це канал, через який програма комунікує з БД. В Таблиці <a href="#c12t01">12-1</a> перелічені важливі методи інтерфейса <tt class="prettyprint lang-java">Connection</tt>. Всі ці методи викликають <tt class="prettyprint lang-java">SQLException</tt>, цей факт в таблиці окремо не оголошується.</p>

    <table border="1">
        <caption><em><strong>Таблиця 12-1.</strong> Важливі методи інтерфейса <tt class="prettyprint lang-java">Connection</tt></em></caption>
        <tr>
            <th>Метод</th><th>Опис</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Statement createStatement()</tt></td>
            <td>Створює об'єкт <tt class="prettyprint lang-java">Statement</tt>, який можна використовувати для відправлення операторів SQL до бази даних.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">PreparedStatement prepareStatement(String sql)</tt></td>
            <td>Створює об'єкт <tt class="prettyprint lang-java">PreparedStatement</tt>, який може містити оператори SQL. Оператор SQL може мати параметри <tt class="prettyprint lang-java">IN</tt>; вони можуть містити символ(-и) <tt class="prettyprint lang-java">?</tt>, які використовуються для передачі дійсних значень.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">CallableStatement prepareCall(String sql)</tt></td>
            <td>Створює об'єкт <tt class="prettyprint lang-java">CallableStatement</tt> для виклику процедур бази даних. Оператор SQL може мати параметри <tt class="prettyprint lang-java">IN</tt> або <tt class="prettyprint lang-java">OUT</tt>; вони можуть містити символ(-и) <tt class="prettyprint lang-java">?</tt>, які використовуються для передачі дійсних значень.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">DatabaseMetaData getMetaData()</tt></td>
            <td>Отримує об'єкт <tt class="prettyprint lang-java">DataBaseMetaData</tt>. Ці мета-дані містять інформацію про схему бази даних, таблицю та таке інше, що особливо корисно, якщо цільова база даних не відома.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Clob createClob()</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Clob</tt> (<tt class="prettyprint lang-java">Clob</tt> це назва інтерфейса). Character Large Object (CLOB) це вбудований тип в SQL.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Blob createBlob()</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Blob</tt> (<tt class="prettyprint lang-java">Blob</tt> це назва інтерфейса). Binary Large Object (BLOB) це вбудований тип в SQL.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">void setSchema(String schema)</tt></td>
            <td>При передачі назви схеми, встановлює об'єкт <tt class="prettyprint lang-java">Connection</tt> для доступу до цієї схеми.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">String getSchema()</tt></td>
            <td>Повертає назву схеми бази даних, асоційованої з цим об'єктом <tt class="prettyprint lang-java">Connection</tt>; повертає null, якщо такої схеми немає.</td>
        </tr>
    </table>

    <h3>Підключення до бази даних з використанням  <tt class="prettyprint lang-java">DriverManager</tt></h3>

    <p>Перший крок в комунікації з базою даних це встановити з'єднання між програмою та сервером бази даних. Встановлення з'єднання вимагає розуміння URL бази даних.</p>

    <p>Загальний формат JDBC URL:</p>

    <pre class="prettyprint lang-bash">
        jdbc:&lt;subprotocol&gt;:&lt;subname&gt;
    </pre>

    <p>Приклад рядка URL <tt class="prettyprint lang-java">jdbc:mysql://localhost:3306/:</tt></p>

    <ul>
        <li><tt class="prettyprint lang-java">jdbc (&lt;protocol&gt;)</tt> однаковий для всіх СУБД.</li>
        <li><tt class="prettyprint lang-java">&lt;subprotocol&gt;</tt> відрізняється для кожної СУБД, <tt>sqlite</tt> в цьому випадку. Інколи він включає назву постачальника (в прикладі відсутній).</li>
        <li>Формат <tt class="prettyprint lang-java">&lt;subname&gt;</tt> залежить від БД, але загальний формат такий: <tt class="prettyprint lang-java">//&lt;server&gt;:&lt;port&gt;/database</tt>. <tt class="prettyprint lang-java">&lt;server&gt;</tt> залежить від розташування БД. Кожна СУБД використовує специфічний номер <tt class="prettyprint lang-java">&lt;port&gt;</tt>. Наприкінці, надається назва БД</li>
    </ul>

    <p>Приклади:</p>

    <pre class="prettyprint lang-java">
    jdbc:postgresql://localhost/test
    jdbc:oracle://127.0.0.1:44000/test
    jdbc:microsoft:sqlserver://himalaya:1433
    </pre>

    <p>Тепер розглянемо просту програму для отримання з'єднання (див. Лістинг <a href="#c12l01">12-1</a>).</p>

    <pre class="prettyprint lang-java" id="c12l01">
    // Лістинг 12-1. DbConnect.java
    import java.sql.Connection;
    import java.sql.DriverManager;
    // Клас намагається отримати з'єднання з БД
    class DbConnect {
        public static void main(String[] args) {
            String url = "jdbc:sqlite:test.db";
            try (Connection connection = DriverManager.getConnection(url)) {
                    System.out.println("З'єднання з БД: Вдало");
            } catch (Exception e) {
                System.out.println("З'єднання з БД: Помилка");
                e.printStackTrace();
            }
        }
    }
    </pre>

    <p>Проаналізуємо код:</p>

    <ol>
        <li>URL <tt class="prettyprint lang-java">jdbc:sqlite:test.db</tt> вказує, що jdbc це протокол, а sqlite - під-протокол; <tt class="prettyprint lang-java">test.db</tt> це назва файла (відносне ім'я).</li>
        <li>Об'єкт з'єднання отримуємо методом <tt class="prettyprint lang-java">DriverManager.getConnection()</tt>, який очікує URL бази даних.</li>
        <li>Перед виходом з програми треба закрити з'єднання. Цей приклад використовує оператор <tt class="prettyprint lang-java">try-with-resources</tt>; отже метод <tt class="prettyprint lang-java">close()</tt> для з'єднання викликається автоматично.</li>
        <li>Якщо щось йде не так, викликається виняток. В нашому випадку програма друкує стек виклику.</li>
    </ol>

    <p>Результат запуску програми:</p>

    <pre class="prettyprint lang-bash">
    $ java -classpath ".:sqlite-jdbc-3.34.0.jar" DbConnect
    З'єднання з БД: Вдало
    </pre>

    <p>Це повідомлення означає, що з'єднання з базою даних встановити вдалося. Подальші програми вимагають встановлення з'єднання для виконання запитів до бази даних.</p>

    <hr/>
    <p>При виникненні винятку <tt class="prettyprint lang-java">SQLException</tt> мало що можна зробити для відновлення нормальної роботи; зазвичай він обгортається у виняток вищого рівня та передається до точки визову. Далі ми просто друкуватимемо трасу стеку винятку та ігнороватимемо виняток в програмах.</p>
    <hr/>

    <h4>Клас <tt class="prettyprint lang-java">DriverManager</tt></h4>

    <p>Клас <tt class="prettyprint lang-java">DriverManager</tt> допомогає встановлювати з'єднання між програмою (користувачем) та драйверами JDBC. Тобто, не треба явно завантажувати драйвер JDBC: <tt class="prettyprint lang-java">DriverManager</tt> шукає потрібний драйвер та автоматично завантажує його при виклику метода <tt class="prettyprint lang-java">getConnection()</tt>. В лістингу <a href="#c12l01">12-1</a> є такий код для отримання з'єднання (всередині оператора try-with-resources) без явного завантаження драйвера JDBC:</p>

    <pre class="prettyprint lang-java">
    Connection connection = DriverManager.getConnection(url + database, userName, password);
    </pre>

    <p>Менеджер драйверів також управляє багатьма підключеними до відповідних джерел даних драйверами одночасно. В таблиці <a href="#c12t02">12-2</a> перелічені основні методи класа <tt class="prettyprint lang-java">DriverManager</tt>, включаючи перевантажені версії <tt class="prettyprint lang-java">getConnection()</tt>.</p>

    <table id="c12t02" border="1">
        <caption><em><strong>Таблиця 12-2.</strong> Основні методи класу <tt class="prettyprint lang-java">DriverManager</tt></em></caption>
        <tr><th>Метод</th><th>Опис</th></tr>
        <tr>
            <td><tt class="prettyprint lang-java">static Connection getConnection(String url)<br/>
    static Connection getConnection(String url, Properties info)<br/>
    static Connection getConnection(String url, String user, String password)</tt></td>
            <td>Намагається встановити з'єднання по наданому URL бази даних. Додатково можна надавати таку інформацію, як ім'я користувача та пароль безпосередньо як <tt class="prettyprint lang-java">String</tt>-ові аргументи, або через ресурсний пакет <tt class="prettyprint lang-java">Properties</tt>. Цей метод викликає <tt class="prettyprint lang-java">SQLException</tt>, якщо з'єднання не можна встановити.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">static Driver getDriver(String url)</tt></td>
            <td>Шукає серед зареєстрованих драйверів JDBC та повертає об'єкт <tt class="prettyprint lang-java">Driver</tt>, який відповідає URL бази даних.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">static void registerDriver(Driver driver)</tt></td>
            <td>Додає до списку зареєстрованих в <tt class="prettyprint lang-java">DriverManager</tt> об'єкт <tt class="prettyprint lang-java">Driver</tt>.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">static void deregisterDriver(Driver driver)</tt></td>
            <td>Припиняє реєстрацію в <tt class="prettyprint lang-java">DriverManager</tt> об'єкт <tt class="prettyprint lang-java">Driver</tt>.</td>
        </tr>
    </table>

    <p>Використовуючи метод <tt class="prettyprint lang-java">getDriver()</tt>, можна завантажити драйвер, надаючи URL бази даних:</p>

    <pre class="prettyprint lang-java">
    String url = "jdbc:mysql://localhost:3306/";
    Driver driver = DriverManager.getDriver(url);
    System.out.println(driver.getClass().getName());
    </pre>

    <p>Цей код надрукує <tt>com.mysql.jdbc.Driver</tt> - повністю кваліфіковану назву драйверу MySQL JDBC, а <tt class="prettyprint lang-java">DriverManager</tt> зможже завантажити його. З цього об'єкту <tt class="prettyprint lang-java">Driver</tt> можна встановити з'єднання через виклик методу <tt class="prettyprint lang-java">connect()</tt> з URL бази даних та необов'язковим поисланням на файл <tt class="prettyprint lang-java">Properties</tt>:</p>

    <pre class="prettyprint lang-java">
    Connection connection = driver.connect(url, /*properties = */ null);
    </pre>

    <p>В файлі <tt class="prettyprint lang-java">Properties</tt> серед інших деталей можна надати ім'я та пароль користувача.</p>

    <h3>Читання та змінення даних в базі</h3>

    <p>Після встановлення з'єднання з бажаною базою даних в ній можна викнувати рзні операції. Найпоширеніші операції відомі за скороченням CRUD (create, read, update, delete). Можна читати дані за допомогою оператора SQL <tt class="prettyprint lang-sql">SELECT</tt> та змінювати дані операторами <tt class="prettyprint lang-sql">INSERT</tt>, <tt class="prettyprint lang-sql">UPDATE</tt> та <tt class="prettyprint lang-sql">DELETE</tt>. JDBC надає два важливих інтерфейси для підтримки запитів: <tt class="prettyprint lang-java">Statement</tt> та <tt class="prettyprint lang-java">ResultSet</tt>. Розглянемо ці інтерфейси.</p>

    <h3>Інтерфейс <tt class="prettyprint lang-java">Statement</tt></h3>

    <p>Як видно з назви, інтерфейс <tt class="prettyprint lang-java">Statement</tt> це оператор SQL, який можна виконати в базі даних та отримати від неї результат. Запити формуються із використанням <tt class="prettyprint lang-java">Statement</tt>, та виконуються за допомогою API, наданому в інтерфейсі <tt class="prettyprint lang-java">Statement</tt> (чи в його нащадках). <tt class="prettyprint lang-java">Statement</tt> буває трьох видів: <tt class="prettyprint lang-java">Statement</tt>, <tt class="prettyprint lang-java">PreparedStatement</tt> та <tt class="prettyprint lang-java">CallableStatement</tt>; це відображено ієрархією спадкування на Рисунку <a href="#c12f02">12-2</a>.</p>

    <p>
        <img src="img/c12f02.png" id="c12f02"/><br/>
        <em><strong>Рисунок 12-2.</strong> Інтерфейс <tt class="prettyprint lang-java">Statement</tt> та його нащадки</em>
    </p>

    <p>Який з цих трьох треба обрати в певній ситуації? Розглянемо відмінності:</p>

    <ul>
        <li><tt class="prettyprint lang-java">Statement</tt>: Надсилає в базу даних оператор SQL без параметрів. Зазвичай, використовується цей інтерфейс. Екземпляр <tt class="prettyprint lang-java">Statement</tt> створюється за допомогою методу <tt class="prettyprint lang-java">createStatement()</tt> інтерфейса <tt class="prettyprint lang-java">Connection</tt>.</li>
        <li><tt class="prettyprint lang-java">PreparedStatement</tt>: Представляє наперед скомпільований оператор SQL, який можна налаштувати параметрами <tt class="prettyprint lang-java">IN</tt>. Зазвичай, він більш ефективний у порівнянні з об'єктом <tt class="prettyprint lang-java">Statement</tt>; отже, він використовується для підвищення продуктивності, особливо, якщо оператор SQL виконується багато разів. Екземпляр <tt class="prettyprint lang-java">PreparedStatement</tt> можна отримати через виклик методу <tt class="prettyprint lang-java">preparedStatement()</tt> інтерфейса <tt class="prettyprint lang-java">Connection</tt>.</li>
        <li><tt class="prettyprint lang-java">CallableStatement</tt>: Виконує збережені процедури. Екземпляри <tt class="prettyprint lang-java">CallableStatement</tt> приймають як <tt class="prettyprint lang-java">IN</tt>, так і <tt class="prettyprint lang-java">OUT</tt> та <tt class="prettyprint lang-java">INOUT</tt> параметри. Для отримання екземпляру цього класу треа викликати метод <tt class="prettyprint lang-java">prepareCall()</tt> інтерфейса <tt class="prettyprint lang-java">Connection</tt>.</li>
    </ul>

    <p>Після створення потрібного об'єкта <tt class="prettyprint lang-java">Statement</tt> можна виконувати оператор SQL. Інтерфейс <tt class="prettyprint lang-java">Statement</tt> пропонує три методи для виконання: <tt class="prettyprint lang-java">executeQuery()</tt>, <tt class="prettyprint lang-java">executeUpdate()</tt> та <tt class="prettyprint lang-java">execute()</tt>. Для оператора <tt>SELECT</tt> треба використовувати метод <tt class="prettyprint lang-java">executeQuery()</tt>, який повертає <tt class="prettyprint lang-java">ResultSet</tt> (розглядається трохт пізніше). Якщо треба внести зміни в дані з використанням операторів <tt>INSERT</tt>, <tt>UPDATE</tt> чи <tt>DELETE</tt>, треба викликати метод <tt class="prettyprint lang-java">executeUpdate()</tt>, який повертає кількість змінених рядків. Якщо заздалегідь не відомо, який саме оператор SQL треба буде виконати, можна використовувати метод <tt class="prettyprint lang-java">execute()</tt>, який може повернути багато наборів результатів (resultsets) чи багато кількостей змін або їх комбінацію. В Таблиці <a href="#c12t03">12-3</a> наведені основні методи інтерфейса <tt class="prettyprint lang-java">Statement</tt>.</p>

    <table id="c12t03" border="1">
        <caption><em><strong>Таблиця 12-3.</strong>Основні методи інтерфейса<tt class="prettyprint lang-java">Statement</tt></em></caption>
        <tr><th>Метод</th><th>Опис</th></tr>
        <tr>
            <td><tt class="prettyprint lang-java">boolean execute(String sql)</tt></td>
            <td>Виконує наданий оператор SQL. Повертає <tt class="prettyprint lang-java">true</tt>, якщо запит має результатом <tt class="prettyprint lang-java">ResultSet</tt>. Об'єкт <tt class="prettyprint lang-java">ResultSet</tt> можна отримати через виклик методу <tt class="prettyprint lang-java">getResultSet()</tt>. Повертає <tt class="prettyprint lang-java">false</tt>, якщо оператор SQL не має результату чи є кількість змінених рядків. Для отримання кількості змін можна викликати метод <tt class="prettyprint lang-java">getUpdateCount()</tt>. Інколи може повертати декілька <tt class="prettyprint lang-java">ResultSet</tt>-ів; в таких випадках треба викликати метод <tt class="prettyprint lang-java">getMoreResults()</tt>.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">ResultSet executeQuery(String sql)</tt></td>
            <td>Виконує запит та повертає в якості результату об'єкт <tt class="prettyprint lang-java">ResultSet</tt>. Якщо результатів немає, метод не повертає <tt class="prettyprint lang-java">null</tt>; натомість об'єкт <tt class="prettyprint lang-java">ResultSet</tt> поверне <tt class="prettyprint lang-java">false</tt> при виклику його метода <tt class="prettyprint lang-java">next()</tt>.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">int executeUpdate(String sql)</tt></td>
            <td>Виконує оператори SQL <tt>CREATE</tt>, <tt>INSERT</tt>, <tt>UPDATE</tt> або <tt>DELETE</tt>. Повертає кількість змінених рядків (ябо 0 при відсутності результату, як в разі оператора <tt>CREATE</tt>).</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">Connection getConnection()</tt></td>
            <td>Повертає об'єкт <tt class="prettyprint lang-java">Connection</tt>, з яким був створений об'єкт <tt class="prettyprint lang-java">Statement</tt>.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">void close()</tt></td>
            <td>Закриває з'єднання з базою даних та інші пов'язані з об'єктом <tt class="prettyprint lang-java">Statement</tt> ресурси JDBC. Виклик <tt class="prettyprint lang-java">close()</tt> на вже закритому об'єкті <tt class="prettyprint lang-java">Statement</tt> не матиме ефекту.</td>
        </tr>
    </table>

    <p><hr/>
    Треба обирати відповідний метод виконання, виходячи з типу оператора SQL. Треба пам'ятати, що кожен метод виконання повертає різні результати. Метод <tt class="prettyprint lang-java">executeQuery()</tt> повертає <tt class="prettyprint lang-java">ResultSet</tt>, <tt class="prettyprint lang-java">executeUpdate()</tt> повертає кількість змінених рядків та метод <tt class="prettyprint lang-java">execute()</tt> може повернути декілька <tt class="prettyprint lang-java">ResultSet</tt>-ів чи декілька кількостей змінених рядків, або комбінацію обох варіантів.
    <hr/></p>

    <h3>Інтерфейс <tt class="prettyprint lang-java">ResultSet</tt></h3>

    <p>Реляційна база даних містить таблиці.Кожна таблиця має набір атрибутів (властивостей об'єкта, який моделює таблицю), які представлені як стовпці; рядки це записи, які містять значення тих властивостей. При запиті до бази даних вона повертає дані у табличному вигляді: певну кількість рядків, які містять запитані оператором стовпці. Ці дані у табличному вигляді називаються <em>resultset</em>. <em>resultset</em> (набір результатів) це таблиця із заголовками стовпців, які були вказані в запиті.</p>

    <p>Набір результатів супроводжує курсов, який вказує на поточний рядок. За один раз можна зчитувати лише один рядок, то ж треба змінювати позицію курсора для читання чи навігації по всьому набору результатів. Спочатку курсор встановлений перед першим рядком. Для просування курсору на один рядок треба викликати метод <tt class="prettyprint lang-java">next()</tt> на наборі результатів. Цей метод повертає булеве значення; отже його можна використовувати всередині <tt class="prettyprint lang-java">while</tt> циклу для ітерації по всьому набору результатів. Таблиця <a href="#c12t04">12-4</a> містить інші методи <tt class="prettyprint lang-java">ResultSet</tt> для переміщення курсору.</p>

    <table id="c12t04" border="1">
        <caption><em><strong>Таблиця 12-4.</strong> Корисні методи <tt class="prettyprint lang-java">ResultSet</tt> для переміщення курсору</em></caption>
        <tr>
            <th>Метод</th><th>Опис</th>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">void beforeFirst()</tt></td>
            <td>Встановлює курсор перед першим рядком.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">void afterLast()</tt></td>
            <td>Встановлює курсор після останнього рядка.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">boolean absolute(int rowNumber)</tt></td>
            <td>Встановлює курсор в певний рядок за абсолютною позицією.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">boolean relative(int rowNumber)</tt></td>
            <td>Встановлює курсор в певний рядок відносно поточної позиції. <tt class="prettyprint lang-java">rowNumber</tt> може бути позитивним чи від'ємним значенням: позитивне переміщує вперед, від'ємне - назад.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">boolean next()</tt></td>
            <td>Встановлює курсор на наступний рядок.</td>
        </tr>
        <tr>
            <td><tt class="prettyprint lang-java">boolean previous()</tt></td>
            <td>Встановлює курсор на попередній рядок.</td>
        </tr>
    </table>

    <p>Рисунок <a href="#c12f03">12-3</a> демонструє ці методи на прикладах. Зображено п'ять рядків, курсор вказує на третій. Виклик <tt class="prettyprint lang-java">beforeFirst()</tt> встановить курсор перед першим рядком. Виклик <tt class="prettyprint lang-java">afterLast()</tt> встановить курсор після рядка з ID 5. Виклик <tt class="prettyprint lang-java">relative(-2)</tt> встановить курсор на рядок з ID 1. Виклик <tt class="prettyprint lang-java">previous()</tt> чи <tt class="prettyprint lang-java">next()</tt> перемістить курсор на позицію рядка з ID 2 чи ID 4 відповідно. Виклик <tt class="prettyprint lang-java">absolute(5)</tt> перпемістить курсор на рядок з ID 5.</p>

    <p>
        <img src="img/c12f03.png" id="c12f03"/><br/>
        <em><strong>Рисунок 12-3.</strong> Переміщення курсору викликами методів <tt class="prettyprint lang-java">ResultSet</tt></em>
    </p>

    <p><tt class="prettyprint lang-java">ResultSet</tt> також надає набір методів для читання значення бажаного стовпця поточного рядку. Загалом, ці методи бувають двох типів: один приймає на вхід номер стовпця, а другий - ім'я стовпця. Наприклад, методи для читання значення числа з подвійною точністю:  <tt class="prettyprint lang-java">double getDouble(int columnNumber)</tt> та <tt class="prettyprint lang-java">double getDouble(String columnName)</tt>. Аналогічно, <tt class="prettyprint lang-java">ResultSet</tt> надає методи <tt class="prettyprint lang-java">get()</tt>для всіх базових типів.</p>

    <p>Також, <tt class="prettyprint lang-java">ResultSet</tt> пропонує набір методів для змінення значень в бажаному стовцпі обраного рядку. Такі методи також представлені в двох варіантах: <tt class="prettyprint lang-java">void updateXXX(int columnNumber, XXX x)</tt> та <tt class="prettyprint lang-java">void updateXXX(String columnName, XXX x)</tt>, де <tt class="prettyprint lang-java">XXX</tt> означає різні базові типи, для яких визначені методи змінення.</p>

    <h3>Запити до бази даних</h3>

    <p>Тепер нам відомі всі необхідні інтерфейси, які використовуються для виконання запиту до бази даних: <tt class="prettyprint lang-java">Connection</tt>, <tt class="prettyprint lang-java">Statement</tt> та <tt class="prettyprint lang-java">ResultSet</tt>. На Рисунку <a href="#c12f04">12-4</a> показані високорівневі кроки для встановлення з'єднання з базою даних, виконання запитів SQL та опрацювання їх результатів.</p>

    <p>
        <img id="c12f04" src="img/c12f04.png"/><br/>
        <em><strong>Рисунок 12-4.</strong> З'єднання з базою даних, виконання запитів та обробка результатів</em>
    </p>

    <p>Виконаємо запит до бази даних та надрукуємо результат. Ми створили базу даних <tt class="prettyprint lang-java">test.db</tt> з таблицею <tt class="prettyprint lang-sql">contact</tt>, в яку додали два рядки. Припустимо, треба роздрукувати вміст таблиці; лістинги <a href="#c12l02">12-2</a> та <a href="#c12l03">12-3</a> містять програми для цього</p>

    <pre id="c12l02" class="prettyprint lang-java">
    // Лістинг 12-2. DbConnector.java
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.SQLException;
    // Допоміжний клас з методом connectToDb(), який використовується іншими програмами
    public class DbConnector {
        public static Connection connectToDb() throws SQLException {
            String url = "jdbc:sqlite:./test.db";
    //        String database = "addressBook";
    //        String userName = "root";
    //        String password = "mysql123";
    //        return DriverManager.getConnection(url + database, userName, password);
            return DriverManager.getConnection(url);
        }
    }
    </pre>

    <pre id="c12l03" class="prettyprint lang-java">
    // Лістинг 12-3. DbQuery.java
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    // Програма для демонстрації запиту до бази даних
    class DbQuery {
        public static void main(String[] args) {
            // Отримати з'єднання, виконати запит, отримати набір результатів
            // та рохдрукувати його елементи
            try (Connection connection = DbConnector.connectToDb();
                Statement statement = connection.createStatement();
                ResultSet resultSet = statement.executeQuery("SELECT * FROM contact")){
                    System.out.println("ID \tfName \tlName \temail \t\tphoneNo");
                    while (resultSet.next()) {
                        System.out.println(resultSet.getInt("id") + "\t"
                        + resultSet.getString("firstName") + "\t"
                        + resultSet.getString("lastName") + "\t"
                        + resultSet.getString("email") + "\t"
                        + resultSet.getString("phoneNo"));
                    }
                }
            catch (SQLException sqle) {
                sqle.printStackTrace();
                System.exit(-1);
            }
        }
    }
    </pre>

    <p>Вивід програми наступний:</p>

    <pre>
    ID  fName   lName   email           phoneNo
    1   Петро   Кравчук petro.k@mail.ua +380987654321
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    </pre>

    <p>Розглянемо по крокам, що відбувається в цьому коді:</p>

    <ul>
        <li>В методі <tt class="prettyprint lang-java">main()</tt> є оператор <tt class="prettyprint lang-java">try-with-resources</tt>. Перший оператор - виклик метода <tt class="prettyprint lang-java">connectToDb()</tt>, який вия ззначено в програмі. Метод <tt class="prettyprint lang-java">connectToDb()</tt> з'єднується з базою даних та повертає об'єкт <tt class="prettyprint lang-java">Connection</tt> в разі успіху.</li>
        <li>Наступний оператор створює із з'єднання об'єкт <tt class="prettyprint lang-java">Statement</tt>.</li>
        <li>Об'єкт <tt class="prettyprint lang-java">Statement</tt> використовується для виконання запиту. Оскільки бажано отримати всі стовпці таблиці <tt class="prettyprint lang-sql">contact</tt>, в якості запиту використовується <tt class="prettyprint lang-sql">SELECT * FROM contact</tt>. Запит виконується через використання методу <tt class="prettyprint lang-java">executeQuery()</tt> об'єкта <tt class="prettyprint lang-java">Statement</tt>. Результат запиту зберігається в об'єкті <tt class="prettyprint lang-java">ResultSet</tt>.</li>
        <li>Об'єкт <tt class="prettyprint lang-java">ResultSet</tt> використовується для друку отриманих даних. Зчитуютьсначення всіх стовпців поточного рядка; те саме робиться для кожного рядка об'єкта <tt class="prettyprint lang-java">ResultSet</tt>.</li>
        <li>Оскільки об'єкти <tt class="prettyprint lang-java">Connection</tt>, <tt class="prettyprint lang-java">Statement</tt> та <tt class="prettyprint lang-java">ResultSet</tt> створені всередині оператора <tt class="prettyprint lang-java">try-with-resources</tt>, то немає потреби явно викликати <tt class="prettyprint lang-java">close()</tt> для цих ресурсів. Однак, якщо <tt class="prettyprint lang-java">try-with-resources</tt> не використовується, треба вивільняти ці ресурси в блоці <tt class="prettyprint lang-java">finally</tt>.</li>
    </ul>

    <p>Для читання значень використовані імена стовпців. А можна використовувати номери стовпців для того самого. Ось змінений код в циклі <tt class="prettyprint lang-java">while</tt>:</p>

    <pre class="prettyprint lang-java">
    while (resultSet.next()) {
        System.out.println(resultSet.getInt(1)
                + "\t" + resultSet.getString(2)
                + "\t" + resultSet.getString(3)
                + "\t" + resultSet.getString(4)
                + "\t" + resultSet.getString(5));
    }
    </pre>

    <p>Цей код дає той самий результат. Треба пам'ятати, що індекс стовпців починається с 1, а не з 0.</p>

    <p><hr/>
        Індекс стовпців в об'єкті <tt class="prettyprint lang-java">ResultSet</tt> починається з 1, а не з 0.
    <hr/></p>

    <p>При адресації стовпців за індексом, більшим за їх кількість, виникне виняток. Наприклад, при зміні одного з індексів в прикладі на 6, виникне наступний виняток:</p>

    <pre>
    java.sql.SQLException: Column Index out of range, 6 > 5.
            at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1074)
            [... this part of the stack trace elided ...]
            at DbQuery.main(DbQuery.java:18)
    </pre>

    <p>Будьте уважними, надаючи індекси стовпців.</p>

    <p>В цьому прикладі відомі як кількість стовпців, так і їх типи даних. В разі, коли щось з цього не відоме, спочатку треба викликати метод <tt class="prettyprint lang-java">getMetaData()</tt> об'єкта <tt class="prettyprint lang-java">ResultSet</tt>, який поверне об'єкт <tt class="prettyprint lang-java">ResultMetaData</tt>, в якому можна викликати метод <tt class="prettyprint lang-java">getColumnCount()</tt> для отримання кількості стовпців. Якщо не відомий тип даних в стовпці, можна викликати метод <tt class="prettyprint lang-java">getObject()</tt> об'єкта <tt class="prettyprint lang-java">ResultSet</tt>. Можна надати індекс стовпця методу <tt class="prettyprint lang-java">getObject()</tt> для отримання значення відповідного стовпця. Приклад використання цих методів:</p>

    <pre class="prettyprint lang-java">
    // з метаданих resultSet знайти кількість стовпців
    // потім зчитати значення стовпців
    int numOfColumns = resultSet.getMetaData().getColumnCount();
    while (resultSet.next()) {
        // памя'тати: індекс стовпців починається з 1, а не з 0
        for(int i = 1; i <= numOfColumns; i++) {
            // оскільки тип даних невідомий, використовувати треба getObject()
            System.out.print(resultSet.getObject(i) + "\t");
        }
        System.out.println("");
    }
    </pre>

    <p>Вивід програми такий:</p>

    <pre>
    1   Петро   Кравчук petro.k@mail.ua +380987654321
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    </pre>

    <p>В наступному прикладі треба надрукувати лице ім'я на адреу електронної пошти з тих записів, стовпець з ім'ям в яких співпадає із значенням "Василь" (див. Лістинг <a href="#c12l04">12-4</a>).</p>

    <pre id="c12l04" class="prettyprint lang-java">
    // Лістинг 12-4. DbQuery4.java
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.ResultSet;
    import java.sql.SQLException;

    class DbQuery4 {
        public static void main(String[] args) throws SQLException {
            try (Connection connection = DbConnector.connectToDb();
            Statement statement = connection.createStatement();
            ResultSet resultset = statement.executeQuery("SELECT \"firstName\", email"
            + " FROM contact WHERE \"firstName\"=\"Василь\"")) {
                System.out.println("fName \temail");
                while (resultset.next()){
                    System.out.println(resultset.getString("firstName") + "\t"
                    + resultset.getString("email"));
                }
            } catch (SQLException e) {
                e.printStackTrace();
                System.exit(-1);
            }
        }
    }
    </pre>

    <p>Програма надрукує наступне:</p>

    <pre>
    fName   email
    Василь  p.vasyl@mail.ua
    </pre>

    <h3>Внесення змін до бази даних</h3>

    <p>Вносити зміни до даних в базі можна двома шляхами: використовувати безпосередньо оператори SQL для зміни даних, або отримувати набір результатів через запит SQL, а потім змінювати його та базу даних. JDBC підтримує обидва методи. Сфокусуємо увагу на другому методі.</p>

    <p>Для того, щоб змінити набір результатів в базі даних, клас <tt class="prettyprint lang-java">ResultSet</tt> надає набір методів змінення для кожного типу даних. Також для спрощення задач є інші допоміжні методи, такі як <tt class="prettyprint lang-java">updateRow()</tt> та <tt class="prettyprint lang-java">deleteRow()</tt>. Припустимо, один контакт в нашій базі даних змінив свій номер телефону, і треба внести ці зміни в базу даних за допомогою програми з використанням JDBC (див. Лістинг <a href="#c12l05">12-5</a>).</p>

    <pre id="c12l05" class="prettyprint lang-java">
    // Лістинг 12-5. DbUpdate.java
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    // Демонстрація змінення даних
    class DbUpdate {
        public static void main(String[] args) throws SQLException {
            try (Connection connection = DbConnector.connectToDb();
                    Statement statement = connection.createStatement();
                    ResultSet resultSet = statement.executeQuery("SELECT * FROM contact"
                    + " WHERE \"firstName\"=\"Василь\"")) {
                // зчитати дані та відобразити їх перед операцією змінення
                System.out.println("Перед зміненням");
                System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                while (resultSet.next()) {
                    System.out.println(resultSet.getInt("id") + "\t"
                    + resultSet.getString("firstName") + "\t"
                    + resultSet.getString("lastName") + "\t"
                    + resultSet.getString("email") + "\t"
                    + resultSet.getString("phoneNo"));
                }
                // змінити набір результатів та відобразити змінені дані
                resultSet.absolute(1);
                resultSet.updateString("phoneNo", "+919976543210");
                System.out.println("Після змінення");
                System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                resultSet.beforeFirst();
                while (resultSet.next()) {
                    System.out.println(resultSet.getInt("id") + "\t"
                    + resultSet.getString("firstName") + "\t"
                    + resultSet.getString("lastName") + "\t"
                    + resultSet.getString("email") + "\t"
                    + resultSet.getString("phoneNo"));
                }
            } catch (SQLException e) {
                e.printStackTrace();
                System.exit(-1);
            }
        }
    }
    </pre>

    <p>Розглянемо програму крок за кроком:</p>

    <ul>
        <li>Методом <tt class="prettyprint lang-java">DbConnector.connectToDb()</tt> встановлюється з'єднання з базою даних.</li>
        <li>Після сторення об'єкта <tt class="prettyprint lang-java">Statement</tt> виконується запит до бази даних для пошуку рядка, пов'язаного з Василем (для спрощення припускається, що такий рядок один).</li>
        <li>Друкується отриманий рядок.</li>
        <li>Для переміщення курсору на перший рядок використовуєтсья метод <tt class="prettyprint lang-java">absolute()</tt> об'єкта <tt class="prettyprint lang-java">ResultSet</tt>; потім змінюється номер телефону методом <tt class="prettyprint lang-java">updateString()</tt>.</li>
        <li>Наприкінці друкуєтсья змінений набір результатів.</li>
    </ul>

    <p>Виглядає просто. Однак, виконання програми призводить до такого виводу:</p>

    <pre>
    Перед зміненням
    id  fName   lName   email       phoneNo
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    java.sql.SQLException: ResultSet is TYPE_FORWARD_ONLY
        at org.sqlite.jdbc4.JDBC4ResultSet.absolute(JDBC4ResultSet.java:437)
        at DbUpdate.main(DbUpdate.java:24)
    </pre>

    <p>Трапляється виняток! Чому?</p>

    <p>Справа в тому, що об'єкт <tt class="prettyprint lang-java">ResultSet</tt> не є змінюваним. Для того, щоб зміни набору результатів та бази даних можна було виконувати, треба зробити набір даних змінюваним. Це досягається створенням правильного об'єкту <tt class="prettyprint lang-java">Statement</tt>; при виклику метода <tt class="prettyprint lang-java">createStatement()</tt> можна передавати вхідні параметри, які вказували б на такі бажані риси набору результатів, як чи має він бути чутливим до прокручавання чи змінюваним.</p>

    <p>Треба зробити маленьку зміну в виклику <tt class="prettyprint lang-java">createStatement()</tt> в Лістингу <a href="#c12l05">12-5</a>:</p>

    <pre class="prettyprint lang-java">
    Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
    </pre>

    <hr/><p>Треба зауважити, що не всі СУБД здатні надати об'єкти <tt class="prettyprint lang-java">ResultSet</tt> із потрібними властивостями. Наразі SQLite не може.</p><hr/>

    <p>Тепер виклик програми надрукує наступне:</p>

    <pre>
    Перед зміненням
    id  fName   lName   email           phoneNo
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    Після змінення
    id fName   lName    email           phoneNo
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    </pre>

    <p>Добре, програма не викликає виняток. Але номер телефона не змінився! Чому? Був пропущений важливий оператор для внесення змін: виклик метода <tt class="prettyprint lang-java">updateRow()</tt>. Кожен раз при зміненні набору результатів із використанням відповідного методу <tt class="prettyprint lang-java">updateXXX()</tt> треба викликати метод <tt class="prettyprint lang-java">updateRow()</tt> для гарантії того, що внесені зміни дійсно проведені в базі даних. Зробимо відповідні доповнення (див. Лістинг <a href="#c12l06">12-6</a>).</p>

    <pre id="c12l06" class="prettyprint lang-java">
    // Лістинг 12-6. DbUpdate2.java
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    // Демонстрація змінення даних
    class DbUpdate2 {
        public static void main(String[] args) throws SQLException {
            try (Connection connection = DbConnector.connectToDb();
                // створити оператор, для фкого створені набори даних
                // будуть чутливими для прокручування та змінюваними
                Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, 
                    ResultSet.CONCUR_UPDATABLE);
                ResultSet resultSet = statement.executeQuery("SELECT * FROM contact WHERE \"firstName\"=\"Василь\"")) {
                    // зчитати дані та відобразити їх перед операцією змінення
                    System.out.println("Перед зміненням");
                    System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                    while (resultSet.next()) {
                    System.out.println(resultSet.getInt("id") + "\t"
                    + resultSet.getString("firstName") + "\t"
                    + resultSet.getString("lastName") + "\t"
                    + resultSet.getString("email") + "\t"
                    + resultSet.getString("phoneNo"));
                }
                // змінити набір результатів та відобразити змінені дані
                resultSet.absolute(1);
                resultSet.updateString("phoneNo", "+919976543210");
                // відобразити зміни в базі даних через виклик методу updateRow()
                resultSet.updateRow();
                System.out.println("Після змінення");
                System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                resultSet.beforeFirst();
                while (resultSet.next()) {
                    System.out.println(resultSet.getInt("id") + "\t"
                    + resultSet.getString("firstName") + "\t"
                    + resultSet.getString("lastName") + "\t"
                    + resultSet.getString("email") + "\t"
                    + resultSet.getString("phoneNo"));
                }
            } catch (SQLException e) {
                e.printStackTrace();
                System.exit(-1);
            }
        }
    }
    </pre>

    <p>Тепер програма друкує наступне:</p>

    <pre>
    Перед зміненням
    id  fName   lName   email           phoneNo
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    Після змінення
    id fName   lName    email           phoneNo
    2   Василь  Пекар   p.vasyl@mail.ua +919976543210
    </pre>

    <p>Тепер працює вірно. Ми познайомилися з вимогами та кроками, необхідними для змінення рядка в базі даних.</p>

    <hr/><p>Завжди викликайте <tt>updateRow()</tt> після змінення вмісту рядка; інакше зміни будуть втрачені.</p><hr/>

    <p>Розглянемо вставку в набір результатів та базу даних на прикладі в Лістингу <a href="#c12l07">12-7</a>.</p>

    <pre id="c12l07" class="prettyprint lang-java">
    // Лістинг 12-7. DbInsert.java
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    // Демонстрація додавання рядка до набору результатів та бази даних
    class DbInsert {
        public static void main(String[] args) throws SQLException {
            try (Connection connection = DbConnector.connectToDb();
                Statement statement = connection.createStatement(
                        ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
                ResultSet resultSet =
                        statement.executeQuery("SELECT * FROM contact")) {
                System.out.println("Перед вставкою");
                System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                while (resultSet.next()){
                    System.out.println(resultSet.getInt("id") + "\t"
                    + resultSet.getString("firstName") + "\t"
                    + resultSet.getString("lastName") + "\t"
                    + resultSet.getString("email") + "\t"
                    + resultSet.getString("phoneNo"));
                }
                resultSet.moveToInsertRow();
                resultSet.updateString("firstName", "Ілля");
                resultSet.updateString("lastName", "Муромець");
                resultSet.updateString("email", "ilia@lavra.ua");
                resultSet.updateString("phoneNo", "+380442120101");
                resultSet.insertRow();
                System.out.println("Після вставки");
                System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                resultSet.beforeFirst();
                while (resultSet.next()){
                    System.out.println(resultSet.getInt("id") + "\t"
                    + resultSet.getString("firstName") + "\t"
                    + resultSet.getString("lastName") + "\t"
                    + resultSet.getString("email") + "\t"
                    + resultSet.getString("phoneNo"));
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    </pre>

    <p>Що відбувається в цьому прикладі? Після другу поточниз рядків викликається метод <tt class="prettyprint lang-java">moveToInsertRow()</tt>. Цей метод встановлює курсор на новий запис та готує набір результатів до додавання рядка (він сторює буфер для збереження значень стовпців). Після того використовується <tt class="prettyprint lang-java">updateString()</tt> для змінення значення кожного стовпця в новоствореному рядку. Та наприкінці викликається <tt class="prettyprint lang-java">insertRow()</tt> для вставки нового рядка в набір результатів та бази даних. Важливо ждя кожного стовпця надавати значення коректних типів. Також не можна залишати порожнім (не встановлювати значення) для стовпця, який не може бути порожнім. В разі порушення цих вимог виникне виняток <tt class="prettyprint lang-java">SQLException</tt>.</p>

    <p>Що друкує програма:</p>

    <pre>
    Перед вставкою
    id  fName   lName   email       phoneNo
    1   Петро   Кравчук petro.k@mail.ua +380987654321
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    Після вставки
    id  fName   lName   email       phoneNo
    1   Петро   Кравчук petro.k@mail.ua +380987654321
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    3   Ілля    Муромець    ilia@lavra.ua   +380442120101
    </pre>

    <p>Тепер спробуємо видалення рядка з таблиці в базі даних. Програму наведено в Лістингу <a href="#c12l08">12-8</a>.</p>

    <pre id="c12l08" class="prettyprint lang-java">
    // Лістинг 12-8. DbDelete.java
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    // Демонстрація видалення рядка з набору результатів та бази даних
    class DbDelete {
        public static void main(String[] args) throws SQLException {
            String name = args[0];
            try (Connection connection = DbConnector.connectToDb();
                PreparedStatement statement = connection.prepareStatement("SELECT * FROM contact WHERE firstName=?",
                        ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);)
            {
                statement.setString(1, name);
                ResultSet resultSet1 = statement.executeQuery();
                if(resultSet1.next()){
                    // видалити рядок
                    resultSet1.deleteRow();
                }
                resultSet1.close();
                // оновити вибірку з бази даних
                try (PreparedStatement stat = connection.prepareStatement("SELECT * FROM contact");
                        ResultSet resultSet2 = stat.executeQuery()
                    ) {
                    System.out.println("Після видалення");
                    System.out.println("id \tfName \tlName \temail \t\tphoneNo");
                    while (resultSet2.next()){
                        System.out.println(resultSet2.getInt("id") + "\t"
                        + resultSet2.getString("firstName") + "\t"
                        + resultSet2.getString("lastName") + "\t"
                        + resultSet2.getString("email") + "\t"
                        + resultSet2.getString("phoneNo"));
                    }
                }
            } catch (SQLException e) {
                e.printStackTrace();
                System.exit(-1);
            }
        }
    }
    </pre>

    <p>Ця програма вибирає рядки для видалення та викликає метод <tt class="prettyprint lang-java">deleteRow()</tt> для поточного вибраного рядка. Вивід програми з аргументом "Ілля":</p>

    <pre>
    Після видалення
    id  fName   lName   email       phoneNo
    1   Петро   Кравчук petro.k@mail.ua +380987654321
    2   Василь  Пекар   p.vasyl@mail.ua +380123456789
    </pre>

    <p>В програмі продемонстровано використання наперед скомпільованого оператора та призначення змінних прив'язки для запобігання атаки через ін'єкцію SQL, оскільки програма приймає користувацький ввід у вигляді аргумента виклику з командного рядка.</p>

    <p>Також можна виконувати не тільки оператори DML. Наприклад, можна створити таблицю <tt class="prettyprint lang-java">familyGroup</tt> програмно (див. Лістинг <a href="#c12l09">12-9</a>).</p>

    <pre id="c12l09" class="prettyprint lang-java">
    // Лістинг 12-9. DbCreateTable.java
    import java.sql.Connection;
    import java.sql.Statement;
    import java.sql.SQLException;
    class DbCreateTable {
        public static void main(String[] args) {
            try (Connection connection = DbConnector.connectToDb();
                    Statement statement = connection.createStatement()){
                // use CREATE TABLE SQL statement to
                // create table familyGroup
                statement.executeUpdate("CREATE TABLE familyGroup (id int not null"
                + " auto_increment, nickName varchar(30) not null, primary key(id));");
                System.out.println("Таблицю створено успішно.");
            }
            catch (SQLException sqle) {
                sqle.printStackTrace();
                System.exit(-1);
            }
        }
    }
    </pre>

    <p>Програма надрукує наступне (при наявності потрібних повноважень у користувача):</p>

    <pre>Таблицю створено успішно.</pre>

    <p>В програмі відбувається підключення до бази даних, отримання об'єкта <tt class="prettyprint lang-java">Statement</tt> у відомий спосіб. Потім виконується метод <tt class="prettyprint lang-java">executeUpdate()</tt> з оператором SQL, в якому декларується створення таблиці <tt class="prettyprint lang-java">familyGroup</tt> з двома стовпцями: <tt class="prettyprint lang-java">id</tt> та <tt class="prettyprint lang-java">nickName</tt> та первинним ключем. При створенні об'єктів у такий спосіб треба брати до уваги особливості діалекту SQL використовуваної СУБД.</p>

    <p>При наданні до виконання оператора SQL з помилкою виникне виняток:</p>

    <pre>com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL
    syntax; check the manual that corresponds to your MySQL server version for the right syntax
    to use near 'TABL familyGroup (id int not null auto_increment, nickName varchar(30) not
    null,' at line 1</pre>

    <h3>Пам'ятка</h3>

    <p>Корисно запам'ятати:</p>

    <ul>
        <li>Метод <tt class="prettyprint lang-java">boolean absolute(int)</tt> в <tt class="prettyprint lang-java">ResultSet</tt> переміщує курсор на рядок із наданим номером. Якщо номер позитивний, курсор переміщується, рахуюючи з початку об'єкта <tt class="prettyprint lang-java">ResultSet</tt>; якщо - негативний, то - з кінця об'єкта <tt class="prettyprint lang-java">ResultSet</tt>. Якщл в об'єкті <tt class="prettyprint lang-java">ResultSet</tt> десять елементів, то виклик <tt class="prettyprint lang-java">absolute(3)</tt> перемістить курсор на третій рядок, а виклик <tt class="prettyprint lang-java">absolute(-3)</tt> перемістить курсор на восьмий рядок. При наданні індексів поза межами курсор зміщуватиметься на початок чи в кінець.</li>
        <li>В об'єкті <tt class="prettyprint lang-java">ResultSet</tt> виклик <tt class="prettyprint lang-java">absolute(1)</tt> еквівалентний виклику <tt class="prettyprint lang-java">first()</tt>, а виклик <tt class="prettyprint lang-java">absolute(-1)</tt> еквівалентний виклику <tt class="prettyprint lang-java">last()</tt>.</li>
        <li>З методами <tt class="prettyprint lang-java">ResultSet</tt> можна використовувати імена стовпців або їх індекси. Номер має бути індексом в об'єкті <tt class="prettyprint lang-java">ResultSet</tt>, а не номером стовпця в таблиці бази даних.</li>
        <li>Об'єкт <tt class="prettyprint lang-java">Statement</tt> закриває поточний об'єкт <tt class="prettyprint lang-java">ResultSet</tt> при своєму закритті, повторному виконанні або отриманні наступної порції результатів. Це означає, що немає потреби викликати <tt class="prettyprint lang-java">close()</tt> явно в об'єкті <tt class="prettyprint lang-java">ResultSet</tt>; однак, є хорошою практикою викликати  <tt class="prettyprint lang-java">close()</tt> при закінченні роботи з об'єктом.</li>
        <li>Ім'я стовпця в об'єкті <tt class="prettyprint lang-java">ResultSet</tt>можна використовувати, не піклуючися про регістр: методи <tt class="prettyprint lang-java">getXXX()</tt> приймають регістро-незалежні імена стовпців для отримання відповідних значень.</li>
        <li>Якщо в об'єкті <tt class="prettyprint lang-java">ResultSet</tt> зустрічаються стовпці з однаковими іменами, звернення по імені надасть перший стовпець. Отже, для отримання всіх значень знадобиться адресація за індексом.</li>
        <li>Інтерфейс <tt class="prettyprint lang-java">PreparedStatement</tt> спадкує від <tt class="prettyprint lang-java">Statement</tt>. Однак, <tt class="prettyprint lang-java">PreparedStatement</tt> перевизначає всі методи виконання. Наприклад, поведінка <tt class="prettyprint lang-java">executeUpdate()</tt> може відрізнятися від поведінки базового метода.</li>
        <li>Відмінити зроблені зміни можна за допомогою метода <tt class="prettyprint lang-java">cancelRowUpdates()</tt>. Однак, викликати його треба перед викликом <tt class="prettyprint lang-java">updateRow()</tt>. Інакше ефекту не буде.</li>
        <li>WДля з'єднання з базою даних треба надати правильні ім'я користувача та пароль, інакше виникне виняток <tt class="prettyprint lang-java">SQLException</tt>.</li>
    </ul>

    <h2>Підсумки</h2>

    <p>Ключові моменти теми.</p>

    <p><strong>Треба визначити компоненти, необхідні для з'єднання з базою даних із використаннями класу <tt class="prettyprint lang-java">DriverManager</tt>, включаючи JDBC URL</strong></p>

    <ul>
        <li>JDBC приховує гетерогенність всіх СУБД та пропонує один набір API для взаємодії зі всіма типами (реляційних) баз даних. Складність гетерогенних взаємодій делеговано менеджеру драйверів JDBC та самим драйверам JDBC.</li>
        <li>Метод <tt class="prettyprint lang-java">getConnection()</tt> класу <tt class="prettyprint lang-java">DriverManager</tt> приймає три аргументи: рядок URL, рядок username та рядок password.</li>
        <li>Синтаксис URL (потрібного для отримання об'єкта <tt class="prettyprint lang-java">Connection</tt>) такий <tt class="prettyprint lang-java">jdbc:&lt;subprotocol&gt;:&lt;subname&gt;</tt>.</li>
        <li>Якщо JDBC API не здатний знайти драйвер JDBC, він викликає <tt class="prettyprint lang-java">SQLException</tt>. Наявні файли jars з драйверами потрібно включити до classpath для надання JDBC API можливості знайти драйвер.</li>
    </ul>

    <p><strong>Опис інтерфейсів з ядра JDBC API, включаючи інтерфейси <tt class="prettyprint lang-java">Driver</tt>, <tt class="prettyprint lang-java">Connection</tt>, <tt class="prettyprint lang-java">Statement</tt> та <tt class="prettyprint lang-java">ResultSet</tt> та їх взамозв'язків</strong></p>

    <ul>
        <li>Інтерфейс <tt class="prettyprint lang-java">java.sql.Connection</tt> надає канал, через який спілкуються додаток та база даних.</li>
        <li>JDBC підтримує два класи для запитів та змінення: <tt class="prettyprint lang-java">Statement</tt> та <tt class="prettyprint lang-java">Resultset</tt>.</li>
        <li><tt class="prettyprint lang-java">Statement</tt> це оператор SQL, який використовується для взаємодії із з'єднаною базою даних, та отримання результатів від неї. Є три типи <tt class="prettyprint lang-java">Statement</tt>:
            <ul>
                <li><tt class="prettyprint lang-java">Statement</tt>: Надсилає в базу даних оператор SQL без параметрів</li>
                <li><tt class="prettyprint lang-java">PreparedStatement</tt>: Представляє наперед скомппільований оператор SQL, який може бути налаштований з використанням параметрів <tt class="prettyprint lang-java">IN</tt></li>
                <li><tt class="prettyprint lang-java">CallableStatement</tt>: Виконує збережені процедури; може супроводжуватися як <tt class="prettyprint lang-java">IN</tt> чи <tt class="prettyprint lang-java">OUT</tt> так і <tt class="prettyprint lang-java">INOUT</tt> параметрами</li>
            </ul>
        </li>
        <li>Набір результатів це таблиця із стовпцями та відповідними значеннями, які вказані в запиті.</li>
    </ul>

    <p><strong>Виконання запитів та читання результатів з бази даних, включаючи оператори створення, повернення наборів результатів, проходження по результатам та правильне закриття наборів результатів, операторів та з'єднань</strong></p>

    <ul>
        <li>Об'єкт <tt class="prettyprint lang-java">ResultSet</tt> супроводжує курсор, який вказує на поточний рядок. Спочатку курсор встановлено перед першим рядком; виклик метода <tt class="prettyprint lang-java">next()</tt> просуває курсор на один рядок.</li>
        <li>Індекс стовпця в об'єкті <tt class="prettyprint lang-java">ResultSet</tt> починається з 1 (не з 0).</li>
        <li>Після змінення вмісту набору результатів треба викликати <tt class="prettyprint lang-java">updateRow()</tt>; інакше зроблені в об'єкті  <tt class="prettyprint lang-java">ResultSet</tt> зміни будуть втрачені.</li>
        <li>Для актоматичного закриття ресурсів (<tt class="prettyprint lang-java">Connection</tt>, <tt class="prettyprint lang-java">ResultSet</tt> та <tt class="prettyprint lang-java">Statement</tt>) можна використовувати оператор try-with-resources.</li>


        <h1>Лекція 13</h1>
        <h1>Локалізація</h1>

        <p>Цілі</p>
    
        <ul>
            <li>Читання та встановлення локалі за допомогою об'єкта <tt>Locale</tt></li>
            <li>Створення та читання файла властивостей (<tt>Properties</tt>)</li>
            <li>Побудова ресурсного пакета для кожної локалі та завантаження ресурсного пакету в додаток</li>
        </ul>
    
        <p>Комп'ютери та програмне забезпечення сьогодні настільки поширені, що використовуються повсюди в будь-якій діяльності людини. Для відповідання вимогам користувачів по всьому світу програмне забезбечення має бути локазізоване. Процес, в ході якого ми адаптуємо ПЗ до локальної мови та місцевих культурних особливостей, називається <em>локалізація</em>.</p>
    
        <p>Локалізація робить ПЗ відповідним та зручним у використанні для користувачів, які належать різним культурам - иншими словами, налаштування ПЗ для людей з різних країн та з різними мовами. Як саме локалізується програмний додаток? При локалізації програмного додатку слід дотримуватися двох важливих рекомендацій:</p>
    
        <ul>
            <li>Не використовувати в коді тексти (наприклад, повідомлення для користувачів, текстові елементи в графічному інтерфейсі корситувача и т.і.) та виділяти їх у зовнішні файли чи окремі класи. Це як правило спрощує додавання підтримки нової локалі в програмний додаток.</li>
    
            <li>Управляти такими культурно-специфічними аспектами, як дата, час, валюта та форматування чисел, не випускаючи питання локалізації з уваги. Замість покладання на локаль по замовчанню треба проектувати вибірку та налаштування поточної локалі.</li>
        </ul>
    
        <p>В цій главі ми навчимося локалізувати своє програмне забезпечення. В основному, локалізація полягає в створенні <em>ресурсних пакетів</em> для різних локалей, а також у розробленні програмного забезпечення з урахуванням культурних особливостей шляхом його адаптації до використання з різними локалями. Також навчимося, як створювати та використовувати такі ресурсні пакети.</p>
    
        <h2>Локалі</h2>
    
        <p>Локаль - це "місце представлення країни, мови чи культури". Розглянемо франко-канадську локаль. Французською розмовляють у багатьох частинах Канади, тож це має бути представлене локаллю. Іншими словами, якщо є бажання продавати програмне забезпечення, налаштоване для канадійців, які розмовляють французською, то треба облаштувати таке ПЗ для цієї локалі. В Java ця локаль представлена кодом <tt>fr_CA</tt>, де <tt>fr</tt>це скорочення для <tt>French</tt>, а <tt>CA</tt> - для <tt>Canada</tt>; далі ми обговоримо схему іменування локалей більш детально.</p>
    
        <h3>Клас <tt>Locale</tt></h3>
    
        <p>В Java клас <tt>java.util.Locale</tt> надає програмну підтримку для локалей. В таблиці <a href="#c13t01">13-1</a> перелічені важливі методи цього класа.</p>
    
        <table id="c13t01" border="1" cellpadding="2">
            <caption>Таблиця 13-1. Важливі методи класа <tt>Locale</tt></caption>
            <tr><th>Метод</th><th>Короткий опис</th></tr>
            <tr><td><tt>static Locale[] getAvailableLocales()</tt></td><td>Повертає перелік доступних локалей (тобто, встановлених локалей), які підтримуються JVM.</td></tr>
            <tr><td><tt>static Locale getDefault()</tt></td><td>Повертає локаль по замовчанню JVM.</td></tr>
            <tr><td><tt>static void setDefault(Locale newLocale)</tt></td><td>Встановлює локаль по замовчанню JVM.</td></tr>
            <tr><td><tt>String getCountry()</tt></td><td>Повертає <em>код</em> країни для об'єкта локалі.</td></tr>
            <tr><td><tt>String getDisplayCountry()</tt></td><td>Повертає <em>назву</em> для об'єкта локалі.</td></tr>
            <tr><td><tt>String getLanguage()</tt></td><td>Повертає <em>код</em> мови для об'єкта локалі.</td></tr>
            <tr><td><tt>String getDisplayLanguage()</tt></td><td>Повертає <em>назву</em> мови для об'єкта локалі.</td></tr>
            <tr><td><tt>String getVariant()</tt></td><td>Повертає <em>код</em> варіанта для об'єкта локалі.</td></tr>
            <tr><td><tt>String getDisplayVariant()</tt></td><td>Повертає <em>назву</em> варіанта для об'єкта локалі.</td></tr>
            <tr><td><tt>String toString()</tt></td><td>Повертає <tt>String</tt>, складену з кодів мови, країни, варіанта і т.п. локалі.</td></tr>
        </table>
    
        <p>Код в лістингу <a href="#c13l01">13-1</a> знаходить локаль по замовчанню та перевіряє доступні для JVM локалі.</p>
    
        <pre id="c13l01" class="prettyprint lang-java">
    // Лістинг 13-1. AvailableLocales.java
    import java.util.Locale;
    import java.util.Arrays;
    
    class AvailableLocales {
        public static void main(String []args) {
            System.out.println("Локаль по замовчанню: " + Locale.getDefault());
            Locale [] locales = Locale.getAvailableLocales();
            System.out.println("Інші доступні локалі:");
            Arrays.stream(locales).forEach(
                    locale -> System.out.printf("Код локалі: %s, він означає %s %n",
                    locale, locale.getDisplayName()));
            System.out.printf("Кількість доступних локалей: %d %n",
                    locales.length);
        }
    }
        </pre>
    
        <p>Він друкує наступне:</p>
    
        <pre id="c13l01out" class="prettyprint lang-bsh">
    Локаль по замовчанню: en_US
    Інші доступні локалі:
    Код локалі: nn, він означає Norwegian Nynorsk 
    Код локалі: ar_JO, він означає Arabic (Jordan) 
    Код локалі: bg, він означає Bulgarian 
    Код локалі: kea, він означає Kabuverdianu 
    Код локалі: nds, він означає Low German 
    Код локалі: zu, він означає Zulu 
    [...]
    Код локалі: ti, він означає Tigrinya 
    Код локалі: kok, він означає Konkani 
    Код локалі: ewo, він означає Ewondo 
    Код локалі: ms_BN, він означає Malay (Brunei) 
    Код локалі: ccp_IN, він означає Chakma (India) 
    Код локалі: br_FR, він означає Breton (France) 
    Кількість доступних локалей: 748 
        </pre>
    
        <p>Перед аналізом виводу програми подивимось на застосовані в ній методи. Для отримання коду локалі по замовчанню в <tt>Locale</tt> використовується метод <tt>getDefault()</tt>. Після того використовується метод <tt>getAvailableLocales()</tt> класу <tt>Locale</tt> для отримання списку локалей, які підтримуються JVM. Потім для кожної локалі друкується її код та назва за допомогою метода <tt>getDisplayName()</tt>.</p>
    
        <p>Для моєї JVM програма друкує локаль по замовчанню <tt>en_US</tt>, що означає американську англійську. Потім друкується дуже довгий перелік доступних локалей; для збереження місця показано лише малу частку виводу. Ця програма продемонструвала, що існує багато доступних локалей, та що з кожною JVM пов'язана локаль по замовчанню.</p>
    
        <p>В цьому виводі можна побачити чотири різні типи кодів локалі:</p>
    
        <ul>
            <li>"zu, він означає Zulu": лише один код, де <tt>zu</tt> означає <tt>Zulu</tt></li>
    
            <li>"br_FR, він означає Breton (France)": два коди, розділені підкресленням, де <tt>br</tt> означає бретонську, а <tt>FR</tt> - Францію</li>
    
            <li>"no_NO_NY, він означає Norwegian (Norway,Nynorsk)": три коди, розділені підкресленням, де <tt>no</tt> означає норвезьку, <tt>NO</tt> - Норвегію, а <tt>NY</tt> - нюнорськ (нова норвезька - створена в 19 ст. із сільських діалектів для дистанціювання від датської)</li>
    
            <li>"th_TH_TH_#u-nu-thai, він означає Thai (Thailand,TH)": два чи три початкових коди, розділені підкресленням, та кінцевий через <tt>#</tt> чи <tt>_#</tt>.</li>
        </ul>
    
        <p>Як кодуються імена локалей:</p>
    
        <pre>мова + "_" + країна + "_" + (варіант + "_#" | "#") + написання + "-" + розширення</pre>
    
        <p>Ця схема кодування локалі дозволяє комбінувати різні варіації для створення локалі. Для коду локалі "<tt>th_TH_TH_#u-nu-thai</tt>":</p>
    
        <ul>
            <li>Код мови "<tt>th</tt>" (тайська) завжди пишеться в нижньому регістрі</li>
    
            <li>Код країни "<tt>TH</tt>" (Таїланд) завжди пишеться у верхньому регістрі</li>
    
            <li>Назва варанту "<tt>TH</tt>"; тут він повторює код країни, але може бути будь-який рядок</li>
    
            <li>Назва написання тут порожній рядок; якщо надається, буде рядком з чотирьох символів, перший з яких у верхньому регістрі, а інші - в нижньому (наприклад, <tt>Latn</tt>)</li>
    
            <li>Розширення слідує за <tt>#</tt> або <tt>_#</tt> (оскільки написання - порожній рядок); в прикладі це "u-nu-thai"</li>
        </ul>
    
        <p>Інший приклад: код локалі "sr_RS_#Latn",</p>
    
        <ul>
            <li>Код мови "<tt>sr</tt>" (сербська)</li>
    
            <li>Код країни "<tt>RS</tt>" (Сербія)</li>
    
            <li>Порожня назва варіанту</li>
    
            <li>Назва написання "Latn" (латиниця)</li>
    
            <li>Розширення порожнє</li>
        </ul>
    
        <p>Щодо англійської, якою розмовляють у багатьох країнах. Існують варіації англійської, які залежать від країни. Відомо, що американьска англійська відрізняється від британської англійської, але є ще багато версій. Наведено код (лістинг <a href="#c13l02">13-2</a>), в якому зі всіх локалей відфільтровуються лише англійські:</p>
    
        <pre id="c13l02" class="prettyprint lang-java">
    // Лістинг 13-2. AvailableLocalesEnglish.java
    import java.util.Locale;
    import java.util.Arrays;
    
    class AvailableLocalesEnglish {
        public static void main(String []args) {
            Arrays.stream(Locale.getAvailableLocales())
                    .filter(locale -> locale.getLanguage().equals("en"))
                    .forEach(locale ->
                        System.out.printf("Код локалі: %s, він означає %s %n",
                                locale, locale.getDisplayName()));
        }
    }
        </pre>
    
        <p>Він друкує наступне (результат може відрізнятися на іншій машині):</p>
    
        <pre id="c13l02out" class="prettyprint lang-bsh">
    $ java AvailableLocalesEnglish 
    Код локалі: en_NU, він означає English (Niue) 
    Код локалі: en_MS, він означає English (Montserrat) 
    Код локалі: en_GG, він означає English (Guernsey) 
    Код локалі: en_JM, він означає English (Jamaica) 
    Код локалі: en_ZM, він означає English (Zambia) 
    Код локалі: en_MT, він означає English (Malta) 
    Код локалі: en_LR, він означає English (Liberia) 
    Код локалі: en_GH, він означає English (Ghana) 
    ...
        </pre>
    
        <p>Вивід відноситься до різних англійських локалей та використовує лише код мови та код країни. Використано метод <tt>getLanguage()</tt> в <tt>Locale</tt>, який повертає код локалі. Дослідимо інші доступні методи класу <tt>Locale</tt>.</p>
    
        <h4>Отримання деталей локалі та встановлення локалі</h4>
    
        <p>Методи-геттери в класі <tt>Locale</tt>, такі як <tt>getLanguage()</tt>, <tt>getCountry()</tt> та <tt>getVariant()</tt>, повертають коди, а такі як <tt>getDisplayCountry()</tt>, <tt>getDisplayLanguage()</tt> та <tt>getDisplayVariant()</tt> повертають назви. Лістинг <a href="#c13l03">13-3</a> ілюструє використання цих методів для локалі <tt>Locale.CANADA_FRENCH</tt>.</p>
    
        <pre id="c13l03" class="prettyprint lang-java">
    // Лістинг 13-3. LocaleDetails.java
    import java.util.Locale;
    
    public class LocaleDetails {
        public static void main(String args[]) {
            Locale.setDefault(Locale.CANADA_FRENCH);
            Locale defaultLocale = Locale.getDefault();
            System.out.printf("Локаль по замовчанню %s %n", defaultLocale);
            System.out.printf("Код локалі по замовчанню %s, а її назва %s %n",
                    defaultLocale.getLanguage(), defaultLocale.getDisplayLanguage());
            System.out.printf("Код країни по замовчанню %s, а її назва %s %n",
                    defaultLocale.getCountry(), defaultLocale.getDisplayCountry());
            System.out.printf("Код варіанта по замовчанню %s, а його назва %s %n",
                    defaultLocale.getVariant(), defaultLocale.getDisplayVariant());
        }
    }
        </pre>
    
        <p>Він друкує наступне:</p>
    
        <pre id="c13l03out" class="prettyprint lang-bsh">
    $ java LocaleDetails 
    Локаль по замовчанню fr_CA 
    Код локалі по замовчанню fr, а її назва français 
    Код країни по замовчанню CA, а її назва Canada 
    Код варіанта по замовчанню , а його назва  
        </pre>
    
        <p>Метод <tt>setDefault()</tt> приймає як аргумент об'єкт <tt>Locale</tt>. В прикладі ми встановлюємо локаль по замовчанню як <tt>Locale.CANADA_FRENCH</tt> в цьому операторі:</p>
    
        <pre class="prettyprint lang-java">Locale.setDefault(Locale.CANADA_FRENCH);</pre>
    
        <p>Клас <tt>Locale</tt> має багато статичних об'єктів <tt>Locale</tt>, які представляють загальні локалі, тож їх не треба створювати, а можна одразу використовувати в програмі. В прикладі, <tt>Locale.CANADA_FRENCH</tt> це статичний об'єкт <tt>Locale</tt>.</p>
    
        <p>Замість використання цього статичного об'єкта <tt>Locale</tt> можна створити об'єкт <tt>Locale</tt>. Ось - альтернативний шлях встановлення локалі по замовчанню через створення нового об'єкта локалі <tt>Canada (French)</tt>:</p>
    
        <pre class="prettyprint lang-java">Locale.setDefault(new Locale("fr", "CA", ""));</pre>
    
        <p>Метод <tt>getDefault()</tt> в <tt>Locale</tt> повертає об'єкт локалі, встановленої в JVM по замовчанню. Наступний оператор використовує методи для отримання інформації, що відноситься до країни. Різниця між методами <tt>getCountry()</tt> та <tt>getDisplayCountry()</tt> в тому, що перший повертає код країни (який не дуже читабельний), а останній - назву країни. Код країни це дві чи три літери (<tt>ISO 3166</tt>).</p>
    
        <p>Поведінка <tt>getLanguage()</tt> та <tt>getDisplayLanguage()</tt> схожа. Код мови складаєтсья з двох чи трьох літер (<tt>ISO 639</tt>).</p>
    
        <p>В цій локалі немає варіанту, тож нічого не друкується методами <tt>getVariant()</tt> та <tt>getDisplayVariant()</tt>. Варіант може містити додаткові деталі, наприклад, операційне середовище (як <tt>MAC</tt> для машини Macintosh) чи назву компанії (як <tt>Sun</tt> чи <tt>Oracle</tt>).</p>
    
        <p>Окрім того, є ще менш вживані методи <tt>getScript()</tt> та <tt>getDisplayScript()</tt>, які повертають код та назву написання для локалі.</p>
    
        <p>
            <hr/>
            Замість виклику метода <tt>getDisplayCountry()</tt>, який не приймає аргументів, можна використовувати перевантажену версію <tt>getDisplayCountry(Locale)</tt>, який приймає як аргумент об'єкт <tt>Locale</tt>. Він поверне назву країни <em>для наданої локалі</em>. Наприклад, виклик <tt>Locale.GERMANY.getDisplayCountry()</tt> поверне "<tt>Deutschland</tt>" (так німці називають свою країну), а виклик <tt>Locale.GERMANY.getDisplayCountry(Locale.ENGLISH)</tt> поверне "Germany" (як ця країна називається англійською).
            <hr/>
        </p>
    
        <hr/>
    
        <h4>РІЗНІ СПОСОБИ СТВОРЕННЯ ОБʼЄКТУ ЛОКАЛІ</h4>
    
        <p>Існує багато способів отримати чи створити об'єкт <tt>Locale</tt>. Нижче наведено чотири можливості для створення екземпляра італійської локалі.</p>
    
        <p><b>Можливість 1</b>: Використання конструктора класа <tt>Locale</tt>: <tt>Locale(String language, String country, String variant)</tt>:</p>
    
        <pre class="prettyprint lang-java">Locale locale1 = new Locale("it", "", "");</pre>
    
        <p><b>Можливість 2</b>: Використання метода <tt>forLanguageTag(String languageTag)</tt> класа <tt>Locale</tt>:</p>
    
        <pre class="prettyprint lang-java">Locale locale2 = Locale.forLanguageTag("it");</pre>
    
        <p><b>Можливість 3</b>: Побудова об'єкта <tt>Locale</tt> через створення екземпляра <tt>Locale.Builder</tt> та виклик <tt>setLanguageTag()</tt>:</p>
    
        <pre class="prettyprint lang-java">Locale locale3 = new Locale.Builder().setLanguageTag("it").build();</pre>
    
        <p><b>Можливість 4</b>: Використання наперед заданих статичних констант для локалей в класі <tt>Locale</tt>:</p>
    
        <pre class="prettyprint lang-java">Locale locale4 = Locale.ITALIAN;</pre>
    
        <p>Можна обирати спосіб створення об'єкта <tt>Locale</tt> в залежності від потреб.</p>
    
        <hr/>
    
        <h2>Ресурсні пакети</h2>
    
        <p>Яким чином використовується інформація локалі для налаштування поведінки програми? Розглянемо простий приклад вітання: англійською ми кажемо "Hello", але при іншій локалі як змінити це вітання на, для італійського прикладу, "Ciao"?</p>
    
        <p>Одне очевидне рішення - це отримати локаль по замовчанню, перевірити, чи вона італійська, та надрукувати "Ciao", якщо так. Спрацює, але такий підхід ані гнучкий, ані масштабований. Як потім налаштовуватися на інші локалі, наприклад, Саудівської Аравії (Арабська) чи Таїланду (Тайська)? Треба знайти та замінити всі рядки, специфічні для локалі. Ця задача стане жахом, якщо програма складається з тисяч таких рядків серед мільйонів рядків коду - та ще й для багатьох підтримуваних локалей.</p>
    
        <p>В Java для рішення цієї проблеми з налаштування програмних додатків для локаль-залежних потреб існують ресурсні пакети. Що так ресурсний пакет (resource bundle)? Це набір класів або файлів властивостей, який допомагає визначити ключі та відобразити ці ключі на значення, специфічні для локалі.</p>
    
        <p>Абстрактний клас <tt>java.util.ResourceBundle</tt> пропонує абстракцію ресурсних пакетів в Java. Він має два породжених класи: <tt>java.util.PropertyResourceBundle</tt> та <tt>java.util.ListResourceBundle</tt> (див. Рисунок <a href="#c13f01">13-1</a>). Два породжених класи надають підтримку ресурсних пакетів, використовуючи два різних механізми:</p>
    
        <dl>
            <dt>Клас <tt>PropertyResourceBundle</tt></dt>
            <dd>Цей конкретний клас пропонує підтримку для багатьох локалей у формі файлів властивостей. Для кожної локалі у файлі властивостей для цієї локалі вказуються ключі та значення. Для даної локалі при використання метода <tt>ResourceBundle.getBundle()</tt> автоматично буде завантажений відповідний файл властивостей. Звичайно, в цьому немає ніякої магії: для створення файлів властивостей треба дотримуватися певних домовлень по іменуванню, про що йтиметься згодом. При використанні файлів властивостей для ключів та значень можна використовувати лише <tt>String</tt>.</dd>
    
            <dt>Клас <tt>ListResourceBundle</tt></dt>
            <dd>Для додавання підтримки локалі треба розширити цей абстрактний клас. В породженому класі треба перевизначити метод <tt>getContents()</tt>, який повертає <tt>Object [][]</tt>. Цей масив повинен мати список ключів та значень. Ключі мають бути <tt>String</tt>-ами. Зазвичай значення - теж <tt>String</tt>-и, але значення можуть бути чим завгодно: аудіо-кліпами, відео-кліпами, URL-ами чи рисунками.</dd>
        </dl>
    
        <p><img id="c13f01" alt="Рисунок 13-1. ResourceBundle та два його нащадки" src="c13f01.png"/><br/>
        Рисунок 13-1. <tt>ResourceBundle</tt> та два його нащадки</p>
    
        <p>Оглянемо методи абстрактного класа <tt>ResourceBundle</tt>. В таблиці <a href="#c13t02">13-2</a> підсумовані важливі методи цього класа. Обговоримо підтримку локалізації за допомогою цих двох нащадків <tt>ResourceBundle</tt>.</p>
    
        <table id="c13t02" border="1" cellpadding="2">
            <caption>Таблиця 13-2. Важливі методи в абстрактному класі <tt>ResourceBundle</tt></caption>
            <tr><th>Метод</th><th>Короткий опис</th></tr>
            <tr><td><tt>Object getObject(String key)</tt></td><td>Повертає значення, яке відповідає наданому ключу. Викличе <tt>MissingResourceException</tt>, якщо для ключа немає об'єкта.</td></tr>
            <tr><td><tt>static ResourceBundle getBundle
    (String baseName),<br/>
    static final ResourceBundle getBundle
    (String baseName, Locale locale)</tt></td><td>Повертає <tt>ResourceBundle</tt> для наданих <tt>baseName</tt>, <tt>locale</tt> та <tt>control</tt>; викликає <tt>MissingResourceException</tt>, якщо не знайдено відповідного ресурсного пакета. Параметр <tt>Control</tt> призначений для управління інформацією про процес завантаження ресурсного пакета чи її отримання</td></tr>
            <tr><td><tt>final ResourceBundle getBundle
    (String baseName, Locale targetLocale,
    Control control)<br/>
    String getString(String key)</tt></td><td>Повертає значення, яке відповідає наданому ключу; еквівалент приведення отриманого значення від <tt>getObject()</tt> до <tt>String</tt>. Викличе <tt>MissingResourceException</tt>, якщо для наданого ключа не можна знайти об'єкт. Викличе <tt>ClassCastException</tt>, якщо отриманий об'єкт не <tt>String</tt>.</td></tr>
        </table>
    
        <h3>Використання PropertyResourceBundle</h3>
    
        <p>Якщо проектувати додаток, не випускаючи з уваги можливості по локакалізації з використанням файлів властивостей, то можна додавати підтримку нових локалей <em>без жодної зміни в коді</em>!</p>
    
        <p>Розглянемо приклад використання ресурсних файлів. Почнемо з простої програми, яка друкує "<tt>Hello</tt>". Вона має три ресурсних пакети файлів властивостей:</p>
    
        <ol>
            <li>Ресурсний пакет по замовчанню, яке передбачає англійську (США) локаль.</li>
            <li>Ресурсний пакет для арабської локалі.</li>
            <li>Ресурсний пакет для італійської локалі.</li>
        </ol>
    
        <p>Як відомо, файли властивостей визначають стрічки як пари ключ-значення в файлі. Приклад <tt>classpath</tt>, який треба підлаштувати до своєї машини: <tt>classpath=C:\Program Files\Java\jre8</tt>. Зазвичай файли властивостей містять багато таких пар ключ-значення, кожна в окремому рядку, наприклад:</p>
    
        <pre>
    classpath=C:\Program Files\Java\jre8
    temp=C:\Windows\Temp
    windir=C:\Windows
        </pre>
    
        <p>При локалізації ми використовуємо файли властивостей для відображення одного ключа на різні рядки значень. В програмі ми посилаємося на ключі, а після завантаження відповідного файла властивостей для локалі з них будуть обрані для використання програмою відповідні ключам значення.</p>
    
        <p>Важливо правильно іменувати такі файли властивостей; нижче наведені приклади вмісту цих пакетів. Заради спрощення, в цих файлах властивостей - лише одна пара ключ-значення; в реальності в кожному файлі властивостей можуть міститися сотні та навіть тисячі пар.</p>
    
        <pre>
    D:\&gt; type ResourceBundle.properties
    Greeting=Hello
    D:\&gt; type ResourceBundle_ar.properties
    Greeting=As-Salamu Alaykum
    D:\&gt; type ResourceBundle_it.properties
    Greeting=Ciao
        </pre>
    
        <p>Як можна бачити, пакет по замовчанню називається <tt>ResourceBundle.properties</tt>. Ресурсний пакет для арабської називається <tt>ResourceBundle_ar.properties</tt>. Зверніть увагу на суфікс "<tt>_ar</tt>", який вказує арабську в якості мови локалі. Аналогічно, ресурсний пакет для італійської називається <tt>ResourceBundle_it.properties</tt>, з використанням суфіксу "<tt>_it</tt>" для указання на те, що італійська пов'язана з цим файлом властивостей. Лістинг <a href="#c13l04">13-4</a> використовує ці ресурсні пакети.</p>
    
        <pre id="c13l04" class="prettyprint lang-java">
    // Лістинг 13-4. LocalizedHello.java
    import java.util.Locale;
    import java.util.ResourceBundle;
    
    public class LocalizedHello {
        public static void main(String args[]) {
            Locale currentLocale = Locale.getDefault();
            ResourceBundle resBundle =
                    ResourceBundle.getBundle("ResourceBundle", currentLocale);
            System.out.printf(resBundle.getString("Greeting"));
        }
    }
        </pre>
    
        <pre class="prettyprint lang-bsh">
    $ echo 'Greeting=Привет' > ResourceBundle_ru.properties
    $ LANG=ru_UA.utf8 java LocalizedHello 
    Привет
        </pre>
    
        <p>Є дві можливості для запуску цієї програми:</p>
    
        <ul>
            <li><b>Можливість I</b>: Змінити локаль по замовчанню в програмі через виклик метода <tt>setDefault()</tt>:
            <pre>Locale.setDefault(Locale.ITALY);</pre>
            </li>
        </ul>
    
        <p>Ця опція не рекомендується, оскільки потребує зміни програмного коду для встановлення локалі.</p>
    
        <ul>
            <li><b>Можливість II</b>: Змінити локаль по замовчанню при виклику JVM з командного рядку (якщо JVM викликається з IDE, надайте аргументи командного рядку для JVM в налаштуваннях IDE):
            <pre class="prettyprint lang-bsh">D:\> java -Duser.language=it -Duser.region=IT LocalizedHello</pre>
            </li>
        </ul>
    
        <p>Спробуємо програму, встановивши локаль за можливістю II (надаючи аргументи командного рядка при виклику JVM).</p>
    
        <pre class="prettyprint lang-bsh">
    $ echo 'Greeting=As-Salamu Alaykum' > ResourceBundle_ar.properties
    $ java -Duser.language=ar LocalizedHello
    As-Salamu Alaykum
        </pre>
    
        <p>Як видно, в залежности від явно встановленої локалі (італійської чи арабської в нашому прикладі) чи локалі по замовчанню (США англійська в нашому прикладі), завантажується відповідний файл властивостей та знаходиться потрібний рядок повідомлення.</p>
    
        <p>
            <hr/>
            Якщо не створити файли властивостей, чи вони не розташовуватимуться в шляху, виникне <tt>MissingResourceException</tt>.
            <hr/>
        </p>
    
        <p>Перше, що робиться в програмі, це отримується поточна локаль в операторі.</p>
    
        <pre class="prettyprint lang-java">Locale currentLocale = Locale.getDefault();</pre>
    
        <p>Потім з використанням локалі завантажується ресурсний пакет, ім'я якого починається з <tt>ResourceBundle</tt>.</p>
    
        <pre class="prettyprint lang-java">ResourceBundle resBundle = ResourceBundle.getBundle("ResourceBundle", currentLocale);</pre>
    
        <p>Наприкінці, за ключем "<tt>Greeting</tt>" в ресурсному пакеті відбувається пошук значення.</p>
    
        <pre class="prettyprint lang-java">System.out.printf(resBundle.getString("Greeting"));</pre>
    
        <h3>Використання ListResourceBundle</h3>
    
        <p>Підтримку нової локалі можна додати, використовуючи <tt>ListResourceBundle</tt> шляхом його розширення. При розширенні <tt>ListResourceBundle</tt> треба перевизначити абстрактний метод <tt>getContents()</tt>:</p>
    
        <pre class="prettyprint lang-java">protected Object[][] getContents();</pre>
    
        <p>Зверніть увагу на те, що ключі - це <tt>Strings</tt>-и, а значення можуть належати будь-якому типу, оскільки тип масиву - це <tt>Object</tt>; далі, метод повертає список пар ключ-значення. В результаті метод <tt>getContents()</tt> повертає двовимірний масив <tt>Objects</tt>.</p>
    
        <p>
            <hr/>
            Ресурсні пакети створюються через розширення класа <tt>ListResourceBundle</tt>, в той час як з <tt>PropertyResourceBundle</tt> ресурсні пакети створюються як файли властивостей. При розширенні <tt>ListResourceBundle</tt> можна мати значення будь-якого об'єктного типу, в той час як в файлах властивостей припустимі лише <tt>Strings</tt>.
            <hr/>
        </p>
    
        <p>Лістинг <a href="#c13l05">13-5</a> містить приклад розширення <tt>ListResourceBundle</tt>, який повертає найбільший кіно-хіт для окремої локалі. Він визначає ресурсний пакет <tt>ResBundle</tt>. Оскільки ім'я класа не мвстить суфіксу (типу "<tt>_it</tt>" чи "<tt>_en_US</tt>"), то є реалізація ресурсного пакета по замовчанню. При невдачі пошуку відповідного <tt>ResBundle</tt> для якоїсь локалі буде використана ця реалізація по замовчанню.</p>
    
        <pre id="c13l05" class="prettyprint lang-java">
    // Лістинг 13-5. ResBundle.java
    import java.util.ListResourceBundle;
        // версія по замовчанню US English
        public class ResBundle extends ListResourceBundle {
            public Object[][] getContents() {
                return contents;
            }
        
        static final Object[][] contents = {
            { "MovieName", "Avatar" },
            { "GrossRevenue", (Long) 2782275172L }, // in US dollars
            { "Year", (Integer)2009 }
        };
    }
        </pre>
    
        <p>А тепер визначимо <tt>ResBundle</tt> для італійської локалі. Треба доповнити ім'я класа суфіксом "<tt>_it_IT</tt>". Код мови "<tt>it</tt>" означає італійську, а код країни "<tt>IT</tt>" - Італію (Лістинг <a href="#c13l06">13-6</a>).</p>
    
        <pre id="c13l06" class="prettyprint lang-java">
    // Лістинг 13-6. ResBundle_it_IT.java
    import java.util.ListResourceBundle;
        // Italian version
        public class ResBundle_it_IT extends ListResourceBundle {
            public Object[][] getContents() {
                return contents;
            }
        static final Object[][] contents = {
            { "MovieName", "Che Bella Giornata" },
            { "GrossRevenue", (Long) 43000000L }, // in euros
            { "Year", (Integer)2011 }
        };
    }
        </pre>
    
        <p>Як видно, реалізації <tt>ResBundle</tt> та <tt>ResBundle_it_IT</tt> однакові за винятком значень, призначених ключам. Як узнати, чи працюють ваші ресурсні пакети? В лістингу <a href="#c13l07">13-7</a> <tt>ResBundle</tt> завантажується для обох локалей: італійської та по замовчанню.</p>
    
        <pre id="c13l07" class="prettyprint lang-java">
    // Лістинг 13-7. LocalizedBoxOfficeHits.java
    import java.util.ResourceBundle;
    import java.util.Locale;
    
    public class LocalizedBoxOfficeHits {
        public void printMovieDetails(ResourceBundle resBundle) {
            String movieName = resBundle.getString("MovieName");
            Long revenue = (Long)(resBundle.getObject("GrossRevenue"));
            Integer year = (Integer) resBundle.getObject("Year");
            System.out.println("Фільм " + movieName + "(" + year + ")" + " зібрав " + revenue );
        }
    
        public static void main(String args[]) {
            LocalizedBoxOfficeHits localizedHits = new LocalizedBoxOfficeHits();
            // надрукувати найбільший кіно-хіт для локалі по замовчанню (US)
            Locale locale = Locale.getDefault();
            localizedHits.printMovieDetails(ResourceBundle.getBundle("ResBundle", locale));
            // надрукувати найбільший кіно-хіт для італійської локалі
            locale = new Locale("it", "IT", "");
            localizedHits.printMovieDetails(ResourceBundle.getBundle("ResBundle", locale));
        }
    }
        </pre>
    
        <p>Він друкує наступне:</p>
    
        <pre class="prettyprint lang-bsh">
    $ java LocalizedBoxOfficeHits 
    Фільм Avatar(2009) зібрав 2782275172
    Фільм Che Bella Giornata(2011) зібрав 43000000
        </pre>
    
        <p>Завантаження ресурсних пакетів по замовчанню та італійського успішне. Однак, мають місце проблеми з виводом. Значення <tt>2782275172</tt> - це долари США, а <tt>43000000</tt> - євро. Більш за те, числа надруковані без роздільника розрядів, та важкі для сприйняття. Можливо локалізувати форматування цих валютних значень. Питання відмінностей з форматування чисел, десяткових чисел та валют між різними локалями залишаємо на самостійне вивчення.</p>
    
        <p>Розглянемо наступний оператор нашої програми:</p>
    
        <pre class="prettyprint lang-java">Long revenue = (Long)(resBundle.getObject("GrossRevenue"));</pre>
    
        <p>Цей оператор повертає значення, співставлене в ресурсному пакеті з ключем <tt>GrossRevenue</tt>. Ми визначили його як об'єкт <tt>Long</tt> в класах <tt>ResBundle</tt> та <tt>ResBundle_it_IT</tt>. Якщо приводити типи неправильно, наприклад до <tt>Integer</tt>, отримаємо <tt>ClassCastException</tt>:</p>
    
        <pre class="prettyprint lang-java">
    Integer revenue = (Integer)(resBundle.getObject("GrossRevenue"));
    // Ця зміна в коді призведе до виникнення винятку:
    // Exception in thread "main" java.lang.ClassCastException:
    //		java.lang.Long cannot be cast to java.lang.Integer
        </pre>
    
        <p>Інша ситуація: якщо написати <tt>GrossRevenu</tt> замість <tt>GrossRevenue</tt> в якості імені ключа, програма завершиться аварійно з винятком:</p>
    
        <pre class="prettyprint lang-java">
    Long revenue = (Long)(resBundle.getObject("GrossRevenu"));
    // Цей код завершиться аварійно з винятком:
    // Exception in the thread "main" java.util.MissingResourceException:
    //		Can't find resources for bundle ResBundle, key GrossRevenu
        </pre>
    
        <p>
            <hr/>
            Надаючи ім'я ключа для отримання об'єкта з ресурсного пакету треба бути уважним: ім'я ключа чутливе до регістру та має повністю співпадати, інакше - <tt>MissingResourceException</tt>.
            <hr/>
        </p>
    
        <h2>Завантаження ресурсного пакета</h2>
    
        <p>Треба добре розуміти процес завантаження ресурсного пакета.</p>
    
        <p>Процес пошуку відповідного ресурсного пакета для класів, розширених від <tt>ListResourceBundles</tt>, такий самий, як для файлів властивостей, визначених для <tt>PropertyResourceBundles</tt>.</p>
    
        <p>
            <hr/>Щоб знайти та завантажити клас, Java використовує механізм рефлексії для ресурсних пакетів, реалізованих як класи, розширені від <tt>ListResourceBundles</tt>. Для успішного пошуку механізмом рефлексії треба впевнитися, що клас публічний.
            <hr/>
        </p>
    
        <h3>Домовленості з іменування ресурсних пакетів</h3>
    
        <p>Для створення ресурсних пакетів Java вимагає дотримання наперед заданої домовленості з іменування. Бібліотека Java завантажує відповідні локалі лише завдяки іменам пакетів властивостей. Отже, розуміти та слідувати цій домовленості з іменування при створенні пакетів властивостей для локалізації додатків Java дуже важливо.</p>
    
        <p>Ми вже знаємо, як кодується ім'я локалі. Розуміння цього кодування імені локалі важливе для іменування ресурсних пакетів, оскільки використовується та сама схема кодування. Повністю кваліфікований ресурсний пакет має таку форму:</p>
    
        <pre>packagequalifier.bundlename + "_" + language + "_" + country + "_" + (variant + "_#" | "#") + script + "-" + extensions</pre>
    
        <p>Опис елементів цього повністю кваліфікованого імені:</p>
    
        <dl>
            <dt>packagequalifier</dt>
            <dd>Ім'я пакета (чи під-пакетів), в якому надано ресурсний пакет.</dd>
    
            <dt>bundlename</dt>
            <dd>Ім'я ресурсного пакета, який має використовуватися в програмі.</dd>
            
            <dt>language</dt>
             <dd>Дволітерна абревіатура, зазвичай надана в нижньому регістрі, для мови локалі (рідко три літери).</dd>
            
            <dt>country</dt>
            <dd>Дволітерна абревіатура, зазвичай надана у верхньому регістрі, для країни локалі (рідко три літери).</dd>
            
            <dt>variant</dt>
            <dd>Необов'язковий список варіантів (в нижньому або верхньому регістрі) для розрізнення локалей, коли потрібно більше однієї локалі для комбінації мова-країна.</dd>
        </dl>
    
        <p>Опис написання та розширень опущений, оскільки вони рідко використовуються.</p>
    
        <p>Розглянемо таке повністю кваліфіковане ім'я:</p>
    
        <pre>localization.examples.AppBundle_ en_US_Oracle_exam</pre>
    
        <p>Тут <tt>localization.examples</tt> це пакет, <tt>AppBundle</tt> це ім'я ресурсного пакета, <tt>en</tt> це мова (англійська), <tt>US</tt> це країна, а <tt>Oracle_exam</tt> це варіант.</p>
    
        <p>Дво- чи три-літерні абревіатури для мови та країни локалі є наперед визначеними, оскільки базуються на міжнародних стандартах.</p>
    
        <p>Оскільки для одного імені ресурсного пакета може існувати багато ресурсних пакетів, важливо розуміти послідовність пошуку ресурсного пакета для завантаження? Уявимо цю послідовність як декілька кроків. Пошук починається з кроку 1. Якщо на якомусь кроці пошук знаходить співпадіння, ресурсний пакет завантажується. Інакше пошук переходить до іншого кроку (див. Рисунок <a href="#c13f02">13-2</a>).</p>
    
        <p><img id="c13f02" alt="Рисунок 13-2. Послідовність пошуку ResourceBundles" src="c13f02.jpg"/><br/>
        Рисунок 13-2. Послідовність пошуку <tt>ResourceBundles</tt></p>
    
        <p>Пошук починається з деталей наданої локалі, а якщо нічого не знайдено, продовжується для локалі по замовчанню:</p>
    
        <pre>
    BundleName + "_" + language + "_" + country + "_" + variant
    BundleName + "_" + language + "_" + country
    BundleName + "_" + language
    BundleName + "_" + defaultLanguage + "_" + defaultCountry
    BundleName + "_" + defaultLanguage
        </pre>
    
        <p>Розглянемо приклад пошуку ресурсного пакета. Припустимо, що в шляху пошуку є такі п'ять елементів, а локаль по амовчанню - американьска англійська.</p>
    
        <pre>
    ResourceBundle.properties 				-- Глобальний пакет
    ResourceBundle_ar.properties 			-- Пакет арабської мови
    ResourceBundle_en.properties 			-- Англійский пакет (в припущенні, що локаль по замовчанню - en_US)
    ResourceBundle_it.properties 			-- Пакет італійської мови
    ResourceBundle_it_IT_Rome.properties 	-- Італійський (Італія, Рим) пакет
        </pre>
    
        <p>
            <hr/>
            Метод <tt>getBundle()</tt> приймає додатковий параметр об'єкт <tt>ResourceBundle.Control</tt>. Розширивши клас <tt>ResourceBundle.Control</tt> та надавши екземпляр цього розширеного класа в метод <tt>getBundle()</tt>, можна змінити процес пошуку ресурсних пакетів, який використовується по замовчанню, або зчитувати не стандартні формати ресурсних пакетів (файли XML, наприклад).
            <hr/>
        </p>
    
        <p>Як можна знайти послідовність локалей, які шукає Java? Для цього розширимо клас <tt>ResourceBundle.Control</tt> та перевизначимо метод <tt>getCandidateLocales()</tt>: це - для програмного доступу до списка локалей-кандидатів та фінального відображення локалі, яка підходить. Зауважте, що під "локалямі-кандидатами" розуміються локалі, які Java приймає до уваги в процесі пошуку. Припустимо, що файли властивостей <tt>ResourceBundle_it_IT_Rome.properties</tt> та <tt>ResourceBundle_en.properties</tt> доступні. Програму наведено в лістингу <a href="#c13l08">13-8</a>.</p>
    
        <pre id="c13l08" class="prettyprint lang-java">
    // Лістинг 13-8. CandidateLocales.java
    import java.util.ResourceBundle;
    import java.util.List;
    import java.util.Locale;
    
    // Розширити ResourceBundle.Control та перевизначити метод getCandidateLocales
    // для отримання списка локалей-кандидатів, які шукає Java
    class TalkativeResourceBundleControl extends ResourceBundle.Control {
        // спочатку перевизначити метод по замовчанню getCandidateLocales
        // для друку локалей-кандидатів
        public List<Locale> getCandidateLocales(String baseName, Locale locale) {
            List<Locale> candidateLocales = super.getCandidateLocales(baseName, locale);
            System.out.printf("Локалі-кандидати для базового імені пакета %s та локалі %s %n",
                    baseName, locale.getDisplayName());
            candidateLocales.forEach(System.out::println);
            return candidateLocales;
        }
    }
    
    // Використати метод-помічник (helper) loadResourceBundle для завантаження пакета по імені пакета та локалі
    class CandidateLocales {
        public static void loadResourceBundle(String resourceBundleName, Locale locale) {
            // Передати екземпляр TalkativeResourceBundleControl
            // для друку локалей-кандидатів
            ResourceBundle resourceBundle = ResourceBundle.getBundle(resourceBundleName,
                    locale, new TalkativeResourceBundleControl());
            String rbLocaleName = resourceBundle.getLocale().toString();
            // якщо ім'я локалі ресурсного пакета порожнє,
            // це означає файл властивостей по замовчанню
            if(rbLocaleName.equals("")) {
                System.out.println("Завантажено файл властивостей по замовчанню: "
                        + resourceBundleName);
            } else {
                System.out.println("Завантажено ресурсний пакет для локалі: "
                        + resourceBundleName + "." + rbLocaleName);
            }
        }
        
        public static void main(String[] args) {
            // відследіти, як визначається ResourceBundle_it_IT_Rome.properties
            loadResourceBundle("ResourceBundle", new Locale("it", "IT", "Rome"));
        }
    }
        </pre>
    
        <p>Він друкує наступне:</p>
    
        <pre class="prettyprint lang-bsh">
    Локалі-кандидати для базового імені пакета ResourceBundle та локалі Italian (Italy, Rome) 
    it_IT_Rome
    it_IT
    it
    
    Завантажено ресурсний пакет для локалі: ResourceBundle.it
        </pre>
    
        <p>Тепер, перед тим, як продовжити спроби з іншими локалями, розглянемо, як працює програма. Для відстеження того, як Java визначає ресурсний пакет для фінального завантаження, потрібно отримати список локалей-кандидатів. В метод <tt>ResourceBundle.getBundle()</tt> передаємо додатковий аргумент, який є екземпляром класу <tt>ResourceBundle.Control</tt>. Для цього визначаємо клас <tt>TalkativeResourceBundleControl</tt>.</p>
    
        <p>Клас <tt>TalkativeResourceBundleControl</tt> розширє клас <tt>ResourceBundle.Control</tt> та перевизначає метод <tt>getCandidateLocales()</tt>. Цей метод <tt>getCandidateLocales()</tt> повертає екземпляр <tt>List&lt;Locale&gt;</tt>, який містить список локалей-кандидатів для наданої локалі. Викликаємо <tt>super.getCandidateLocales()</tt> та проходимо по отриманому об'єкту <tt>List&lt;Locale&gt;</tt> для друку локалей-кандидатів для подальшого аналізу виводу. З цього перевизначеного метода <tt>getCandidateLocales()</tt> ми просто повертаємо цей об'єкт <tt>List&lt;Locale&gt;</tt>. Тож, поведінка <tt>TalkativeResourceBundleControl</tt> є ідентичною до <tt>ResourceBundle.Control</tt> за винятком того, що перевизначений <tt>getCandidateLocales()</tt> в <tt>TalkativeResourceBundleControl</tt> друкує локалі-кандидати.</p>
    
        <p>Клас <tt>CandidateLocales</tt> використовує <tt>TalkativeResourceBundleControl</tt>. Він має допоміжний метод <tt>loadResourceBundle()</tt>, який приймає як аргументи ім'я ресурсного пакета та ім'я локалі. Цей просто передає ці аргументи в метод <tt>ResourceBundle.getBundle()</tt>; додатково він створює <tt>TalkativeResourceBundleControl</tt> та передає цей об'єкт як третій аргумент. Метод <tt>getBundle()</tt> повертає об'єкт <tt>ResourceBundle</tt>. Якщо ім'я локалі від <tt>ResourceBundle.getLocale()</tt> порожнє, це означає, що Java завантажила глобальний ресурсний пакет. Ім'я глобального ресурсного пакета не має пов'язаних з локаллю деталей. Якщо ім'я локалі не порожнє, це означає, що Java визначила відповідну окрему локаль.</p>
    
        <p>Подивимось на метод <tt>main()</tt>. Він викликає <tt>loadResourceBundle()</tt> для локалі <tt>it_IT_Rome</tt>. Існує три локалі-кандидата, з яких було правильно завантажено відповідний файл властивостей для локалі <tt>it_IT_Rome</tt>. Тож, ми бачимо, що файл властивостей <tt>ResourceBundle_it_IT_Rome.properties</tt> завантажено вірно.</p>
    
        <p>В продовження експерименту змінимо код всередині метода <tt>main()</tt> в лістингу <a href="#c13l08">13-8</a> на цей:</p>
    
        <pre class="prettyprint lang-java">loadResourceBundle("ResourceBundle", new Locale("fr", "CA", ""));</pre>
    
        <p>Тепер програма друкує наступне:</p>
    
        <pre class="prettyprint lang-bsh">
    $ java CandidateLocales
    Локалі-кандидати для базового імені пакета ResourceBundle та локалі French (Canada) 
    fr_CA
    fr
    
    Локалі-кандидати для базового імені пакета ResourceBundle та локалі English (United States) 
    en_US
    en
    
    Завантажено файл властивостей по замовчанню: ResourceBundle
        </pre>
    
        <p>Чому вивід саме такий? Зауважте, що відповідного файла властивостей для локалі <tt>fr_CA</tt> немає в переліку файлів властивостей. Отже, пошук продовжується до перевірки файлів властивостей для локалі по замовчанню. В нашому випадку, локаль по замовчанню це <tt>en_US</tt>, та існує файл властивостей для локалі  en (English). Отже, у виборі серед локалей-кандидатів Java правильно вирішує завантажити файл властивостей <tt>ResourceBundle_en.properties</tt>.</p>
    
        <p>І останній приклад. Замінимо код в методі <tt>main()</tt> цим оператором:</p>
    
        <pre class="prettyprint lang-java">loadResourceBundle("ResBundl", Locale.getDefault());</pre>
    
        <p>Програма надрукує:</p>
    
        <pre class="prettyprint lang-bsh">
    $ java CandidateLocales
    Локалі-кандидати для базового імені пакета ResBundl та локалі English (United States) 
    en_US
    en
    
    Exception in thread "main" java.util.MissingResourceException: Can't find bundle for base name ResBundl, locale en_US
        at java.base/java.util.ResourceBundle.throwMissingResourceException(ResourceBundle.java:2055)
            [...]
        </pre>
    
        <p>Ми не маємо ресурсного пакета <tt>ResBundl</tt>, та надаємо локаль по замовчанню (<tt>en_US</tt>). Java шукає пакет для цієї локалі, та ми знаємо, що не надали жодного пакета з іменем <tt>ResBundl</tt>. Отже, програма заверується аварійно з винятком <tt>MissingResourceException</tt>.</p>
    
        <h2>Підсумки</h2>
    
        <p>Читання та встановлення локалі з використанням об'єкта <tt>Locale</tt></p>
    
        <ul>
            <li><i>Лкаль</i> представляє мову, культуру чи країну; клас <tt>Locale</tt> в Java пропонує абстракцію цієї концепції.</li>
            <li>Кожна локаль може мати три елементи: мову, країну та варіант. Можна використовувати стандартні коди мов та країн для формування міток локалей. Для варіантів стандартних кодів не існує; для них можна застосовувати рядки згідно з потребами</li>
            <li>Методи-геттери в класі <tt>Locale</tt>, такі як <tt>getLanguage()</tt>, <tt>getCountry()</tt> та <tt>getVariant()</tt>, повертають коди; аналогічні методи <tt>getDisplayCountry()</tt>, <tt>getDisplayLanguage()</tt> та <tt>getDisplayVariant()</tt> повертають імена.</li>
            <li>Метод <tt>getDefault()</tt> в <tt>Locale</tt> повертає локаль по замовчанню, встановлену в JVM. Можна змінити цю локаль по замовчанню на іншу локаль за допомогою метода <tt>setDefault()</tt>.</li>
            <li>Є багато способів створити чи отримати об'єкт <tt>Locale</tt>, відповідний до локалі:</li>
            <ul>
                <li>Використання конструктора класа <tt>Locale</tt>.</li>
                <li>Використання метода <tt>forLanguageTag(String languageTag)</tt> в класі <tt>Locale</tt>.</li>
                <li>Побудова об'єкта <tt>Locale</tt> шляхом створення <tt>Locale.Builder</tt> та виклику <tt>setLanguageTag()</tt> на цьому об'єкті.</li>
                <li>Використання наперед заданих констант для локалей в класі <tt>Locale</tt>.</li>
            </ul>
        </ul>
    
        <p>Створення та читання файла властивостей</p>
    
        <ul>
            <li>Ресурсний пакет це набір класів або файлів властивостей, які допомагають поставити у відповідність ключам локально-специфічні значення.</li>
            <li>Клас <tt>ResourceBundle</tt> має два класи-потомки: <tt>PropertyResourceBundle</tt> та <tt>ListResourceBundle</tt>. Можна використовувати <tt>ResourceBundle.getBundle()</tt> для отримання пакету для даної локалі.</li>
            <li>Клас <tt>PropertyResourceBundle</tt> пропонує підтримку багатьох локалей у формі файлів властивостей. Для кожної локалі у файлі властивостей надається набір пар ключ-значення. Для ключів та значень припустимі лише <tt>String</tt>.</li>
            <li>Для додавання підтримки нової локалі можна розширити клас <tt>ListResourceBundle</tt>. В породженому класі треба перевизначити метод <tt>Object [][] getContents()</tt>. Масив, який повертається, має містити список ключів та значень. Ключі мають бути <tt>String</tt>, а значення можуть бути будь-якими об'єктами.</li>
            <li>При передачі рядка ключа в метод <tt>getObject()</tt> для отримання відповідного значення з ресурсного пакету, впевніться в тому, що наданий ключ та ключ в ресурсному пакеті точно співпадають (ям'я ключа чутливе до регістру). Якщо вони не співпадають, виникне <tt>MissingResourceException</tt>.</li>
            <li>Домовленість для повністю кваліфікованих імен ресурсних пакетів: <tt>packagequalifier.bundlename + "_" + language + "_" + country + "_" + (variant + "_#" | "#") + script + "-" + extensions</tt>.</li>
        </ul>
    
         <p>Побудова ресурсного пакета для кожної локалі та завантаження ресурсного пакета в програму</p>
    
         <ul>
             <li>Процес пошуку відповідного ресурсного пакета однаковий для класів, розширених від <tt>ListResourceBundles</tt>, та файлів властивостей, визначених для <tt>PropertyResourceBundles</tt>.</li>
             <li>Нижче наведено послідовність пошуку відповідного ресурсного пакета. Пошук починаєтсья з кроку 1. Якщо на будь-якому кроці пошук знаходить відповідність, ресурсний пакет завантажується. Інакше, пошук переходить до наступного кроку.
                 <ul>
                     <li><b>Крок 1</b>: Процес починається з пошуку точного співпадіння ресурсного пакета з повним ім'ям.</li>
                     <li><b>Крок 2</b>: Останній компонент (частина, відокремлена <tt>_</tt>) опускається, та пошук повторюється з отриманим коротшим іменем. <i>Цей процес повторюється доки не залишається останній модифікатор локалі</i>.</li>
                     <li><b>Крок 3</b>: Пошук продовжується з використанням повного імені пакета для локалі по замовчанню.</li>
                     <li><b>Крок 4</b>: Пошук ресурсного пакета лише по імені пакета.</li>
                     <li><b>Крок 5</b>: Пошук хибить з винятком <tt>MissingBundleException</tt>.</li>
                 </ul>
             </li>
             <li>Метод <tt>getBundle()</tt> приймає об'єкт <tt>ResourceBundle.Control</tt> в якості додаткового параметра. Розширивши цей клас <tt>ResourceBundle.Control</tt> та передавши його об'єкт, можна управляти на налаштовувати процес пошуку та завантаження ресурсного пакета.</li>
         </ul>
         
    </body>
</html>
